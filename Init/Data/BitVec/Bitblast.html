<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Init.Data.BitVec.Bitblast</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Init.Data.BitVec.Bitblast";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Init</span>.<span class="name">Data</span>.<span class="name">BitVec</span>.<span class="name">Bitblast</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init/Data/BitVec/Folds.html">Init.Data.BitVec.Folds</a></li><li><a href="../../.././Init/Data/Nat/Mod.html">Init.Data.Nat.Mod</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Init.Data.BitVec.Bitblast" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Bool.atLeastTwo"><span class="name">Bool</span>.<span class="name">atLeastTwo</span></a></div><div class="nav_link"><a class="break_within" href="#Bool.atLeastTwo_false_left"><span class="name">Bool</span>.<span class="name">atLeastTwo_false_left</span></a></div><div class="nav_link"><a class="break_within" href="#Bool.atLeastTwo_false_mid"><span class="name">Bool</span>.<span class="name">atLeastTwo_false_mid</span></a></div><div class="nav_link"><a class="break_within" href="#Bool.atLeastTwo_false_right"><span class="name">Bool</span>.<span class="name">atLeastTwo_false_right</span></a></div><div class="nav_link"><a class="break_within" href="#Bool.atLeastTwo_true_left"><span class="name">Bool</span>.<span class="name">atLeastTwo_true_left</span></a></div><div class="nav_link"><a class="break_within" href="#Bool.atLeastTwo_true_mid"><span class="name">Bool</span>.<span class="name">atLeastTwo_true_mid</span></a></div><div class="nav_link"><a class="break_within" href="#Bool.atLeastTwo_true_right"><span class="name">Bool</span>.<span class="name">atLeastTwo_true_right</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.carry"><span class="name">BitVec</span>.<span class="name">carry</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.carry_zero"><span class="name">BitVec</span>.<span class="name">carry_zero</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.carry_succ"><span class="name">BitVec</span>.<span class="name">carry_succ</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.carry_succ_one"><span class="name">BitVec</span>.<span class="name">carry_succ_one</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.carry_of_and_eq_zero"><span class="name">BitVec</span>.<span class="name">carry_of_and_eq_zero</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.carry_width"><span class="name">BitVec</span>.<span class="name">carry_width</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.toNat_add_of_and_eq_zero"><span class="name">BitVec</span>.<span class="name">toNat_add_of_and_eq_zero</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.adcb"><span class="name">BitVec</span>.<span class="name">adcb</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.adc"><span class="name">BitVec</span>.<span class="name">adc</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.getLsbD_add_add_bool"><span class="name">BitVec</span>.<span class="name">getLsbD_add_add_bool</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.getLsbD_add"><span class="name">BitVec</span>.<span class="name">getLsbD_add</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.getElem_add_add_bool"><span class="name">BitVec</span>.<span class="name">getElem_add_add_bool</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.getElem_add"><span class="name">BitVec</span>.<span class="name">getElem_add</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.adc_spec"><span class="name">BitVec</span>.<span class="name">adc_spec</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.add_eq_adc"><span class="name">BitVec</span>.<span class="name">add_eq_adc</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.getMsbD_add"><span class="name">BitVec</span>.<span class="name">getMsbD_add</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.msb_add"><span class="name">BitVec</span>.<span class="name">msb_add</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.add_not_self"><span class="name">BitVec</span>.<span class="name">add_not_self</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.allOnes_sub_eq_not"><span class="name">BitVec</span>.<span class="name">allOnes_sub_eq_not</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.add_eq_or_of_and_eq_zero"><span class="name">BitVec</span>.<span class="name">add_eq_or_of_and_eq_zero</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.getLsbD_sub"><span class="name">BitVec</span>.<span class="name">getLsbD_sub</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.getMsbD_sub"><span class="name">BitVec</span>.<span class="name">getMsbD_sub</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.msb_sub"><span class="name">BitVec</span>.<span class="name">msb_sub</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.bit_not_testBit"><span class="name">BitVec</span>.<span class="name">bit_not_testBit</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.bit_not_add_self"><span class="name">BitVec</span>.<span class="name">bit_not_add_self</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.bit_not_eq_not"><span class="name">BitVec</span>.<span class="name">bit_not_eq_not</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.bit_neg_eq_neg"><span class="name">BitVec</span>.<span class="name">bit_neg_eq_neg</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.getLsbD_neg"><span class="name">BitVec</span>.<span class="name">getLsbD_neg</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.getMsbD_neg"><span class="name">BitVec</span>.<span class="name">getMsbD_neg</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.msb_neg"><span class="name">BitVec</span>.<span class="name">msb_neg</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.msb_abs"><span class="name">BitVec</span>.<span class="name">msb_abs</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.ult_eq_not_carry"><span class="name">BitVec</span>.<span class="name">ult_eq_not_carry</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.ule_eq_not_ult"><span class="name">BitVec</span>.<span class="name">ule_eq_not_ult</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.ule_eq_carry"><span class="name">BitVec</span>.<span class="name">ule_eq_carry</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.slt_eq_ult_of_msb_eq"><span class="name">BitVec</span>.<span class="name">slt_eq_ult_of_msb_eq</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.ult_eq_msb_of_msb_neq"><span class="name">BitVec</span>.<span class="name">ult_eq_msb_of_msb_neq</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.slt_eq_not_ult_of_msb_neq"><span class="name">BitVec</span>.<span class="name">slt_eq_not_ult_of_msb_neq</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.slt_eq_ult"><span class="name">BitVec</span>.<span class="name">slt_eq_ult</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.slt_eq_not_carry"><span class="name">BitVec</span>.<span class="name">slt_eq_not_carry</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.sle_eq_not_slt"><span class="name">BitVec</span>.<span class="name">sle_eq_not_slt</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.sle_eq_carry"><span class="name">BitVec</span>.<span class="name">sle_eq_carry</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.mulRec"><span class="name">BitVec</span>.<span class="name">mulRec</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.mulRec_zero_eq"><span class="name">BitVec</span>.<span class="name">mulRec_zero_eq</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.mulRec_succ_eq"><span class="name">BitVec</span>.<span class="name">mulRec_succ_eq</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.setWidth_setWidth_succ_eq_setWidth_setWidth_add_twoPow"><span class="name">BitVec</span>.<span class="name">setWidth_setWidth_succ_eq_setWidth_setWidth_add_twoPow</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.zeroExtend_truncate_succ_eq_zeroExtend_truncate_add_twoPow"><span class="name">BitVec</span>.<span class="name">zeroExtend_truncate_succ_eq_zeroExtend_truncate_add_twoPow</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.mulRec_eq_mul_signExtend_setWidth"><span class="name">BitVec</span>.<span class="name">mulRec_eq_mul_signExtend_setWidth</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.mulRec_eq_mul_signExtend_truncate"><span class="name">BitVec</span>.<span class="name">mulRec_eq_mul_signExtend_truncate</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.getLsbD_mul"><span class="name">BitVec</span>.<span class="name">getLsbD_mul</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.getElem_mul"><span class="name">BitVec</span>.<span class="name">getElem_mul</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.shiftLeftRec"><span class="name">BitVec</span>.<span class="name">shiftLeftRec</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.shiftLeftRec_zero"><span class="name">BitVec</span>.<span class="name">shiftLeftRec_zero</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.shiftLeftRec_succ"><span class="name">BitVec</span>.<span class="name">shiftLeftRec_succ</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.shiftLeft_or_of_and_eq_zero"><span class="name">BitVec</span>.<span class="name">shiftLeft_or_of_and_eq_zero</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.shiftLeftRec_eq"><span class="name">BitVec</span>.<span class="name">shiftLeftRec_eq</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.shiftLeft_eq_shiftLeftRec"><span class="name">BitVec</span>.<span class="name">shiftLeft_eq_shiftLeftRec</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.udiv_eq_of_mul_add_toNat"><span class="name">BitVec</span>.<span class="name">udiv_eq_of_mul_add_toNat</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.umod_eq_of_mul_add_toNat"><span class="name">BitVec</span>.<span class="name">umod_eq_of_mul_add_toNat</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.DivModState"><span class="name">BitVec</span>.<span class="name">DivModState</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.DivModArgs"><span class="name">BitVec</span>.<span class="name">DivModArgs</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.DivModState.Lawful"><span class="name">BitVec</span>.<span class="name">DivModState</span>.<span class="name">Lawful</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.DivModState.Lawful.hw"><span class="name">BitVec</span>.<span class="name">DivModState</span>.<span class="name">Lawful</span>.<span class="name">hw</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.DivModState.init"><span class="name">BitVec</span>.<span class="name">DivModState</span>.<span class="name">init</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.DivModState.lawful_init"><span class="name">BitVec</span>.<span class="name">DivModState</span>.<span class="name">lawful_init</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.DivModState.udiv_eq_of_lawful"><span class="name">BitVec</span>.<span class="name">DivModState</span>.<span class="name">udiv_eq_of_lawful</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.DivModState.umod_eq_of_lawful"><span class="name">BitVec</span>.<span class="name">DivModState</span>.<span class="name">umod_eq_of_lawful</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.DivModState.Poised"><span class="name">BitVec</span>.<span class="name">DivModState</span>.<span class="name">Poised</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.DivModState.wr_lt_w"><span class="name">BitVec</span>.<span class="name">DivModState</span>.<span class="name">wr_lt_w</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.divSubtractShift"><span class="name">BitVec</span>.<span class="name">divSubtractShift</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.DivModState.toNat_shiftRight_sub_one_eq"><span class="name">BitVec</span>.<span class="name">DivModState</span>.<span class="name">toNat_shiftRight_sub_one_eq</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.lawful_divSubtractShift"><span class="name">BitVec</span>.<span class="name">lawful_divSubtractShift</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.divRec"><span class="name">BitVec</span>.<span class="name">divRec</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.divRec_zero"><span class="name">BitVec</span>.<span class="name">divRec_zero</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.divRec_succ"><span class="name">BitVec</span>.<span class="name">divRec_succ</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.lawful_divRec"><span class="name">BitVec</span>.<span class="name">lawful_divRec</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.wn_divRec"><span class="name">BitVec</span>.<span class="name">wn_divRec</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.udiv_eq_divRec"><span class="name">BitVec</span>.<span class="name">udiv_eq_divRec</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.umod_eq_divRec"><span class="name">BitVec</span>.<span class="name">umod_eq_divRec</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.divRec_succ'"><span class="name">BitVec</span>.<span class="name">divRec_succ'</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.sshiftRightRec"><span class="name">BitVec</span>.<span class="name">sshiftRightRec</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.sshiftRightRec_zero_eq"><span class="name">BitVec</span>.<span class="name">sshiftRightRec_zero_eq</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.sshiftRightRec_succ_eq"><span class="name">BitVec</span>.<span class="name">sshiftRightRec_succ_eq</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.sshiftRight'_or_of_and_eq_zero"><span class="name">BitVec</span>.<span class="name">sshiftRight'_or_of_and_eq_zero</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.sshiftRightRec_eq"><span class="name">BitVec</span>.<span class="name">sshiftRightRec_eq</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.sshiftRight_eq_sshiftRightRec"><span class="name">BitVec</span>.<span class="name">sshiftRight_eq_sshiftRightRec</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.ushiftRightRec"><span class="name">BitVec</span>.<span class="name">ushiftRightRec</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.ushiftRightRec_zero"><span class="name">BitVec</span>.<span class="name">ushiftRightRec_zero</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.ushiftRightRec_succ"><span class="name">BitVec</span>.<span class="name">ushiftRightRec_succ</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.ushiftRight'_or_of_and_eq_zero"><span class="name">BitVec</span>.<span class="name">ushiftRight'_or_of_and_eq_zero</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.ushiftRightRec_eq"><span class="name">BitVec</span>.<span class="name">ushiftRightRec_eq</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.shiftRight_eq_ushiftRightRec"><span class="name">BitVec</span>.<span class="name">shiftRight_eq_ushiftRightRec</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Bitblasting-of-bitvectors">Bitblasting of bitvectors <a class="hover-link" href="#Bitblasting-of-bitvectors">#</a></h1><p>This module provides theorems for showing the equivalence between BitVec operations using
the <code><a href="../../.././Init/Prelude.html#Fin">Fin</a> 2^n</code> representation and Boolean vectors.  It is still under development, but
intended to provide a path for converting SAT and SMT solver proofs about BitVectors
as vectors of bits into proofs about Lean <code><a href="../../.././Init/Prelude.html#BitVec">BitVec</a></code> values.</p><p>The module is named for the bit-blasting operation in an SMT solver that converts bitvector
expressions into expressions about individual bits in each vector.</p><h3 class="markdown-heading" id="Example-How-bitblasting-works-for-multiplication">Example: How bitblasting works for multiplication <a class="hover-link" href="#Example-How-bitblasting-works-for-multiplication">#</a></h3><p>We explain how the lemmas here are used for bitblasting,
by using multiplication as a prototypical example.
Other bitblasters for other operations follow the same pattern.
To bitblast a multiplication of the form <code>x * y</code>,
we must unfold the above into a form that the SAT solver understands.</p><p>We assume that the solver already knows how to bitblast addition.
This is known to <code>bv_decide</code>, by exploiting the lemma <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.add_eq_adc">add_eq_adc</a></code>,
which says that <code>x + y : <a href="../../.././Init/Prelude.html#BitVec">BitVec</a> w</code> equals <code>(adc x y false).2</code>,
where <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.adc">adc</a></code> builds an add-carry circuit in terms of the primitive operations
(bitwise and, bitwise or, bitwise xor) that bv_decide already understands.
In this way, we layer bitblasters on top of each other,
by reducing the multiplication bitblaster to an addition operation.</p><p>The core lemma is given by <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.getLsbD_mul">getLsbD_mul</a></code>:</p><pre><code class="language-lean"> x y : <a href="../../.././Init/Prelude.html#BitVec">BitVec</a> w ⊢ (x * y).getLsbD i = (mulRec x y w).getLsbD i
</code></pre><p>Which says that the <code>i</code>th bit of <code>x * y</code> can be obtained by
evaluating the <code>i</code>th bit of <code>(mulRec x y w)</code>.
Once again, we assume that <code>bv_decide</code> knows how to implement <code>getLsbD</code>,
given that <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.mulRec">mulRec</a></code> can be understood by <code>bv_decide</code>.</p><p>We write two lemmas to enable <code>bv_decide</code> to unfold <code>(mulRec x y w)</code>
into a complete circuit, <strong>when <code>w</code> is a known constant</strong><code>. This is given by two recurrence lemmas, </code>mulRec_zero_eq<code>and</code>mulRec_succ_eq<code>, which are applied repeatedly when the width is </code>0<code>and when the width is</code>w' + 1`:</p><pre><code class="language-lean"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.mulRec_zero_eq">mulRec_zero_eq</a> :
    <a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.mulRec">mulRec</a> x y 0 =
      if y.getLsbD 0 then x else 0

<a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.mulRec_succ_eq">mulRec_succ_eq</a>
    <a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.mulRec">mulRec</a> x y (s + 1) =
      <a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.mulRec">mulRec</a> x y s +
      if y.getLsbD (s + 1) then (x &lt;&lt;&lt; (s + 1)) else 0 := <a href="../../.././Init/Prelude.html#rfl">rfl</a>
</code></pre><p>By repeatedly applying the lemmas <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.mulRec_zero_eq">mulRec_zero_eq</a></code> and <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.mulRec_succ_eq">mulRec_succ_eq</a></code>,
one obtains a circuit for multiplication.
Note that this circuit uses <code><a href="../../.././Init/Data/BitVec/BasicAux.html#BitVec.add">BitVec.add</a></code>, <code><a href="../../.././Init/Data/BitVec/Basic.html#BitVec.getLsbD">BitVec.getLsbD</a></code>, <code><a href="../../.././Init/Data/BitVec/Basic.html#BitVec.shiftLeft">BitVec.shiftLeft</a></code>.
Here, <code><a href="../../.././Init/Data/BitVec/BasicAux.html#BitVec.add">BitVec.add</a></code> and <code><a href="../../.././Init/Data/BitVec/Basic.html#BitVec.shiftLeft">BitVec.shiftLeft</a></code> are (recursively) bitblasted by <code>bv_decide</code>,
using the lemmas <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.add_eq_adc">add_eq_adc</a></code> and <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.shiftLeft_eq_shiftLeftRec">shiftLeft_eq_shiftLeftRec</a></code>,
and <code><a href="../../.././Init/Data/BitVec/Basic.html#BitVec.getLsbD">BitVec.getLsbD</a></code> is a primitive that <code>bv_decide</code> knows how to reduce to SAT.</p><p>The two lemmas, <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.mulRec_zero_eq">mulRec_zero_eq</a></code>, and <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.mulRec_succ_eq">mulRec_succ_eq</a></code>,
are used in <code><a href="../../.././Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Impl/Operations/Mul.html#Std.Tactic.BVDecide.BVExpr.bitblast.blastMul">Std.Tactic.BVDecide.BVExpr.bitblast.blastMul</a></code>
to prove the correctness of the circuit that is built by <code>bv_decide</code>.</p><pre><code class="language-lean">def blastMul (aig : AIG BVBit) (input : AIG.BinaryRefVec aig w) : AIG.RefVecEntry BVBit w
theorem denote_blastMul (aig : AIG BVBit) (lhs rhs : <a href="../../.././Init/Prelude.html#BitVec">BitVec</a> w) (assign : Assignment) :
   ...
   ⟦(blastMul aig input).aig, (blastMul aig input).vec.get idx hidx, assign.toAIGAssignment⟧
     =
   (lhs * rhs).getLsbD idx
</code></pre><p>The definition and theorem above are internal to <code>bv_decide</code>,
and use <code>mulRec_{zero,succ}_eq</code> to prove that the circuit built by <code>bv_decide</code>
computes the correct value for multiplication.</p><p>To zoom out, therefore, we follow two steps:
First, we prove bitvector lemmas to unfold a high-level operation (such as multiplication)
into already bitblastable operations (such as addition and left shift).
We then use these lemmas to prove the correctness of the circuit that <code>bv_decide</code> builds.</p><p>We use this workflow to implement bitblasting for all SMT-LIB2 operations.</p><h2 class="markdown-heading" id="Main-results">Main results <a class="hover-link" href="#Main-results">#</a></h2><ul>
<li><code>x + y : <a href="../../.././Init/Prelude.html#BitVec">BitVec</a> w</code> is <code>(adc x y false).2</code>.</li>
</ul><h2 class="markdown-heading" id="Future-work">Future work <a class="hover-link" href="#Future-work">#</a></h2><p>All other operations are to be PR'ed later and are already proved in
<a href="https://github.com/mhk119/lean-smt/blob/bitvec/Smt/Data/Bitwise.lean">https://github.com/mhk119/lean-smt/blob/bitvec/Smt/Data/Bitwise.lean</a>.</p></div><div class="decl" id="Bool.atLeastTwo"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L111-L112">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#Bool.atLeastTwo"><span class="name">Bool</span>.<span class="name">atLeastTwo</span></a></span><span class="decl_args">
<span class="fn">(a b c : <a href="../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Bool">Bool</a></div></div><p>At least two out of three booleans are true.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span>.atLeastTwo</span> <span class="fn">b</span> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn">c</span></span></span> <a href="../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn">c</span></span>)</span></span></li></ul></details><details id="instances-for-list-Bool.atLeastTwo" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Bool.atLeastTwo_false_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L114-L114">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#Bool.atLeastTwo_false_left"><span class="name">Bool</span>.<span class="name">atLeastTwo_false_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b c : <a href="../../.././Init/Prelude.html#Bool">Bool</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Bool.false">false</a>.atLeastTwo</span> <span class="fn">b</span> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">b</span> <a href="../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn">c</span>)</span></span></div></div></div></div><div class="decl" id="Bool.atLeastTwo_false_mid"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L115-L115">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#Bool.atLeastTwo_false_mid"><span class="name">Bool</span>.<span class="name">atLeastTwo_false_mid</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a c : <a href="../../.././Init/Prelude.html#Bool">Bool</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span>.atLeastTwo</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">a</span> <a href="../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn">c</span>)</span></span></div></div></div></div><div class="decl" id="Bool.atLeastTwo_false_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L116-L116">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#Bool.atLeastTwo_false_right"><span class="name">Bool</span>.<span class="name">atLeastTwo_false_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../../.././Init/Prelude.html#Bool">Bool</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span>.atLeastTwo</span> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">a</span> <a href="../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn">b</span>)</span></span></div></div></div></div><div class="decl" id="Bool.atLeastTwo_true_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L117-L117">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#Bool.atLeastTwo_true_left"><span class="name">Bool</span>.<span class="name">atLeastTwo_true_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b c : <a href="../../.././Init/Prelude.html#Bool">Bool</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Bool.true">true</a>.atLeastTwo</span> <span class="fn">b</span> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">b</span> <a href="../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn">c</span>)</span></span></div></div></div></div><div class="decl" id="Bool.atLeastTwo_true_mid"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L118-L118">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#Bool.atLeastTwo_true_mid"><span class="name">Bool</span>.<span class="name">atLeastTwo_true_mid</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a c : <a href="../../.././Init/Prelude.html#Bool">Bool</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span>.atLeastTwo</span> <a href="../../.././Init/Prelude.html#Bool.true">true</a> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">a</span> <a href="../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn">c</span>)</span></span></div></div></div></div><div class="decl" id="Bool.atLeastTwo_true_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L119-L119">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#Bool.atLeastTwo_true_right"><span class="name">Bool</span>.<span class="name">atLeastTwo_true_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../../.././Init/Prelude.html#Bool">Bool</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span>.atLeastTwo</span> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Bool.true">true</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">a</span> <a href="../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn">b</span>)</span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Preliminaries">Preliminaries <a class="hover-link" href="#Preliminaries">#</a></h3></div><div class="mod_doc"><h3 class="markdown-heading" id="Addition">Addition <a class="hover-link" href="#Addition">#</a></h3></div><div class="decl" id="BitVec.carry"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L161-L163">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.carry"><span class="name">BitVec</span>.<span class="name">carry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(i : <a href="../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(x y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <a href="../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Bool">Bool</a></div></div><p>carry i x y c returns true if the <code>i</code> carry bit is true when computing <code>x + y + c</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.carry">BitVec.carry</a> <span class="fn">i</span> <span class="fn">x</span> <span class="fn">y</span> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#Decidable.decide">decide</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.toNat</span> <a href="../../.././Init/Prelude.html#HMod.hMod">%</a> <span class="fn"><span class="fn">2</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">i</span></span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn"><span class="fn">y</span>.toNat</span> <a href="../../.././Init/Prelude.html#HMod.hMod">%</a> <span class="fn"><span class="fn">2</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">i</span></span></span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">c</span>.toNat</span></span> <a href="../../.././Init/Prelude.html#GE.ge">≥</a> <span class="fn"><span class="fn">2</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">i</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-BitVec.carry" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="BitVec.carry_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L165-L166">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.carry_zero"><span class="name">BitVec</span>.<span class="name">carry_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w✝ : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w✝</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../../.././Init/Prelude.html#Bool">Bool</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.carry">BitVec.carry</a> <span class="fn">0</span> <span class="fn">x</span> <span class="fn">y</span> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="BitVec.carry_succ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L168-L175">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.carry_succ"><span class="name">BitVec</span>.<span class="name">carry_succ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(i : <a href="../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(x y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <a href="../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.carry">BitVec.carry</a> <span class="fn">(<span class="fn">i</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span>)</span> <span class="fn">x</span> <span class="fn">y</span> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">x</span>.getLsbD</span> <span class="fn">i</span>)</span>.atLeastTwo</span> <span class="fn">(<span class="fn"><span class="fn">y</span>.getLsbD</span> <span class="fn">i</span>)</span> <span class="fn">(<a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.carry">BitVec.carry</a> <span class="fn">i</span> <span class="fn">x</span> <span class="fn">y</span> <span class="fn">c</span>)</span></span></span></div></div></div></div><div class="decl" id="BitVec.carry_succ_one"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L177-L199">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.carry_succ_one"><span class="name">BitVec</span>.<span class="name">carry_succ_one</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(i : <a href="../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.carry">BitVec.carry</a> <span class="fn">(<span class="fn">i</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span>)</span> <span class="fn">x</span> <span class="fn">(1#<span class="fn">w</span>)</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#Decidable.decide">decide</a> <span class="fn">(∀ (<span class="fn">j</span> : <a href="../../.././Init/Prelude.html#Nat">Nat</a>), <span class="fn"><span class="fn"><span class="fn">j</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">i</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.getLsbD</span> <span class="fn">j</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a></span></span>)</span></span></span></div></div></div></div><div class="decl" id="BitVec.carry_of_and_eq_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L201-L212">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.carry_of_and_eq_zero"><span class="name">BitVec</span>.<span class="name">carry_of_and_eq_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w i : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#HAnd.hAnd">&amp;&amp;&amp;</a> <span class="fn">y</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">0#<span class="fn">w</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.carry">BitVec.carry</a> <span class="fn">i</span> <span class="fn">x</span> <span class="fn">y</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.false">false</a></span></div></div><p>If <code>x &amp;&amp;&amp; y = 0</code>, then the carry bit <code>(x + y + 0)</code> is always <code>false</code> for any index <code>i</code>.
Intuitively, this is because a carry is only produced when at least two of <code>x</code>, <code>y</code>, and the
previous carry are true. However, since <code>x &amp;&amp;&amp; y = 0</code>, at most one of <code>x, y</code> can be true,
and thus we never have a previous carry, which means that the sum cannot produce a carry.</p></div></div><div class="decl" id="BitVec.carry_width"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L214-L217">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.carry_width"><span class="name">BitVec</span>.<span class="name">carry_width</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../../.././Init/Prelude.html#Bool">Bool</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.carry">BitVec.carry</a> <span class="fn">w</span> <span class="fn">x</span> <span class="fn">y</span> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#Decidable.decide">decide</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.toNat</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">y</span>.toNat</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">c</span>.toNat</span></span> <a href="../../.././Init/Prelude.html#GE.ge">≥</a> <span class="fn"><span class="fn">2</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">w</span></span>)</span></span></span></div></div><p>The final carry bit when computing <code>x + y + c</code> is <code>true</code> iff <code>x.toNat + y.toNat + c.toNat ≥ 2^w</code>.</p></div></div><div class="decl" id="BitVec.toNat_add_of_and_eq_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L219-L230">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.toNat_add_of_and_eq_zero"><span class="name">BitVec</span>.<span class="name">toNat_add_of_and_eq_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#HAnd.hAnd">&amp;&amp;&amp;</a> <span class="fn">y</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">0#<span class="fn">w</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn">x</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">y</span>)</span>.toNat</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">x</span>.toNat</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">y</span>.toNat</span></span></span></div></div><p>If <code>x &amp;&amp;&amp; y = 0</code>, then addition does not overflow, and thus <code>(x + y).toNat = x.toNat + y.toNat</code>.</p></div></div><div class="decl" id="BitVec.adcb"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L232-L233">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.adcb"><span class="name">BitVec</span>.<span class="name">adcb</span></a></span><span class="decl_args">
<span class="fn">(x y c : <a href="../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Bool">Bool</a> <a href="../../.././Init/Prelude.html#Prod">×</a> <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Carry function for bitwise addition.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.adcb">BitVec.adcb</a> <span class="fn">x</span> <span class="fn">y</span> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">x</span>.atLeastTwo</span> <span class="fn">y</span> <span class="fn">c</span></span>, <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Data/Bool.html#Bool.xor">^^</a> <span class="fn">(<span class="fn">y</span> <a href="../../.././Init/Data/Bool.html#Bool.xor">^^</a> <span class="fn">c</span>)</span></span>)</span></span></li></ul></details><details id="instances-for-list-BitVec.adcb" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="BitVec.adc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L235-L237">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.adc"><span class="name">BitVec</span>.<span class="name">adc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Bool">Bool</a> → <span class="fn"><a href="../../.././Init/Prelude.html#Bool">Bool</a> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span></span></span></div></div><p>Bitwise addition implemented via a ripple carry adder.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.adc</span> <span class="fn">y</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Folds.html#BitVec.iunfoldr">BitVec.iunfoldr</a> <span class="fn">fun (<span class="fn">i</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">w</span></span>) (<span class="fn">c</span> : <a href="../../.././Init/Prelude.html#Bool">Bool</a>) =&gt; <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.adcb">BitVec.adcb</a> <span class="fn">(<span class="fn"><span class="fn">x</span>.getLsbD</span> <span class="fn">↑<span class="fn">i</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">y</span>.getLsbD</span> <span class="fn">↑<span class="fn">i</span></span>)</span> <span class="fn">c</span></span></span></span></span></li></ul></details><details id="instances-for-list-BitVec.adc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="BitVec.getLsbD_add_add_bool"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L239-L258">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.getLsbD_add_add_bool"><span class="name">BitVec</span>.<span class="name">getLsbD_add_add_bool</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w i : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(i_lt : <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <a href="../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">y</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Basic.html#BitVec.setWidth">BitVec.setWidth</a> <span class="fn">w</span> <span class="fn">(<a href="../../.././Init/Data/BitVec/Basic.html#BitVec.ofBool">BitVec.ofBool</a> <span class="fn">c</span>)</span></span>)</span>.getLsbD</span> <span class="fn">i</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">x</span>.getLsbD</span> <span class="fn">i</span></span> <a href="../../.././Init/Data/Bool.html#Bool.xor">^^</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">y</span>.getLsbD</span> <span class="fn">i</span></span> <a href="../../.././Init/Data/Bool.html#Bool.xor">^^</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.carry">BitVec.carry</a> <span class="fn">i</span> <span class="fn">x</span> <span class="fn">y</span> <span class="fn">c</span></span>)</span>)</span></span></div></div></div></div><div class="decl" id="BitVec.getLsbD_add"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L260-L263">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.getLsbD_add"><span class="name">BitVec</span>.<span class="name">getLsbD_add</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w i : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(i_lt : <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn">x</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">y</span>)</span>.getLsbD</span> <span class="fn">i</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">x</span>.getLsbD</span> <span class="fn">i</span></span> <a href="../../.././Init/Data/Bool.html#Bool.xor">^^</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">y</span>.getLsbD</span> <span class="fn">i</span></span> <a href="../../.././Init/Data/Bool.html#Bool.xor">^^</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.carry">BitVec.carry</a> <span class="fn">i</span> <span class="fn">x</span> <span class="fn">y</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a></span>)</span>)</span></span></div></div></div></div><div class="decl" id="BitVec.getElem_add_add_bool"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L265-L270">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.getElem_add_add_bool"><span class="name">BitVec</span>.<span class="name">getElem_add_add_bool</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w i : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(i_lt : <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <a href="../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">y</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Basic.html#BitVec.setWidth">BitVec.setWidth</a> <span class="fn">w</span> <span class="fn">(<a href="../../.././Init/Data/BitVec/Basic.html#BitVec.ofBool">BitVec.ofBool</a> <span class="fn">c</span>)</span></span>)</span>[<span class="fn">i</span>]</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn">x</span>[<span class="fn">i</span>]</span> <a href="../../.././Init/Data/Bool.html#Bool.xor">^^</a> <span class="fn">(<span class="fn"><span class="fn">y</span>[<span class="fn">i</span>]</span> <a href="../../.././Init/Data/Bool.html#Bool.xor">^^</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.carry">BitVec.carry</a> <span class="fn">i</span> <span class="fn">x</span> <span class="fn">y</span> <span class="fn">c</span></span>)</span>)</span></span></div></div></div></div><div class="decl" id="BitVec.getElem_add"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L272-L274">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.getElem_add"><span class="name">BitVec</span>.<span class="name">getElem_add</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w i : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(i_lt : <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn">x</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">y</span>)</span>[<span class="fn">i</span>]</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn">x</span>[<span class="fn">i</span>]</span> <a href="../../.././Init/Data/Bool.html#Bool.xor">^^</a> <span class="fn">(<span class="fn"><span class="fn">y</span>[<span class="fn">i</span>]</span> <a href="../../.././Init/Data/Bool.html#Bool.xor">^^</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.carry">BitVec.carry</a> <span class="fn">i</span> <span class="fn">x</span> <span class="fn">y</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a></span>)</span>)</span></span></div></div></div></div><div class="decl" id="BitVec.adc_spec"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L276-L287">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.adc_spec"><span class="name">BitVec</span>.<span class="name">adc_spec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <a href="../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.adc</span> <span class="fn">y</span> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.carry">BitVec.carry</a> <span class="fn">w</span> <span class="fn">x</span> <span class="fn">y</span> <span class="fn">c</span></span>, <span class="fn"><span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">y</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Basic.html#BitVec.setWidth">BitVec.setWidth</a> <span class="fn">w</span> <span class="fn">(<a href="../../.././Init/Data/BitVec/Basic.html#BitVec.ofBool">BitVec.ofBool</a> <span class="fn">c</span>)</span></span></span>)</span></span></div></div></div></div><div class="decl" id="BitVec.add_eq_adc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L289-L290">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.add_eq_adc"><span class="name">BitVec</span>.<span class="name">add_eq_adc</span></a></span><span class="decl_args">
<span class="fn">(w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(x y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">y</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">x</span>.adc</span> <span class="fn">y</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span>.snd</span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="add">add <a class="hover-link" href="#add">#</a></h3></div><div class="decl" id="BitVec.getMsbD_add"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L294-L297">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.getMsbD_add"><span class="name">BitVec</span>.<span class="name">getMsbD_add</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w i : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i_lt : <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">w</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn">x</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">y</span>)</span>.getMsbD</span> <span class="fn">i</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">x</span>.getMsbD</span> <span class="fn">i</span></span> <a href="../../.././Init/Data/Bool.html#Bool.xor">^^</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">y</span>.getMsbD</span> <span class="fn">i</span></span> <a href="../../.././Init/Data/Bool.html#Bool.xor">^^</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.carry">BitVec.carry</a> <span class="fn">(<span class="fn"><span class="fn">w</span> <a href="../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span></span> <a href="../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">i</span>)</span> <span class="fn">x</span> <span class="fn">y</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a></span>)</span>)</span></span></div></div></div></div><div class="decl" id="BitVec.msb_add"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L299-L307">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.msb_add"><span class="name">BitVec</span>.<span class="name">msb_add</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn">x</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">y</span>)</span>.msb</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn">x</span>.msb</span> <a href="../../.././Init/Data/Bool.html#Bool.xor">^^</a> <span class="fn">(<span class="fn"><span class="fn">y</span>.msb</span> <a href="../../.././Init/Data/Bool.html#Bool.xor">^^</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.carry">BitVec.carry</a> <span class="fn">(<span class="fn">w</span> <a href="../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span>)</span> <span class="fn">x</span> <span class="fn">y</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a></span>)</span>)</span></span></div></div></div></div><div class="decl" id="BitVec.add_not_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L309-L313">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.add_not_self"><span class="name">BitVec</span>.<span class="name">add_not_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><a href="../../.././Init/Prelude.html#Complement.complement">~~~</a><span class="fn">x</span></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Basic.html#BitVec.allOnes">BitVec.allOnes</a> <span class="fn">w</span></span></span></div></div><p>Adding a bitvector to its own complement yields the all ones bitpattern</p></div></div><div class="decl" id="BitVec.allOnes_sub_eq_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L315-L317">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.allOnes_sub_eq_not"><span class="name">BitVec</span>.<span class="name">allOnes_sub_eq_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../../.././Init/Data/BitVec/Basic.html#BitVec.allOnes">BitVec.allOnes</a> <span class="fn">w</span></span> <a href="../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#Complement.complement">~~~</a><span class="fn">x</span></span></span></div></div><p>Subtracting <code>x</code> from the all ones bitvector is equivalent to taking its complement</p></div></div><div class="decl" id="BitVec.add_eq_or_of_and_eq_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L319-L332">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.add_eq_or_of_and_eq_zero"><span class="name">BitVec</span>.<span class="name">add_eq_or_of_and_eq_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#HAnd.hAnd">&amp;&amp;&amp;</a> <span class="fn">y</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">0#<span class="fn">w</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">y</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#HOr.hOr">|||</a> <span class="fn">y</span></span></span></div></div><p>Addition of bitvectors is the same as bitwise or, if bitwise and is zero.</p></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Sub">Sub <a class="hover-link" href="#Sub">#</a></h3></div><div class="decl" id="BitVec.getLsbD_sub"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L336-L340">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.getLsbD_sub"><span class="name">BitVec</span>.<span class="name">getLsbD_sub</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w i : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i_lt : <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">w</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn">x</span> <a href="../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">y</span>)</span>.getLsbD</span> <span class="fn">i</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">x</span>.getLsbD</span> <span class="fn">i</span></span> <a href="../../.././Init/Data/Bool.html#Bool.xor">^^</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Init/Prelude.html#Complement.complement">~~~</a><span class="fn">y</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1#<span class="fn">w</span></span>)</span>.getLsbD</span> <span class="fn">i</span></span> <a href="../../.././Init/Data/Bool.html#Bool.xor">^^</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.carry">BitVec.carry</a> <span class="fn">i</span> <span class="fn">x</span> <span class="fn">(<span class="fn"><a href="../../.././Init/Prelude.html#Complement.complement">~~~</a><span class="fn">y</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1#<span class="fn">w</span></span>)</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a></span>)</span>)</span></span></div></div></div></div><div class="decl" id="BitVec.getMsbD_sub"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L342-L347">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.getMsbD_sub"><span class="name">BitVec</span>.<span class="name">getMsbD_sub</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w i : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i_lt : <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">w</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn">x</span> <a href="../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">y</span>)</span>.getMsbD</span> <span class="fn">i</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">x</span>.getMsbD</span> <span class="fn">i</span></span> <a href="../../.././Init/Data/Bool.html#Bool.xor">^^</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Init/Prelude.html#Complement.complement">~~~</a><span class="fn">y</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span>)</span>.getMsbD</span> <span class="fn">i</span></span> <a href="../../.././Init/Data/Bool.html#Bool.xor">^^</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.carry">BitVec.carry</a> <span class="fn">(<span class="fn"><span class="fn">w</span> <a href="../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span></span> <a href="../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">i</span>)</span> <span class="fn">x</span> <span class="fn">(<span class="fn"><a href="../../.././Init/Prelude.html#Complement.complement">~~~</a><span class="fn">y</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span>)</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a></span>)</span>)</span></span></div></div></div></div><div class="decl" id="BitVec.msb_sub"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L349-L352">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.msb_sub"><span class="name">BitVec</span>.<span class="name">msb_sub</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn">x</span> <a href="../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">y</span>)</span>.msb</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn">x</span>.msb</span> <a href="../../.././Init/Data/Bool.html#Bool.xor">^^</a> <span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Init/Prelude.html#Complement.complement">~~~</a><span class="fn">y</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1#<span class="fn">w</span></span>)</span>.msb</span> <a href="../../.././Init/Data/Bool.html#Bool.xor">^^</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.carry">BitVec.carry</a> <span class="fn">(<span class="fn"><span class="fn">w</span> <a href="../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span></span> <a href="../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">0</span>)</span> <span class="fn">x</span> <span class="fn">(<span class="fn"><a href="../../.././Init/Prelude.html#Complement.complement">~~~</a><span class="fn">y</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1#<span class="fn">w</span></span>)</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a></span>)</span>)</span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Negation">Negation <a class="hover-link" href="#Negation">#</a></h3></div><div class="decl" id="BitVec.bit_not_testBit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L356-L358">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.bit_not_testBit"><span class="name">BitVec</span>.<span class="name">bit_not_testBit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <span class="fn"><a href="../../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Init/Data/BitVec/Folds.html#BitVec.iunfoldr">BitVec.iunfoldr</a> <span class="fn">(fun (<span class="fn">i</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">w</span></span>) (<span class="fn">c</span> : <a href="../../.././Init/Prelude.html#Unit">Unit</a>) =&gt; <span class="fn">(<span class="fn">c</span>, <span class="fn"><a href="../../.././Init/Prelude.html#Bool.not">!</a><span class="fn"><span class="fn"><span class="fn">x</span>.getLsbD</span> <span class="fn">↑<span class="fn">i</span></span></span></span>)</span>)</span> <a href="../../.././Init/Prelude.html#Unit.unit">()</a>)</span>.snd</span>.getLsbD</span> <span class="fn">↑<span class="fn">i</span></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#Bool.not">!</a><span class="fn"><span class="fn"><span class="fn">x</span>.getLsbD</span> <span class="fn">↑<span class="fn">i</span></span></span></span></span></div></div></div></div><div class="decl" id="BitVec.bit_not_add_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L360-L366">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.bit_not_add_self"><span class="name">BitVec</span>.<span class="name">bit_not_add_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Init/Data/BitVec/Folds.html#BitVec.iunfoldr">BitVec.iunfoldr</a> <span class="fn">(fun (<span class="fn">i</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">w</span></span>) (<span class="fn">c</span> : <a href="../../.././Init/Prelude.html#Unit">Unit</a>) =&gt; <span class="fn">(<span class="fn">c</span>, <span class="fn"><a href="../../.././Init/Prelude.html#Bool.not">!</a><span class="fn"><span class="fn"><span class="fn">x</span>.getLsbD</span> <span class="fn">↑<span class="fn">i</span></span></span></span>)</span>)</span> <a href="../../.././Init/Prelude.html#Unit.unit">()</a>)</span>.snd</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">-<span class="fn">1</span></span></span></div></div></div></div><div class="decl" id="BitVec.bit_not_eq_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L368-L370">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.bit_not_eq_not"><span class="name">BitVec</span>.<span class="name">bit_not_eq_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Init/Data/BitVec/Folds.html#BitVec.iunfoldr">BitVec.iunfoldr</a> <span class="fn">(fun (<span class="fn">i</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">w</span></span>) (<span class="fn">c</span> : <a href="../../.././Init/Prelude.html#Unit">Unit</a>) =&gt; <span class="fn">(<span class="fn">c</span>, <span class="fn"><a href="../../.././Init/Prelude.html#Bool.not">!</a><span class="fn"><span class="fn"><span class="fn">x</span>.getLsbD</span> <span class="fn">↑<span class="fn">i</span></span></span></span>)</span>)</span> <a href="../../.././Init/Prelude.html#Unit.unit">()</a>)</span>.snd</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#Complement.complement">~~~</a><span class="fn">x</span></span></span></div></div></div></div><div class="decl" id="BitVec.bit_neg_eq_neg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L372-L377">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.bit_neg_eq_neg"><span class="name">BitVec</span>.<span class="name">bit_neg_eq_neg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Init/Data/BitVec/Folds.html#BitVec.iunfoldr">BitVec.iunfoldr</a> <span class="fn">(fun (<span class="fn">i</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">w</span></span>) (<span class="fn">c</span> : <a href="../../.././Init/Prelude.html#Unit">Unit</a>) =&gt; <span class="fn">(<span class="fn">c</span>, <span class="fn"><a href="../../.././Init/Prelude.html#Bool.not">!</a><span class="fn"><span class="fn"><span class="fn">x</span>.getLsbD</span> <span class="fn">↑<span class="fn">i</span></span></span></span>)</span>)</span> <a href="../../.././Init/Prelude.html#Unit.unit">()</a>)</span>.snd</span>.adc</span> <span class="fn">(1#<span class="fn">w</span>)</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span>.snd</span></span></div></div></div></div><div class="decl" id="BitVec.getLsbD_neg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L379-L411">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.getLsbD_neg"><span class="name">BitVec</span>.<span class="name">getLsbD_neg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w i : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">x</span>)</span>.getLsbD</span> <span class="fn">i</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">x</span>.getLsbD</span> <span class="fn">i</span></span> <a href="../../.././Init/Data/Bool.html#Bool.xor">^^</a> <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Decidable.decide">decide</a> <span class="fn">(<span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">w</span>)</span></span> <a href="../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><a href="../../.././Init/Prelude.html#Decidable.decide">decide</a> <span class="fn">(∃ (<span class="fn">j</span> : <a href="../../.././Init/Prelude.html#Nat">Nat</a>), <span class="fn"><span class="fn"><span class="fn">j</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">i</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.getLsbD</span> <span class="fn">j</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a></span></span>)</span></span></span>)</span></span></div></div><p>Remember that negating a bitvector is equal to incrementing the complement
by one, i.e., <code>-x = ~~~x + 1</code>. See also <code>neg_eq_not_add</code>.</p><p>This computation has two crucial properties:</p><ul>
<li>The least significant bit of <code>-x</code> is the same as the least significant bit of <code>x</code>, and</li>
<li>The <code>i+1</code>-th least significant bit of <code>-x</code> is the complement of the <code>i+1</code>-th bit of <code>x</code>, unless
all of the preceding bits are <code>false</code>, in which case the bit is equal to the <code>i+1</code>-th bit of <code>x</code></li>
</ul></div></div><div class="decl" id="BitVec.getMsbD_neg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L413-L428">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.getMsbD_neg"><span class="name">BitVec</span>.<span class="name">getMsbD_neg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w i : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">x</span>)</span>.getMsbD</span> <span class="fn">i</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">x</span>.getMsbD</span> <span class="fn">i</span></span> <a href="../../.././Init/Data/Bool.html#Bool.xor">^^</a> <span class="fn"><a href="../../.././Init/Prelude.html#Decidable.decide">decide</a> <span class="fn">(∃ (<span class="fn">j</span> : <a href="../../.././Init/Prelude.html#Nat">Nat</a>), <span class="fn"><span class="fn"><span class="fn">j</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">w</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">j</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.getMsbD</span> <span class="fn">j</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a></span></span></span>)</span></span>)</span></span></div></div></div></div><div class="decl" id="BitVec.msb_neg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L430-L469">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.msb_neg"><span class="name">BitVec</span>.<span class="name">msb_neg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">x</span>)</span>.msb</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">x</span> <a href="../../.././Init/Core.html#bne">!=</a> <span class="fn">0#<span class="fn">w</span></span></span> <a href="../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Core.html#bne">!=</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Lemmas.html#BitVec.intMin">BitVec.intMin</a> <span class="fn">w</span></span></span></span> <a href="../../.././Init/Data/Bool.html#Bool.xor">^^</a> <span class="fn"><span class="fn">x</span>.msb</span>)</span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="abs">abs <a class="hover-link" href="#abs">#</a></h3></div><div class="decl" id="BitVec.msb_abs"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L473-L488">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.msb_abs"><span class="name">BitVec</span>.<span class="name">msb_abs</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.abs</span>.msb</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><a href="../../.././Init/Prelude.html#Decidable.decide">decide</a> <span class="fn">(<span class="fn">x</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Lemmas.html#BitVec.intMin">BitVec.intMin</a> <span class="fn">w</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><a href="../../.././Init/Prelude.html#Decidable.decide">decide</a> <span class="fn">(<span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">w</span>)</span></span>)</span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Inequalities-le-lt">Inequalities (le / lt) <a class="hover-link" href="#Inequalities-le-lt">#</a></h3></div><div class="decl" id="BitVec.ult_eq_not_carry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L492-L496">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.ult_eq_not_carry"><span class="name">BitVec</span>.<span class="name">ult_eq_not_carry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.ult</span> <span class="fn">y</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#Bool.not">!</a><span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.carry">BitVec.carry</a> <span class="fn">w</span> <span class="fn">x</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Complement.complement">~~~</a><span class="fn">y</span>)</span> <a href="../../.././Init/Prelude.html#Bool.true">true</a></span></span></span></div></div></div></div><div class="decl" id="BitVec.ule_eq_not_ult"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L498-L499">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.ule_eq_not_ult"><span class="name">BitVec</span>.<span class="name">ule_eq_not_ult</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.ule</span> <span class="fn">y</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#Bool.not">!</a><span class="fn"><span class="fn"><span class="fn">y</span>.ult</span> <span class="fn">x</span></span></span></span></div></div></div></div><div class="decl" id="BitVec.ule_eq_carry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L501-L502">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.ule_eq_carry"><span class="name">BitVec</span>.<span class="name">ule_eq_carry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.ule</span> <span class="fn">y</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.carry">BitVec.carry</a> <span class="fn">w</span> <span class="fn">y</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Complement.complement">~~~</a><span class="fn">x</span>)</span> <a href="../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="BitVec.slt_eq_ult_of_msb_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L504-L508">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.slt_eq_ult_of_msb_eq"><span class="name">BitVec</span>.<span class="name">slt_eq_ult_of_msb_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">x</span>.msb</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">y</span>.msb</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.slt</span> <span class="fn">y</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">x</span>.ult</span> <span class="fn">y</span></span></span></div></div><p>If two bitvectors have the same <code>msb</code>, then signed and unsigned comparisons coincide</p></div></div><div class="decl" id="BitVec.ult_eq_msb_of_msb_neq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L510-L514">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.ult_eq_msb_of_msb_neq"><span class="name">BitVec</span>.<span class="name">ult_eq_msb_of_msb_neq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">x</span>.msb</span> <a href="../../.././Init/Core.html#Ne">≠</a> <span class="fn"><span class="fn">y</span>.msb</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.ult</span> <span class="fn">y</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">y</span>.msb</span></span></div></div><p>If two bitvectors have different <code>msb</code>s, then unsigned comparison is determined by this bit</p></div></div><div class="decl" id="BitVec.slt_eq_not_ult_of_msb_neq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L516-L520">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.slt_eq_not_ult_of_msb_neq"><span class="name">BitVec</span>.<span class="name">slt_eq_not_ult_of_msb_neq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">x</span>.msb</span> <a href="../../.././Init/Core.html#Ne">≠</a> <span class="fn"><span class="fn">y</span>.msb</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.slt</span> <span class="fn">y</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#Bool.not">!</a><span class="fn"><span class="fn"><span class="fn">x</span>.ult</span> <span class="fn">y</span></span></span></span></div></div><p>If two bitvectors have different <code>msb</code>s, then signed and unsigned comparisons are opposites</p></div></div><div class="decl" id="BitVec.slt_eq_ult"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L522-L527">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.slt_eq_ult"><span class="name">BitVec</span>.<span class="name">slt_eq_ult</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.slt</span> <span class="fn">y</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">x</span>.msb</span> <a href="../../.././Init/Core.html#bne">!=</a> <span class="fn"><span class="fn">y</span>.msb</span></span> <a href="../../.././Init/Data/Bool.html#Bool.xor">^^</a> <span class="fn"><span class="fn"><span class="fn">x</span>.ult</span> <span class="fn">y</span></span>)</span></span></div></div></div></div><div class="decl" id="BitVec.slt_eq_not_carry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L529-L532">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.slt_eq_not_carry"><span class="name">BitVec</span>.<span class="name">slt_eq_not_carry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.slt</span> <span class="fn">y</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">x</span>.msb</span> <a href="../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">y</span>.msb</span></span> <a href="../../.././Init/Data/Bool.html#Bool.xor">^^</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.carry">BitVec.carry</a> <span class="fn">w</span> <span class="fn">x</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Complement.complement">~~~</a><span class="fn">y</span>)</span> <a href="../../.././Init/Prelude.html#Bool.true">true</a></span>)</span></span></div></div></div></div><div class="decl" id="BitVec.sle_eq_not_slt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L534-L535">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.sle_eq_not_slt"><span class="name">BitVec</span>.<span class="name">sle_eq_not_slt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.sle</span> <span class="fn">y</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#Bool.not">!</a><span class="fn"><span class="fn"><span class="fn">y</span>.slt</span> <span class="fn">x</span></span></span></span></div></div></div></div><div class="decl" id="BitVec.sle_eq_carry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L537-L539">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.sle_eq_carry"><span class="name">BitVec</span>.<span class="name">sle_eq_carry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.sle</span> <span class="fn">y</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#Bool.not">!</a><span class="fn">(<span class="fn"><span class="fn"><span class="fn">x</span>.msb</span> <a href="../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">y</span>.msb</span></span> <a href="../../.././Init/Data/Bool.html#Bool.xor">^^</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.carry">BitVec.carry</a> <span class="fn">w</span> <span class="fn">y</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Complement.complement">~~~</a><span class="fn">x</span>)</span> <a href="../../.././Init/Prelude.html#Bool.true">true</a></span>)</span></span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="mul-recurrence-for-bitblasting">mul recurrence for bitblasting <a class="hover-link" href="#mul-recurrence-for-bitblasting">#</a></h3></div><div class="decl" id="BitVec.mulRec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L543-L551">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.mulRec"><span class="name">BitVec</span>.<span class="name">mulRec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(s : <a href="../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span></div></div><p>A recurrence that describes multiplication as repeated addition.
Is useful for bitblasting multiplication.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.mulRec</span> <span class="fn">y</span> <span class="fn">0</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if <span class="fn"><span class="fn"><span class="fn"><span class="fn">y</span>.getLsbD</span> <span class="fn">0</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a></span> then <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#HShiftLeft.hShiftLeft">&lt;&lt;&lt;</a> <span class="fn">0</span></span> else <span class="fn">0</span></span></span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.mulRec</span> <span class="fn">y</span> <span class="fn"><span class="fn">s_2</span>.succ</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.mulRec</span> <span class="fn">y</span> <span class="fn">s_2</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">if <span class="fn"><span class="fn"><span class="fn"><span class="fn">y</span>.getLsbD</span> <span class="fn"><span class="fn">s_2</span>.succ</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a></span> then <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#HShiftLeft.hShiftLeft">&lt;&lt;&lt;</a> <span class="fn"><span class="fn">s_2</span>.succ</span></span> else <span class="fn">0</span></span></span></span></li></ul></details><details id="instances-for-list-BitVec.mulRec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="BitVec.mulRec_zero_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L553-L555">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.mulRec_zero_eq"><span class="name">BitVec</span>.<span class="name">mulRec_zero_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.mulRec</span> <span class="fn">y</span> <span class="fn">0</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if <span class="fn"><span class="fn"><span class="fn"><span class="fn">y</span>.getLsbD</span> <span class="fn">0</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a></span> then <span class="fn">x</span> else <span class="fn">0</span></span></span></div></div></div></div><div class="decl" id="BitVec.mulRec_succ_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L557-L558">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.mulRec_succ_eq"><span class="name">BitVec</span>.<span class="name">mulRec_succ_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(s : <a href="../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.mulRec</span> <span class="fn">y</span> <span class="fn">(<span class="fn">s</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.mulRec</span> <span class="fn">y</span> <span class="fn">s</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">if <span class="fn"><span class="fn"><span class="fn"><span class="fn">y</span>.getLsbD</span> <span class="fn">(<span class="fn">s</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a></span> then <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#HShiftLeft.hShiftLeft">&lt;&lt;&lt;</a> <span class="fn">(<span class="fn">s</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span>)</span></span> else <span class="fn">0</span></span></span></span></div></div></div></div><div class="decl" id="BitVec.setWidth_setWidth_succ_eq_setWidth_setWidth_add_twoPow"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L560-L582">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.setWidth_setWidth_succ_eq_setWidth_setWidth_add_twoPow"><span class="name">BitVec</span>.<span class="name">setWidth_setWidth_succ_eq_setWidth_setWidth_add_twoPow</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <a href="../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Init/Data/BitVec/Basic.html#BitVec.setWidth">BitVec.setWidth</a> <span class="fn">w</span> <span class="fn">(<a href="../../.././Init/Data/BitVec/Basic.html#BitVec.setWidth">BitVec.setWidth</a> <span class="fn">(<span class="fn">i</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span>)</span> <span class="fn">x</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><a href="../../.././Init/Data/BitVec/Basic.html#BitVec.setWidth">BitVec.setWidth</a> <span class="fn">w</span> <span class="fn">(<a href="../../.././Init/Data/BitVec/Basic.html#BitVec.setWidth">BitVec.setWidth</a> <span class="fn">i</span> <span class="fn">x</span>)</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">(<span class="fn">x</span> <a href="../../.././Init/Prelude.html#HAnd.hAnd">&amp;&amp;&amp;</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Basic.html#BitVec.twoPow">BitVec.twoPow</a> <span class="fn">w</span> <span class="fn">i</span></span>)</span></span></span></div></div><p>Recurrence lemma: truncating to <code>i+1</code> bits and then zero extending to <code>w</code>
equals truncating upto <code>i</code> bits <code>[0..i-1]</code>, and then adding the <code>i</code>th bit of <code>x</code>.</p></div></div><div class="decl" id="BitVec.zeroExtend_truncate_succ_eq_zeroExtend_truncate_add_twoPow"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L584-L587">source</a></div><div class="attributes">@[reducible, inline, deprecated BitVec.setWidth_setWidth_succ_eq_setWidth_setWidth_add_twoPow]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.zeroExtend_truncate_succ_eq_zeroExtend_truncate_add_twoPow"><span class="name">BitVec</span>.<span class="name">zeroExtend_truncate_succ_eq_zeroExtend_truncate_add_twoPow</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <a href="../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Init/Data/BitVec/Basic.html#BitVec.setWidth">BitVec.setWidth</a> <span class="fn">w</span> <span class="fn">(<a href="../../.././Init/Data/BitVec/Basic.html#BitVec.setWidth">BitVec.setWidth</a> <span class="fn">(<span class="fn">i</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span>)</span> <span class="fn">x</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><a href="../../.././Init/Data/BitVec/Basic.html#BitVec.setWidth">BitVec.setWidth</a> <span class="fn">w</span> <span class="fn">(<a href="../../.././Init/Data/BitVec/Basic.html#BitVec.setWidth">BitVec.setWidth</a> <span class="fn">i</span> <span class="fn">x</span>)</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">(<span class="fn">x</span> <a href="../../.././Init/Prelude.html#HAnd.hAnd">&amp;&amp;&amp;</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Basic.html#BitVec.twoPow">BitVec.twoPow</a> <span class="fn">w</span> <span class="fn">i</span></span>)</span></span></span></div></div><p>Recurrence lemma: truncating to <code>i+1</code> bits and then zero extending to <code>w</code>
equals truncating upto <code>i</code> bits <code>[0..i-1]</code>, and then adding the <code>i</code>th bit of <code>x</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.zeroExtend_truncate_succ_eq_zeroExtend_truncate_add_twoPow">@<a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.zeroExtend_truncate_succ_eq_zeroExtend_truncate_add_twoPow">BitVec.zeroExtend_truncate_succ_eq_zeroExtend_truncate_add_twoPow</a></a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.setWidth_setWidth_succ_eq_setWidth_setWidth_add_twoPow">@<a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.setWidth_setWidth_succ_eq_setWidth_setWidth_add_twoPow">BitVec.setWidth_setWidth_succ_eq_setWidth_setWidth_add_twoPow</a></a></span></li></ul></details><details id="instances-for-list-BitVec.zeroExtend_truncate_succ_eq_zeroExtend_truncate_add_twoPow" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="BitVec.mulRec_eq_mul_signExtend_setWidth"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L589-L613">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.mulRec_eq_mul_signExtend_setWidth"><span class="name">BitVec</span>.<span class="name">mulRec_eq_mul_signExtend_setWidth</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(s : <a href="../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.mulRec</span> <span class="fn">y</span> <span class="fn">s</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Basic.html#BitVec.setWidth">BitVec.setWidth</a> <span class="fn">w</span> <span class="fn">(<a href="../../.././Init/Data/BitVec/Basic.html#BitVec.setWidth">BitVec.setWidth</a> <span class="fn">(<span class="fn">s</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span>)</span> <span class="fn">y</span>)</span></span></span></span></div></div><p>Recurrence lemma: multiplying <code>x</code> with the first <code>s</code> bits of <code>y</code> is the
same as truncating <code>y</code> to <code>s</code> bits, then zero extending to the original length,
and performing the multplication.</p></div></div><div class="decl" id="BitVec.mulRec_eq_mul_signExtend_truncate"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L615-L617">source</a></div><div class="attributes">@[reducible, inline, deprecated BitVec.mulRec_eq_mul_signExtend_setWidth]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.mulRec_eq_mul_signExtend_truncate"><span class="name">BitVec</span>.<span class="name">mulRec_eq_mul_signExtend_truncate</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(s : <a href="../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.mulRec</span> <span class="fn">y</span> <span class="fn">s</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Basic.html#BitVec.setWidth">BitVec.setWidth</a> <span class="fn">w</span> <span class="fn">(<a href="../../.././Init/Data/BitVec/Basic.html#BitVec.setWidth">BitVec.setWidth</a> <span class="fn">(<span class="fn">s</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span>)</span> <span class="fn">y</span>)</span></span></span></span></div></div><p>Recurrence lemma: multiplying <code>x</code> with the first <code>s</code> bits of <code>y</code> is the
same as truncating <code>y</code> to <code>s</code> bits, then zero extending to the original length,
and performing the multplication.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.mulRec_eq_mul_signExtend_truncate">@<a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.mulRec_eq_mul_signExtend_truncate">BitVec.mulRec_eq_mul_signExtend_truncate</a></a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.mulRec_eq_mul_signExtend_setWidth">@<a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.mulRec_eq_mul_signExtend_setWidth">BitVec.mulRec_eq_mul_signExtend_setWidth</a></a></span></li></ul></details><details id="instances-for-list-BitVec.mulRec_eq_mul_signExtend_truncate" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="BitVec.getLsbD_mul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L619-L624">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.getLsbD_mul"><span class="name">BitVec</span>.<span class="name">getLsbD_mul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <a href="../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn">x</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">y</span>)</span>.getLsbD</span> <span class="fn">i</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">x</span>.mulRec</span> <span class="fn">y</span> <span class="fn">w</span>)</span>.getLsbD</span> <span class="fn">i</span></span></span></div></div></div></div><div class="decl" id="BitVec.getElem_mul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L626-L628">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.getElem_mul"><span class="name">BitVec</span>.<span class="name">getElem_mul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn">x</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">y</span>)</span>[<span class="fn">i</span>]</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">x</span>.mulRec</span> <span class="fn">y</span> <span class="fn">w</span>)</span>[<span class="fn">i</span>]</span></span></div></div></div></div><div class="mod_doc"><h2 class="markdown-heading" id="shiftLeft-recurrence-for-bitblasting">shiftLeft recurrence for bitblasting <a class="hover-link" href="#shiftLeft-recurrence-for-bitblasting">#</a></h2></div><div class="decl" id="BitVec.shiftLeftRec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L632-L644">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.shiftLeftRec"><span class="name">BitVec</span>.<span class="name">shiftLeftRec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w₁ w₂ : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(n : <a href="../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₁</span></span></div></div><p><code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.shiftLeftRec">shiftLeftRec</a> x y <a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs.n">n</a></code> shifts <code>x</code> to the left by the first <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs.n">n</a></code> bits of <code>y</code>.</p><p>The theorem <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.shiftLeft_eq_shiftLeftRec">shiftLeft_eq_shiftLeftRec</a></code> proves the equivalence of <code>(x &lt;&lt;&lt; y)</code> and <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.shiftLeftRec">shiftLeftRec</a></code>.</p><p>Together with equations <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.shiftLeftRec_zero">shiftLeftRec_zero</a></code>, <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.shiftLeftRec_succ">shiftLeftRec_succ</a></code>,
this allows us to unfold <code>shiftLeft</code> into a circuit for bitblasting.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.shiftLeftRec</span> <span class="fn">y</span> <span class="fn">0</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#HShiftLeft.hShiftLeft">&lt;&lt;&lt;</a> <span class="fn">(<span class="fn">y</span> <a href="../../.././Init/Prelude.html#HAnd.hAnd">&amp;&amp;&amp;</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Basic.html#BitVec.twoPow">BitVec.twoPow</a> <span class="fn">w₂</span> <span class="fn">0</span></span>)</span></span></span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.shiftLeftRec</span> <span class="fn">y</span> <span class="fn"><span class="fn">s_1</span>.succ</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.shiftLeftRec</span> <span class="fn">y</span> <span class="fn">s_1</span></span> <a href="../../.././Init/Prelude.html#HShiftLeft.hShiftLeft">&lt;&lt;&lt;</a> <span class="fn">(<span class="fn">y</span> <a href="../../.././Init/Prelude.html#HAnd.hAnd">&amp;&amp;&amp;</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Basic.html#BitVec.twoPow">BitVec.twoPow</a> <span class="fn">w₂</span> <span class="fn"><span class="fn">s_1</span>.succ</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-BitVec.shiftLeftRec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="BitVec.shiftLeftRec_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L646-L649">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.shiftLeftRec_zero"><span class="name">BitVec</span>.<span class="name">shiftLeftRec_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w₁ w₂ : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₁</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₂</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.shiftLeftRec</span> <span class="fn">y</span> <span class="fn">0</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#HShiftLeft.hShiftLeft">&lt;&lt;&lt;</a> <span class="fn">(<span class="fn">y</span> <a href="../../.././Init/Prelude.html#HAnd.hAnd">&amp;&amp;&amp;</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Basic.html#BitVec.twoPow">BitVec.twoPow</a> <span class="fn">w₂</span> <span class="fn">0</span></span>)</span></span></span></div></div></div></div><div class="decl" id="BitVec.shiftLeftRec_succ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L651-L654">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.shiftLeftRec_succ"><span class="name">BitVec</span>.<span class="name">shiftLeftRec_succ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w₁ w₂ n : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₁</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₂</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.shiftLeftRec</span> <span class="fn">y</span> <span class="fn">(<span class="fn">n</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.shiftLeftRec</span> <span class="fn">y</span> <span class="fn">n</span></span> <a href="../../.././Init/Prelude.html#HShiftLeft.hShiftLeft">&lt;&lt;&lt;</a> <span class="fn">(<span class="fn">y</span> <a href="../../.././Init/Prelude.html#HAnd.hAnd">&amp;&amp;&amp;</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Basic.html#BitVec.twoPow">BitVec.twoPow</a> <span class="fn">w₂</span> <span class="fn">(<span class="fn">n</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="BitVec.shiftLeft_or_of_and_eq_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L656-L666">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.shiftLeft_or_of_and_eq_zero"><span class="name">BitVec</span>.<span class="name">shiftLeft_or_of_and_eq_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w₁ w₂ : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₁</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y z : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₂</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">y</span> <a href="../../.././Init/Prelude.html#HAnd.hAnd">&amp;&amp;&amp;</a> <span class="fn">z</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">0#<span class="fn">w₂</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#HShiftLeft.hShiftLeft">&lt;&lt;&lt;</a> <span class="fn">(<span class="fn">y</span> <a href="../../.././Init/Prelude.html#HOr.hOr">|||</a> <span class="fn">z</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#HShiftLeft.hShiftLeft">&lt;&lt;&lt;</a> <span class="fn">y</span></span> <a href="../../.././Init/Prelude.html#HShiftLeft.hShiftLeft">&lt;&lt;&lt;</a> <span class="fn">z</span></span></span></div></div><p>If <code>y &amp;&amp;&amp; z = 0</code>, <code>x &lt;&lt;&lt; (y ||| z) = x &lt;&lt;&lt; y &lt;&lt;&lt; z</code>.
This follows as <code>y &amp;&amp;&amp; z = 0</code> implies <code>y ||| z = y + z</code>,
and thus <code>x &lt;&lt;&lt; (y ||| z) = x &lt;&lt;&lt; (y + z) = x &lt;&lt;&lt; y &lt;&lt;&lt; z</code>.</p></div></div><div class="decl" id="BitVec.shiftLeftRec_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L668-L688">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.shiftLeftRec_eq"><span class="name">BitVec</span>.<span class="name">shiftLeftRec_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w₁ w₂ : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₁</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₂</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.shiftLeftRec</span> <span class="fn">y</span> <span class="fn">n</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#HShiftLeft.hShiftLeft">&lt;&lt;&lt;</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Basic.html#BitVec.setWidth">BitVec.setWidth</a> <span class="fn">w₂</span> <span class="fn">(<a href="../../.././Init/Data/BitVec/Basic.html#BitVec.setWidth">BitVec.setWidth</a> <span class="fn">(<span class="fn">n</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span>)</span> <span class="fn">y</span>)</span></span></span></span></div></div><p><code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.shiftLeftRec">shiftLeftRec</a> x y <a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs.n">n</a></code> shifts <code>x</code> to the left by the first <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs.n">n</a></code> bits of <code>y</code>.</p></div></div><div class="decl" id="BitVec.shiftLeft_eq_shiftLeftRec"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L690-L698">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.shiftLeft_eq_shiftLeftRec"><span class="name">BitVec</span>.<span class="name">shiftLeft_eq_shiftLeftRec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w₁ w₂ : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#HShiftLeft.hShiftLeft">&lt;&lt;&lt;</a> <span class="fn">y</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">x</span>.shiftLeftRec</span> <span class="fn">y</span> <span class="fn">(<span class="fn">w₂</span> <a href="../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span>)</span></span></span></div></div><p>Show that <code>x &lt;&lt;&lt; y</code> can be written in terms of <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.shiftLeftRec">shiftLeftRec</a></code>.
This can be unfolded in terms of <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.shiftLeftRec_zero">shiftLeftRec_zero</a></code>, <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.shiftLeftRec_succ">shiftLeftRec_succ</a></code> for bitblasting.</p></div></div><div class="mod_doc"><h1 class="markdown-heading" id="udiv-urem-recurrence-for-bitblasting">udiv/urem recurrence for bitblasting <a class="hover-link" href="#udiv-urem-recurrence-for-bitblasting">#</a></h1><p>In order to prove the correctness of the division algorithm on the integers,
one shows that <code>n.div <a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs.d">d</a> = <a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.q">q</a></code> and <code>n.mod <a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs.d">d</a> = <a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.r">r</a></code> iff <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs.n">n</a> = <a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs.d">d</a> * <a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.q">q</a> + <a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.r">r</a></code> and <code>0 ≤ <a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.r">r</a> &lt; <a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs.d">d</a></code>.
Mnemonic: <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs.n">n</a></code> is the numerator, <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs.d">d</a></code> is the denominator, <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.q">q</a></code> is the quotient, and <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.r">r</a></code> the remainder.</p><p>This <em>uniqueness of decomposition</em> is not true for bitvectors.
For <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs.n">n</a> = 0, <a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs.d">d</a> = 3, w = 3</code>, we can write:</p><ul>
<li><code>0 = 0 * 3 + 0</code> (<code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.q">q</a> = 0</code>, <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.r">r</a> = 0 &lt; 3</code>.)</li>
<li><code>0 = 2 * 3 + 2 = 6 + 2 ≃ 0 (mod 8)</code> (<code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.q">q</a> = 2</code>, <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.r">r</a> = 2 &lt; 3</code>).</li>
</ul><p>Such examples can be created by choosing different <code>(q, r)</code> for a fixed <code>(d, n)</code>
such that <code>(d * <a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.q">q</a> + r)</code> overflows and wraps around to equal <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs.n">n</a></code>.</p><p>This tells us that the division algorithm must have more restrictions than just the ones
we have for integers. These restrictions are captured in <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.Lawful">DivModState.Lawful</a></code>.
The key idea is to state the relationship in terms of the toNat values of {n, d, q, r}.
If the division equation <code>d.toNat * q.toNat + r.toNat = n.toNat</code> holds,
then <code>n.udiv <a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs.d">d</a> = <a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.q">q</a></code> and <code>n.umod <a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs.d">d</a> = <a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.r">r</a></code>.</p><p>Following this, we implement the division algorithm by repeated shift-subtract.</p><p>References:</p><ul>
<li>Fast 32-bit Division on the DSP56800E: Minimized nonrestoring division algorithm by David Baca</li>
<li>Bitwuzla sources for bitblasting.h</li>
</ul></div><div class="decl" id="BitVec.udiv_eq_of_mul_add_toNat"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L739-L754">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.udiv_eq_of_mul_add_toNat"><span class="name">BitVec</span>.<span class="name">udiv_eq_of_mul_add_toNat</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d n q r : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hd : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">d</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hrd : <span class="fn"><span class="fn">r</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">d</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hdqnr : <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">d</span>.toNat</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><span class="fn">q</span>.toNat</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">r</span>.toNat</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">n</span>.toNat</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">n</span> <a href="../../.././Init/Prelude.html#HDiv.hDiv">/</a> <span class="fn">d</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">q</span></span></div></div><p>If the division equation <code>d.toNat * q.toNat + r.toNat = n.toNat</code> holds,
then <code>n.udiv <a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs.d">d</a> = <a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.q">q</a></code>.</p></div></div><div class="decl" id="BitVec.umod_eq_of_mul_add_toNat"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L756-L770">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.umod_eq_of_mul_add_toNat"><span class="name">BitVec</span>.<span class="name">umod_eq_of_mul_add_toNat</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d n q r : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hrd : <span class="fn"><span class="fn">r</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">d</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hdqnr : <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">d</span>.toNat</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><span class="fn">q</span>.toNat</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">r</span>.toNat</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">n</span>.toNat</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">n</span> <a href="../../.././Init/Prelude.html#HMod.hMod">%</a> <span class="fn">d</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></span></div></div><p>If the division equation <code>d.toNat * q.toNat + r.toNat = n.toNat</code> holds,
then <code>n.umod <a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs.d">d</a> = <a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.r">r</a></code>.</p></div></div><div class="mod_doc"><h3 class="markdown-heading" id="DivModState">DivModState <a class="hover-link" href="#DivModState">#</a></h3></div><div class="decl" id="BitVec.DivModState"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L774-L783">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState"><span class="name">BitVec</span>.<span class="name">DivModState</span></a></span><span class="decl_args">
<span class="fn">(w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><p><code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState">DivModState</a></code> is a structure that maintains the state of recursive <code>divrem</code> calls.</p><ul class="structure_fields" id="BitVec.DivModState.mk"><li id="BitVec.DivModState.wn" class="structure_field"><div class="structure_field_info">wn : <a href="../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>The number of bits in the numerator that are not yet processed</p></div></li><li id="BitVec.DivModState.wr" class="structure_field"><div class="structure_field_info">wr : <a href="../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>The number of bits in the remainder (and quotient)</p></div></li><li id="BitVec.DivModState.q" class="structure_field"><div class="structure_field_info">q : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span></div><div class="structure_field_doc"><p>The current quotient.</p></div></li><li id="BitVec.DivModState.r" class="structure_field"><div class="structure_field_info">r : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span></div><div class="structure_field_doc"><p>The current remainder.</p></div></li></ul><details id="instances-for-list-BitVec.DivModState" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="BitVec.DivModArgs"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L786-L792">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs"><span class="name">BitVec</span>.<span class="name">DivModArgs</span></a></span><span class="decl_args">
<span class="fn">(w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><p><code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs">DivModArgs</a></code> contains the arguments to a <code>divrem</code> call which remain constant throughout
execution.</p><ul class="structure_fields" id="BitVec.DivModArgs.mk"><li id="BitVec.DivModArgs.n" class="structure_field"><div class="structure_field_info">n : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span></div><div class="structure_field_doc"><p>the numerator (aka, dividend)</p></div></li><li id="BitVec.DivModArgs.d" class="structure_field"><div class="structure_field_info">d : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span></div><div class="structure_field_doc"><p>the denumerator (aka, divisor)</p></div></li></ul><details id="instances-for-list-BitVec.DivModArgs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="BitVec.DivModState.Lawful"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L794-L818">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.Lawful"><span class="name">BitVec</span>.<span class="name">DivModState</span>.<span class="name">Lawful</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(args : <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs">BitVec.DivModArgs</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(qr : <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState">BitVec.DivModState</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState">DivModState</a></code> is lawful if the remainder width <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.wr">wr</a></code> plus the numerator width <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.wn">wn</a></code> equals <code>w</code>,
and the bitvectors <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.r">r</a></code> and <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs.n">n</a></code> have values in the bounds given by bitwidths <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.wr">wr</a></code>, resp. <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.wn">wn</a></code>.</p><p>This is a proof engineering choice: an alternative world could have been
<code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.r">r</a> : <a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.wr">wr</a></code> and <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs.n">n</a> : <a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.wn">wn</a></code>, but this required much more dependent typing coercions.</p><p>Instead, we choose to declare all involved bitvectors as length <code>w</code>, and then prove that
the values are within their respective bounds.</p><p>We start with <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.wn">wn</a> = w</code> and <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.wr">wr</a> = 0</code>, and then in each step, we decrement <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.wn">wn</a></code> and increment <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.wr">wr</a></code>.
In this way, we grow a legal remainder in each loop iteration.</p><ul class="structure_fields" id="BitVec.DivModState.Lawful.mk"><li id="BitVec.DivModState.Lawful.hwrn" class="structure_field"><div class="structure_field_info">hwrn : <span class="fn"><span class="fn"><span class="fn"><span class="fn">qr</span>.wr</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">qr</span>.wn</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">w</span></span></div><div class="structure_field_doc"><p>The sum of widths of the dividend and remainder is <code>w</code>.</p></div></li><li id="BitVec.DivModState.Lawful.hdPos" class="structure_field"><div class="structure_field_info">hdPos : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">args</span>.d</span></span></div><div class="structure_field_doc"><p>The denominator is positive.</p></div></li><li id="BitVec.DivModState.Lawful.hrLtDivisor" class="structure_field"><div class="structure_field_info">hrLtDivisor : <span class="fn"><span class="fn"><span class="fn"><span class="fn">qr</span>.r</span>.toNat</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">args</span>.d</span>.toNat</span></span></div><div class="structure_field_doc"><p>The remainder is strictly less than the denominator.</p></div></li><li id="BitVec.DivModState.Lawful.hrWidth" class="structure_field"><div class="structure_field_info">hrWidth : <span class="fn"><span class="fn"><span class="fn"><span class="fn">qr</span>.r</span>.toNat</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">2</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn"><span class="fn">qr</span>.wr</span></span></span></div><div class="structure_field_doc"><p>The remainder is morally a <code>Bitvec <a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.wr">wr</a></code>, and so has value less than <code>2^wr</code>.</p></div></li><li id="BitVec.DivModState.Lawful.hqWidth" class="structure_field"><div class="structure_field_info">hqWidth : <span class="fn"><span class="fn"><span class="fn"><span class="fn">qr</span>.q</span>.toNat</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">2</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn"><span class="fn">qr</span>.wr</span></span></span></div><div class="structure_field_doc"><p>The quotient is morally a <code>Bitvec <a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.wr">wr</a></code>, and so has value less than <code>2^wr</code>.</p></div></li><li id="BitVec.DivModState.Lawful.hdiv" class="structure_field"><div class="structure_field_info">hdiv : <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">args</span>.n</span>.toNat</span> <a href="../../.././Init/Prelude.html#HShiftRight.hShiftRight">&gt;&gt;&gt;</a> <span class="fn"><span class="fn">qr</span>.wn</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">args</span>.d</span>.toNat</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><span class="fn"><span class="fn">qr</span>.q</span>.toNat</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn"><span class="fn">qr</span>.r</span>.toNat</span></span></span></div><div class="structure_field_doc"><p>The low <code>(w - wn)</code> bits of <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs.n">n</a></code> obey the invariant for division.</p></div></li></ul><details id="instances-for-list-BitVec.DivModState.Lawful" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="BitVec.DivModState.Lawful.hw"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L820-L828">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.Lawful.hw"><span class="name">BitVec</span>.<span class="name">DivModState</span>.<span class="name">Lawful</span>.<span class="name">hw</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{args : <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs">BitVec.DivModArgs</a> <span class="fn">w</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{qr : <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState">BitVec.DivModState</a> <span class="fn">w</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{h : <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.Lawful">BitVec.DivModState.Lawful</a> <span class="fn">args</span> <span class="fn">qr</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">w</span></span></div></div><p>A lawful DivModState implies <code>w &gt; 0</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-BitVec.DivModState.Lawful.hw" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="BitVec.DivModState.init"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L830-L836">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.init"><span class="name">BitVec</span>.<span class="name">DivModState</span>.<span class="name">init</span></a></span><span class="decl_args">
<span class="fn">(w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState">BitVec.DivModState</a> <span class="fn">w</span></span></div></div><p>An initial value with both <code>q, <a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.r">r</a> = 0</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.init">BitVec.DivModState.init</a> <span class="fn">w</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">wn</span> := <span class="fn">w</span>, <span class="fn">wr</span> := <span class="fn">0</span>, <span class="fn">q</span> := <span class="fn">0#<span class="fn">w</span></span>, <span class="fn">r</span> := <span class="fn">0#<span class="fn">w</span></span> }</span></span></li></ul></details><details id="instances-for-list-BitVec.DivModState.init" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="BitVec.DivModState.lawful_init"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L838-L852">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.lawful_init"><span class="name">BitVec</span>.<span class="name">DivModState</span>.<span class="name">lawful_init</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(args : <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs">BitVec.DivModArgs</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hd : <span class="fn"><span class="fn">0#<span class="fn">w</span></span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">args</span>.d</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.Lawful">BitVec.DivModState.Lawful</a> <span class="fn">args</span> <span class="fn">(<a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.init">BitVec.DivModState.init</a> <span class="fn">w</span>)</span></span></div></div><p>The initial state is lawful.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-BitVec.DivModState.lawful_init" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="BitVec.DivModState.udiv_eq_of_lawful"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L854-L865">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.udiv_eq_of_lawful"><span class="name">BitVec</span>.<span class="name">DivModState</span>.<span class="name">udiv_eq_of_lawful</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n d : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{qr : <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState">BitVec.DivModState</a> <span class="fn">w</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h_lawful : <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.Lawful">BitVec.DivModState.Lawful</a> <span class="fn">{ <span class="fn">n</span> := <span class="fn">n</span>, <span class="fn">d</span> := <span class="fn">d</span> }</span> <span class="fn">qr</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h_final : <span class="fn"><span class="fn"><span class="fn">qr</span>.wn</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">n</span> <a href="../../.././Init/Prelude.html#HDiv.hDiv">/</a> <span class="fn">d</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">qr</span>.q</span></span></div></div><p>A lawful DivModState with a fully consumed dividend (<code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.wn">wn</a> = 0</code>) witnesses that the
quotient has been correctly computed.</p></div></div><div class="decl" id="BitVec.DivModState.umod_eq_of_lawful"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L867-L879">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.umod_eq_of_lawful"><span class="name">BitVec</span>.<span class="name">DivModState</span>.<span class="name">umod_eq_of_lawful</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n d : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{qr : <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState">BitVec.DivModState</a> <span class="fn">w</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.Lawful">BitVec.DivModState.Lawful</a> <span class="fn">{ <span class="fn">n</span> := <span class="fn">n</span>, <span class="fn">d</span> := <span class="fn">d</span> }</span> <span class="fn">qr</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h_final : <span class="fn"><span class="fn"><span class="fn">qr</span>.wn</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">n</span> <a href="../../.././Init/Prelude.html#HMod.hMod">%</a> <span class="fn">d</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">qr</span>.r</span></span></div></div><p>A lawful DivModState with a fully consumed dividend (<code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.wn">wn</a> = 0</code>) witnesses that the
remainder has been correctly computed.</p></div></div><div class="mod_doc"><h3 class="markdown-heading" id="DivModState-Poised">DivModState.Poised <a class="hover-link" href="#DivModState-Poised">#</a></h3></div><div class="decl" id="BitVec.DivModState.Poised"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L883-L893">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.Poised"><span class="name">BitVec</span>.<span class="name">DivModState</span>.<span class="name">Poised</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(args : <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs">BitVec.DivModArgs</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(qr : <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState">BitVec.DivModState</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_extends">extends</span> <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.Lawful">BitVec.DivModState.Lawful</a> <span class="fn">args</span> <span class="fn">qr</span></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><p>A <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.Poised">Poised</a></code> DivModState is a state which is <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.Lawful">Lawful</a></code> and furthermore, has at least
one numerator bit left to process <code>(0 &lt; wn)</code></p><p>The input to the shift subtractor is a legal input to <code>divrem</code>, and we also need to have an
input bit to perform shift subtraction on, and thus we need <code>0 &lt; <a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.wn">wn</a></code>.</p><ul class="structure_fields" id="BitVec.DivModState.Poised.mk"><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.Lawful.hwrn">hwrn</a> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">qr</span>.wr</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">qr</span>.wn</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">w</span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.Lawful.hdPos">hdPos</a> : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">args</span>.d</span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.Lawful.hrLtDivisor">hrLtDivisor</a> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">qr</span>.r</span>.toNat</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">args</span>.d</span>.toNat</span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.Lawful.hrWidth">hrWidth</a> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">qr</span>.r</span>.toNat</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">2</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn"><span class="fn">qr</span>.wr</span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.Lawful.hqWidth">hqWidth</a> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">qr</span>.q</span>.toNat</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">2</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn"><span class="fn">qr</span>.wr</span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.Lawful.hdiv">hdiv</a> : <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">args</span>.n</span>.toNat</span> <a href="../../.././Init/Prelude.html#HShiftRight.hShiftRight">&gt;&gt;&gt;</a> <span class="fn"><span class="fn">qr</span>.wn</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">args</span>.d</span>.toNat</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><span class="fn"><span class="fn">qr</span>.q</span>.toNat</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn"><span class="fn">qr</span>.r</span>.toNat</span></span></span></div></li><li id="BitVec.DivModState.Poised.hwn_lt" class="structure_field"><div class="structure_field_info">hwn_lt : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">qr</span>.wn</span></span></div><div class="structure_field_doc"><p>Only perform a round of shift-subtract if we have dividend bits.</p></div></li></ul><details id="instances-for-list-BitVec.DivModState.Poised" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="BitVec.DivModState.wr_lt_w"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L895-L902">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.wr_lt_w"><span class="name">BitVec</span>.<span class="name">DivModState</span>.<span class="name">wr_lt_w</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{args : <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs">BitVec.DivModArgs</a> <span class="fn">w</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{qr : <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState">BitVec.DivModState</a> <span class="fn">w</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.Poised">BitVec.DivModState.Poised</a> <span class="fn">args</span> <span class="fn">qr</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">qr</span>.wr</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">w</span></span></div></div><p>In the shift subtract input, the dividend is at least one bit long (<code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.wn">wn</a> &gt; 0</code>), so
the remainder has bits to be computed (<code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.wr">wr</a> &lt; w</code>).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-BitVec.DivModState.wr_lt_w" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Division-shift-subtractor">Division shift subtractor <a class="hover-link" href="#Division-shift-subtractor">#</a></h3></div><div class="decl" id="BitVec.divSubtractShift"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L906-L923">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.divSubtractShift"><span class="name">BitVec</span>.<span class="name">divSubtractShift</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(args : <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs">BitVec.DivModArgs</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(qr : <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState">BitVec.DivModState</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState">BitVec.DivModState</a> <span class="fn">w</span></span></div></div><p>One round of the division algorithm, that tries to perform a subtract shift.
Note that this should only be called when <code>r.msb = false</code>, so we will not overflow.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-BitVec.divSubtractShift" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="BitVec.DivModState.toNat_shiftRight_sub_one_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L925-L937">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.toNat_shiftRight_sub_one_eq"><span class="name">BitVec</span>.<span class="name">DivModState</span>.<span class="name">toNat_shiftRight_sub_one_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{args : <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs">BitVec.DivModArgs</a> <span class="fn">w</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{qr : <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState">BitVec.DivModState</a> <span class="fn">w</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.Poised">BitVec.DivModState.Poised</a> <span class="fn">args</span> <span class="fn">qr</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">args</span>.n</span>.toNat</span> <a href="../../.././Init/Prelude.html#HShiftRight.hShiftRight">&gt;&gt;&gt;</a> <span class="fn">(<span class="fn"><span class="fn">qr</span>.wn</span> <a href="../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">args</span>.n</span>.toNat</span> <a href="../../.././Init/Prelude.html#HShiftRight.hShiftRight">&gt;&gt;&gt;</a> <span class="fn"><span class="fn">qr</span>.wn</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">2</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">args</span>.n</span>.getLsbD</span> <span class="fn">(<span class="fn"><span class="fn">qr</span>.wn</span> <a href="../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span>)</span>)</span>.toNat</span></span></span></div></div><p>The value of shifting right by <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.wn">wn</a> - 1</code> equals shifting by <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.wn">wn</a></code> and grabbing the lsb at <code>(wn - 1)</code>.</p></div></div><div class="decl" id="BitVec.lawful_divSubtractShift"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L949-L994">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.lawful_divSubtractShift"><span class="name">BitVec</span>.<span class="name">lawful_divSubtractShift</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{args : <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs">BitVec.DivModArgs</a> <span class="fn">w</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(qr : <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState">BitVec.DivModState</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.Poised">BitVec.DivModState.Poised</a> <span class="fn">args</span> <span class="fn">qr</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.Lawful">BitVec.DivModState.Lawful</a> <span class="fn">args</span> <span class="fn">(<a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.divSubtractShift">BitVec.divSubtractShift</a> <span class="fn">args</span> <span class="fn">qr</span>)</span></span></div></div><p>We show that the output of <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.divSubtractShift">divSubtractShift</a></code> is lawful, which tells us that it
obeys the division equation.</p></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Core-division-algorithm-circuit">Core division algorithm circuit <a class="hover-link" href="#Core-division-algorithm-circuit">#</a></h3></div><div class="decl" id="BitVec.divRec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L998-L1003">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.divRec"><span class="name">BitVec</span>.<span class="name">divRec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(m : <a href="../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(args : <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs">BitVec.DivModArgs</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(qr : <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState">BitVec.DivModState</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState">BitVec.DivModState</a> <span class="fn">w</span></span></div></div><p>A recursive definition of division for bitblasting, in terms of a shift-subtraction circuit.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.divRec">BitVec.divRec</a> <span class="fn">0</span> <span class="fn">args</span> <span class="fn">qr</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">qr</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.divRec">BitVec.divRec</a> <span class="fn"><span class="fn">s_1</span>.succ</span> <span class="fn">args</span> <span class="fn">qr</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.divRec">BitVec.divRec</a> <span class="fn">s_1</span> <span class="fn">args</span> <span class="fn">(<a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.divSubtractShift">BitVec.divSubtractShift</a> <span class="fn">args</span> <span class="fn">qr</span>)</span></span></span></li></ul></details><details id="instances-for-list-BitVec.divRec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="BitVec.divRec_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L1005-L1007">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.divRec_zero"><span class="name">BitVec</span>.<span class="name">divRec_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{args : <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs">BitVec.DivModArgs</a> <span class="fn">w</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(qr : <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState">BitVec.DivModState</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.divRec">BitVec.divRec</a> <span class="fn">0</span> <span class="fn">args</span> <span class="fn">qr</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">qr</span></span></div></div></div></div><div class="decl" id="BitVec.divRec_succ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L1009-L1012">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.divRec_succ"><span class="name">BitVec</span>.<span class="name">divRec_succ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(m : <a href="../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(args : <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs">BitVec.DivModArgs</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(qr : <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState">BitVec.DivModState</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.divRec">BitVec.divRec</a> <span class="fn">(<span class="fn">m</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span>)</span> <span class="fn">args</span> <span class="fn">qr</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.divRec">BitVec.divRec</a> <span class="fn">m</span> <span class="fn">args</span> <span class="fn">(<a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.divSubtractShift">BitVec.divSubtractShift</a> <span class="fn">args</span> <span class="fn">qr</span>)</span></span></span></div></div></div></div><div class="decl" id="BitVec.lawful_divRec"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L1014-L1030">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.lawful_divRec"><span class="name">BitVec</span>.<span class="name">lawful_divRec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{args : <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs">BitVec.DivModArgs</a> <span class="fn">w</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{qr : <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState">BitVec.DivModState</a> <span class="fn">w</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.Lawful">BitVec.DivModState.Lawful</a> <span class="fn">args</span> <span class="fn">qr</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.Lawful">BitVec.DivModState.Lawful</a> <span class="fn">args</span> <span class="fn">(<a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.divRec">BitVec.divRec</a> <span class="fn"><span class="fn">qr</span>.wn</span> <span class="fn">args</span> <span class="fn">qr</span>)</span></span></div></div><p>The output of <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.divRec">divRec</a></code> is a lawful state</p></div></div><div class="decl" id="BitVec.wn_divRec"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L1032-L1043">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.wn_divRec"><span class="name">BitVec</span>.<span class="name">wn_divRec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(args : <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs">BitVec.DivModArgs</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(qr : <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState">BitVec.DivModState</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.divRec">BitVec.divRec</a> <span class="fn"><span class="fn">qr</span>.wn</span> <span class="fn">args</span> <span class="fn">qr</span>)</span>.wn</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></span></div></div><p>The output of <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.divRec">divRec</a></code> has no more bits left to process (i.e., <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.wn">wn</a> = 0</code>)</p></div></div><div class="decl" id="BitVec.udiv_eq_divRec"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L1045-L1051">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.udiv_eq_divRec"><span class="name">BitVec</span>.<span class="name">udiv_eq_divRec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d n : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hd : <span class="fn"><span class="fn">0#<span class="fn">w</span></span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">d</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">let <span class="fn">out</span> := <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.divRec">BitVec.divRec</a> <span class="fn">w</span> <span class="fn">{ <span class="fn">n</span> := <span class="fn">n</span>, <span class="fn">d</span> := <span class="fn">d</span> }</span> <span class="fn">(<a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.init">BitVec.DivModState.init</a> <span class="fn">w</span>)</span></span>;
<span class="fn"><span class="fn"><span class="fn">n</span> <a href="../../.././Init/Prelude.html#HDiv.hDiv">/</a> <span class="fn">d</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">out</span>.q</span></span></span></div></div><p>The result of <code>udiv</code> agrees with the result of the division recurrence.</p></div></div><div class="decl" id="BitVec.umod_eq_divRec"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L1053-L1059">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.umod_eq_divRec"><span class="name">BitVec</span>.<span class="name">umod_eq_divRec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d n : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hd : <span class="fn"><span class="fn">0#<span class="fn">w</span></span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">d</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">let <span class="fn">out</span> := <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.divRec">BitVec.divRec</a> <span class="fn">w</span> <span class="fn">{ <span class="fn">n</span> := <span class="fn">n</span>, <span class="fn">d</span> := <span class="fn">d</span> }</span> <span class="fn">(<a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState.init">BitVec.DivModState.init</a> <span class="fn">w</span>)</span></span>;
<span class="fn"><span class="fn"><span class="fn">n</span> <a href="../../.././Init/Prelude.html#HMod.hMod">%</a> <span class="fn">d</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">out</span>.r</span></span></span></div></div><p>The result of <code>umod</code> agrees with the result of the division recurrence.</p></div></div><div class="decl" id="BitVec.divRec_succ'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L1061-L1077">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.divRec_succ'"><span class="name">BitVec</span>.<span class="name">divRec_succ'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(m : <a href="../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(args : <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs">BitVec.DivModArgs</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(qr : <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModState">BitVec.DivModState</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.divRec">BitVec.divRec</a> <span class="fn">(<span class="fn">m</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span>)</span> <span class="fn">args</span> <span class="fn">qr</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">let <span class="fn">wn</span> := <span class="fn"><span class="fn"><span class="fn">qr</span>.wn</span> <a href="../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span></span>;
  <span class="fn">let <span class="fn">wr</span> := <span class="fn"><span class="fn"><span class="fn">qr</span>.wr</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></span>;
  <span class="fn">let <span class="fn">r'</span> := <span class="fn"><span class="fn"><span class="fn"><span class="fn">qr</span>.r</span>.shiftConcat</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">args</span>.n</span>.getLsbD</span> <span class="fn">wn</span>)</span></span>;
  <span class="fn">let <span class="fn">input</span> :=
    <span class="fn">if <span class="fn"><span class="fn">r'</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">args</span>.d</span></span> then <span class="fn">{ <span class="fn">wn</span> := <span class="fn">wn</span>, <span class="fn">wr</span> := <span class="fn">wr</span>, <span class="fn">q</span> := <span class="fn"><span class="fn"><span class="fn"><span class="fn">qr</span>.q</span>.shiftConcat</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a></span>, <span class="fn">r</span> := <span class="fn">r'</span> }</span>
    else <span class="fn">{ <span class="fn">wn</span> := <span class="fn">wn</span>, <span class="fn">wr</span> := <span class="fn">wr</span>, <span class="fn">q</span> := <span class="fn"><span class="fn"><span class="fn"><span class="fn">qr</span>.q</span>.shiftConcat</span> <a href="../../.././Init/Prelude.html#Bool.true">true</a></span>, <span class="fn">r</span> := <span class="fn"><span class="fn">r'</span> <a href="../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn"><span class="fn">args</span>.d</span></span> }</span></span>;
  <span class="fn"><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.divRec">BitVec.divRec</a> <span class="fn">m</span> <span class="fn">args</span> <span class="fn">input</span></span></span></span></span></span></span></div></div></div></div><div class="decl" id="BitVec.sshiftRightRec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L1081-L1091">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.sshiftRightRec"><span class="name">BitVec</span>.<span class="name">sshiftRightRec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w₁ w₂ : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(n : <a href="../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₁</span></span></div></div><p><code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.sshiftRightRec">sshiftRightRec</a> x y <a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs.n">n</a></code> shifts <code>x</code> arithmetically/signed to the right by the first <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs.n">n</a></code> bits of <code>y</code>.
The theorem <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.sshiftRight_eq_sshiftRightRec">sshiftRight_eq_sshiftRightRec</a></code> proves the equivalence of <code>(x.sshiftRight y)</code> and <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.sshiftRightRec">sshiftRightRec</a></code>.
Together with equations <code>sshiftRightRec_zero</code>, <code>sshiftRightRec_succ</code>,
this allows us to unfold <code>sshiftRight</code> into a circuit for bitblasting.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.sshiftRightRec</span> <span class="fn">y</span> <span class="fn">0</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">x</span>.sshiftRight'</span> <span class="fn">(<span class="fn">y</span> <a href="../../.././Init/Prelude.html#HAnd.hAnd">&amp;&amp;&amp;</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Basic.html#BitVec.twoPow">BitVec.twoPow</a> <span class="fn">w₂</span> <span class="fn">0</span></span>)</span></span></span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.sshiftRightRec</span> <span class="fn">y</span> <span class="fn"><span class="fn">s_1</span>.succ</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">x</span>.sshiftRightRec</span> <span class="fn">y</span> <span class="fn">s_1</span>)</span>.sshiftRight'</span> <span class="fn">(<span class="fn">y</span> <a href="../../.././Init/Prelude.html#HAnd.hAnd">&amp;&amp;&amp;</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Basic.html#BitVec.twoPow">BitVec.twoPow</a> <span class="fn">w₂</span> <span class="fn"><span class="fn">s_1</span>.succ</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-BitVec.sshiftRightRec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="BitVec.sshiftRightRec_zero_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L1093-L1096">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.sshiftRightRec_zero_eq"><span class="name">BitVec</span>.<span class="name">sshiftRightRec_zero_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w₁ w₂ : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.sshiftRightRec</span> <span class="fn">y</span> <span class="fn">0</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">x</span>.sshiftRight'</span> <span class="fn">(<span class="fn">y</span> <a href="../../.././Init/Prelude.html#HAnd.hAnd">&amp;&amp;&amp;</a> <span class="fn">1#<span class="fn">w₂</span></span>)</span></span></span></div></div></div></div><div class="decl" id="BitVec.sshiftRightRec_succ_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L1098-L1101">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.sshiftRightRec_succ_eq"><span class="name">BitVec</span>.<span class="name">sshiftRightRec_succ_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w₁ w₂ : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(n : <a href="../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.sshiftRightRec</span> <span class="fn">y</span> <span class="fn">(<span class="fn">n</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">x</span>.sshiftRightRec</span> <span class="fn">y</span> <span class="fn">n</span>)</span>.sshiftRight'</span> <span class="fn">(<span class="fn">y</span> <a href="../../.././Init/Prelude.html#HAnd.hAnd">&amp;&amp;&amp;</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Basic.html#BitVec.twoPow">BitVec.twoPow</a> <span class="fn">w₂</span> <span class="fn">(<span class="fn">n</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="BitVec.sshiftRight'_or_of_and_eq_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L1103-L1112">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.sshiftRight'_or_of_and_eq_zero"><span class="name">BitVec</span>.<span class="name">sshiftRight'_or_of_and_eq_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w₁ w₂ : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₁</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y z : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₂</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">y</span> <a href="../../.././Init/Prelude.html#HAnd.hAnd">&amp;&amp;&amp;</a> <span class="fn">z</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">0#<span class="fn">w₂</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.sshiftRight'</span> <span class="fn">(<span class="fn">y</span> <a href="../../.././Init/Prelude.html#HOr.hOr">|||</a> <span class="fn">z</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">x</span>.sshiftRight'</span> <span class="fn">y</span>)</span>.sshiftRight'</span> <span class="fn">z</span></span></span></div></div><p>If <code>y &amp;&amp;&amp; z = 0</code>, <code>x.sshiftRight (y ||| z) = (x.sshiftRight y).sshiftRight z</code>.
This follows as <code>y &amp;&amp;&amp; z = 0</code> implies <code>y ||| z = y + z</code>,
and thus <code>x.sshiftRight (y ||| z) = x.sshiftRight (y + z) = (x.sshiftRight y).sshiftRight z</code>.</p></div></div><div class="decl" id="BitVec.sshiftRightRec_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L1114-L1128">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.sshiftRightRec_eq"><span class="name">BitVec</span>.<span class="name">sshiftRightRec_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w₁ w₂ : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(n : <a href="../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.sshiftRightRec</span> <span class="fn">y</span> <span class="fn">n</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">x</span>.sshiftRight'</span> <span class="fn">(<a href="../../.././Init/Data/BitVec/Basic.html#BitVec.setWidth">BitVec.setWidth</a> <span class="fn">w₂</span> <span class="fn">(<a href="../../.././Init/Data/BitVec/Basic.html#BitVec.setWidth">BitVec.setWidth</a> <span class="fn">(<span class="fn">n</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span>)</span> <span class="fn">y</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="BitVec.sshiftRight_eq_sshiftRightRec"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L1130-L1138">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.sshiftRight_eq_sshiftRightRec"><span class="name">BitVec</span>.<span class="name">sshiftRight_eq_sshiftRightRec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w₁ w₂ i : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">x</span>.sshiftRight'</span> <span class="fn">y</span>)</span>.getLsbD</span> <span class="fn">i</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">x</span>.sshiftRightRec</span> <span class="fn">y</span> <span class="fn">(<span class="fn">w₂</span> <a href="../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span>)</span>)</span>.getLsbD</span> <span class="fn">i</span></span></span></div></div><p>Show that <code>x.sshiftRight y</code> can be written in terms of <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.sshiftRightRec">sshiftRightRec</a></code>.
This can be unfolded in terms of <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.sshiftRightRec_zero_eq">sshiftRightRec_zero_eq</a></code>, <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.sshiftRightRec_succ_eq">sshiftRightRec_succ_eq</a></code> for bitblasting.</p></div></div><div class="decl" id="BitVec.ushiftRightRec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L1142-L1155">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.ushiftRightRec"><span class="name">BitVec</span>.<span class="name">ushiftRightRec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w₁ w₂ : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(n : <a href="../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₁</span></span></div></div><p><code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.ushiftRightRec">ushiftRightRec</a> x y <a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs.n">n</a></code> shifts <code>x</code> logically to the right by the first <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.DivModArgs.n">n</a></code> bits of <code>y</code>.</p><p>The theorem <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.shiftRight_eq_ushiftRightRec">shiftRight_eq_ushiftRightRec</a></code> proves the equivalence
of <code>(x &gt;&gt;&gt; y)</code> and <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.ushiftRightRec">ushiftRightRec</a></code>.</p><p>Together with equations <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.ushiftRightRec_zero">ushiftRightRec_zero</a></code>, <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.ushiftRightRec_succ">ushiftRightRec_succ</a></code>,
this allows us to unfold <code>ushiftRight</code> into a circuit for bitblasting.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.ushiftRightRec</span> <span class="fn">y</span> <span class="fn">0</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#HShiftRight.hShiftRight">&gt;&gt;&gt;</a> <span class="fn">(<span class="fn">y</span> <a href="../../.././Init/Prelude.html#HAnd.hAnd">&amp;&amp;&amp;</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Basic.html#BitVec.twoPow">BitVec.twoPow</a> <span class="fn">w₂</span> <span class="fn">0</span></span>)</span></span></span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.ushiftRightRec</span> <span class="fn">y</span> <span class="fn"><span class="fn">s_1</span>.succ</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.ushiftRightRec</span> <span class="fn">y</span> <span class="fn">s_1</span></span> <a href="../../.././Init/Prelude.html#HShiftRight.hShiftRight">&gt;&gt;&gt;</a> <span class="fn">(<span class="fn">y</span> <a href="../../.././Init/Prelude.html#HAnd.hAnd">&amp;&amp;&amp;</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Basic.html#BitVec.twoPow">BitVec.twoPow</a> <span class="fn">w₂</span> <span class="fn"><span class="fn">s_1</span>.succ</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-BitVec.ushiftRightRec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="BitVec.ushiftRightRec_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L1157-L1160">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.ushiftRightRec_zero"><span class="name">BitVec</span>.<span class="name">ushiftRightRec_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w₁ w₂ : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.ushiftRightRec</span> <span class="fn">y</span> <span class="fn">0</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#HShiftRight.hShiftRight">&gt;&gt;&gt;</a> <span class="fn">(<span class="fn">y</span> <a href="../../.././Init/Prelude.html#HAnd.hAnd">&amp;&amp;&amp;</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Basic.html#BitVec.twoPow">BitVec.twoPow</a> <span class="fn">w₂</span> <span class="fn">0</span></span>)</span></span></span></div></div></div></div><div class="decl" id="BitVec.ushiftRightRec_succ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L1162-L1165">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.ushiftRightRec_succ"><span class="name">BitVec</span>.<span class="name">ushiftRightRec_succ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w₁ w₂ n : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.ushiftRightRec</span> <span class="fn">y</span> <span class="fn">(<span class="fn">n</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.ushiftRightRec</span> <span class="fn">y</span> <span class="fn">n</span></span> <a href="../../.././Init/Prelude.html#HShiftRight.hShiftRight">&gt;&gt;&gt;</a> <span class="fn">(<span class="fn">y</span> <a href="../../.././Init/Prelude.html#HAnd.hAnd">&amp;&amp;&amp;</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Basic.html#BitVec.twoPow">BitVec.twoPow</a> <span class="fn">w₂</span> <span class="fn">(<span class="fn">n</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="BitVec.ushiftRight'_or_of_and_eq_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L1167-L1175">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.ushiftRight'_or_of_and_eq_zero"><span class="name">BitVec</span>.<span class="name">ushiftRight'_or_of_and_eq_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w₁ w₂ : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₁</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y z : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₂</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">y</span> <a href="../../.././Init/Prelude.html#HAnd.hAnd">&amp;&amp;&amp;</a> <span class="fn">z</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">0#<span class="fn">w₂</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#HShiftRight.hShiftRight">&gt;&gt;&gt;</a> <span class="fn">(<span class="fn">y</span> <a href="../../.././Init/Prelude.html#HOr.hOr">|||</a> <span class="fn">z</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#HShiftRight.hShiftRight">&gt;&gt;&gt;</a> <span class="fn">y</span></span> <a href="../../.././Init/Prelude.html#HShiftRight.hShiftRight">&gt;&gt;&gt;</a> <span class="fn">z</span></span></span></div></div><p>If <code>y &amp;&amp;&amp; z = 0</code>, <code>x &gt;&gt;&gt; (y ||| z) = x &gt;&gt;&gt; y &gt;&gt;&gt; z</code>.
This follows as <code>y &amp;&amp;&amp; z = 0</code> implies <code>y ||| z = y + z</code>,
and thus <code>x &gt;&gt;&gt; (y ||| z) = x &gt;&gt;&gt; (y + z) = x &gt;&gt;&gt; y &gt;&gt;&gt; z</code>.</p></div></div><div class="decl" id="BitVec.ushiftRightRec_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L1177-L1191">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.ushiftRightRec_eq"><span class="name">BitVec</span>.<span class="name">ushiftRightRec_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w₁ w₂ : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(n : <a href="../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.ushiftRightRec</span> <span class="fn">y</span> <span class="fn">n</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#HShiftRight.hShiftRight">&gt;&gt;&gt;</a> <span class="fn"><a href="../../.././Init/Data/BitVec/Basic.html#BitVec.setWidth">BitVec.setWidth</a> <span class="fn">w₂</span> <span class="fn">(<a href="../../.././Init/Data/BitVec/Basic.html#BitVec.setWidth">BitVec.setWidth</a> <span class="fn">(<span class="fn">n</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span>)</span> <span class="fn">y</span>)</span></span></span></span></div></div></div></div><div class="decl" id="BitVec.shiftRight_eq_ushiftRightRec"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Init/Data/BitVec/Bitblast.lean#L1193-L1201">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.shiftRight_eq_ushiftRightRec"><span class="name">BitVec</span>.<span class="name">shiftRight_eq_ushiftRightRec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{w₁ w₂ : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(y : <span class="fn"><a href="../../.././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#HShiftRight.hShiftRight">&gt;&gt;&gt;</a> <span class="fn">y</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">x</span>.ushiftRightRec</span> <span class="fn">y</span> <span class="fn">(<span class="fn">w₂</span> <a href="../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span>)</span></span></span></div></div><p>Show that <code>x &gt;&gt;&gt; y</code> can be written in terms of <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.ushiftRightRec">ushiftRightRec</a></code>.
This can be unfolded in terms of <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.ushiftRightRec_zero">ushiftRightRec_zero</a></code>, <code><a href="../../.././Init/Data/BitVec/Bitblast.html#BitVec.ushiftRightRec_succ">ushiftRightRec_succ</a></code> for bitblasting.</p></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>