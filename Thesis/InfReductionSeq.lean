import Mathlib.Tactic
import Mathlib.Logic.Relation
import Thesis.ReductionSeq

set_option pp.privateNames true

namespace Thesis.InfReductionSeq

section inf_reduction_seq

open Relation Classical

variable {α}
variable {r: Rel α α}

/-
An infinite r⁺-reduction sequence a₀ →⁺ a₁ →⁺ ... can be flattened
to an infinite r-reduction sequence a₀ → ... → a₁ → ... which contains all aₙ.

The formalization in this section came to be as a result of a discussion in the
Lean Zulip. Many thanks to Daniel Weber and Edward van de Meent for their
suggestions :^).

https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/.E2.9C.94.20Infinite.20reduction.20sequences.20in.20abstract.20rewriting/near/453168755
-/
section flatten_trans_seq


/--
A single transitive step `r⁺ a b` can be expanded to a list of reducts `l`,
ending in `b`, such that `List.Chain r a l`.
-/
private lemma trans_chain: r⁺ a b → ∃l, l.getLast? = some b ∧ List.Chain r a l := by
  intro hr
  induction hr using TransGen.head_induction_on with
  | @base a h =>
    use [b]; simp; exact h
  | @ih a c h₁ h₂ ih =>
    obtain ⟨l, hl, hchain⟩ := ih
    use c::l
    simp [hl, h₁, hchain]
    show (c :: l).getLast? = some b
    exact Option.mem_def.mp (List.mem_getLast?_cons hl) -- suggested by apply?


/--
`trans_chain'` chooses a list that has the properties given by `trans_chain`.
-/
private noncomputable def trans_chain': r⁺ a b → List α :=
  fun h ↦ choose (trans_chain h)

/--
The list returned by `trans_chain'` has the properties given by `trans_chain`.
-/
private lemma trans_chain'.spec (h: r⁺ a b):
    (trans_chain' h).getLast? = b ∧ List.Chain r a (trans_chain' h) := by
  simp [choose_spec (trans_chain h), trans_chain']

/-- `trans_chain' h` is nonempty. -/
private lemma trans_chain'.nonempty: (trans_chain' h) ≠ [] := by
  have := (spec h).1
  intro heq
  simp_all only [List.getLast?_nil, reduceCtorEq]


/--
An infinite r⁺-reduction sequence can be turned into an infinite
sequence of lists of reducts, as given by `trans_chain'`.
-/
private noncomputable def inf_trans_lists (f: ℕ → α) (hf: reduction_seq r⁺ ⊤ f): ℕ → List α
| n => trans_chain' (hf n (by simp))

/-- Each of the lists in `inf_trans_lists f hf` is nonempty. -/
private lemma inf_trans_lists.nonempty: ∀n, (inf_trans_lists f hf n) ≠ []
| _ => by simp [inf_trans_lists, trans_chain'.nonempty]


/-
We now wish to define a function `ℕ → α` which produces all of the elements
in the expansion of the r⁺-reduction sequence. To do so, we define
a helper function, `aux`, which produces a sequence containing, in order,
the elements from each of the lists of reducts.
-/
section aux

variable (l_seq: ℕ → List α) (hne: ∀n, (l_seq n) ≠ [])

/--
Starting at list no. `list_idx`, get the `elem_idx`th element, going to the next
list if `elem_idx ≥ (l_seq list_idx).length`.

This definition is largely due to Edward van de Meent on the Lean Zulip.
-/
private def aux (list_idx: ℕ) (elem_idx: ℕ) : α :=
  if h: elem_idx < (l_seq list_idx).length then
    (l_seq list_idx)[elem_idx]
  else
    have: elem_idx - (l_seq list_idx).length < elem_idx := by
      have := List.length_pos.mpr <| hne list_idx
      omega
    aux (list_idx + 1) (elem_idx - (l_seq list_idx).length)

/--
If `x := aux l_seq hne (m + 1) k`, i.e. the `k`th element starting from list
`m + 1`, we can get the same element starting from the previous list `m` by
adding some `n`, which is the length of list `m`.
-/
private lemma aux_skip (m k: ℕ): ∃n, aux l_seq hne m (k + n) = aux l_seq hne (m + 1) k := by
  use (l_seq m).length
  rw [aux]
  simp

/--
An extension of `aux_skip`; we can get the `k`th element starting from list `m + i`
by starting from list `m` and getting the `k + n`th element, where `n` is the
sum of the lengths of the intermediate lists.
-/
private lemma aux_skip_i (i m k: ℕ): ∃n, aux l_seq hne m (k + n) = aux l_seq hne (m + i) k := by
  induction i generalizing m with
  | zero => use 0; simp
  | succ i ih =>
    obtain ⟨n, hn⟩ := ih (m + 1)
    obtain ⟨n', hn'⟩ := aux_skip l_seq hne m (k + n)
    use (n + n')
    simp [hn, hn', <-add_assoc, add_comm i]

/--
If `f` is an infinite transitive reduction sequence, each element > 0 appears
as the last element of the `n - 1`th list in the sequence generated by `aux ...`.
-/
private lemma aux_elem' (f: ℕ → α) (hf: reduction_seq r⁺ ⊤ f) (n) (hn: n > 0):
    let ls := inf_trans_lists f hf
    f n = aux ls inf_trans_lists.nonempty (n - 1) ((ls (n - 1)).length - 1) := by
  simp +singlePass [aux]
  rw [dif_pos]
  · have ⟨h₁, h₂⟩ := trans_chain'.spec (hf.inf_step (n - 1))
    have heq₂ := List.getLast?_eq_getLast (trans_chain' (hf.inf_step (n - 1))) trans_chain'.nonempty
    simp [List.getLast_eq_getElem] at heq₂
    rw [heq₂] at h₁
    simp_all [inf_trans_lists]
    congr
    omega
  have h': 0 < (inf_trans_lists f hf (n - 1)).length :=
    List.length_pos.mpr <| inf_trans_lists.nonempty (n - 1)
  omega

/--
By `aux_skip_i`, `aux_elem'` can be modified to prove each element of `f` is
reachable from the first list. Given that `aux _ _ 0` is the basis of our
eventual sequence, this essentially proves that all elements in `f` (except `f 0`)
appear in the expanded sequence.
-/
private lemma aux_elem (f: ℕ → α) (hf: reduction_seq r⁺ ⊤ f) (n: ℕ) (hn: n > 0):
    ∃n', f n = aux (inf_trans_lists f hf) inf_trans_lists.nonempty 0 n' := by
  have := aux_elem' f hf n hn
  obtain ⟨n, hn⟩ := aux_skip_i (inf_trans_lists f hf) inf_trans_lists.nonempty (n - 1) 0 ((inf_trans_lists f hf (n - 1)).length - 1)
  simp only [zero_add] at hn
  simp [<-hn] at this
  tauto

/-
If the first list forms an r-chain, and each subsequent list forms an r-chain
with the last element of the list before it, `aux l_seq hne` forms an infinite
r-reduction sequence for every start list idx `list_idx`.

Parts of this lemma and its proof, crucially the structure and hypotheses,
are due to Edward van de Meent on the Lean Zulip.
-/
private lemma aux_inf_reduction_seq
    -- the first list by itself forms a chain
    (h₀ : List.Chain' r (l_seq 0))
    -- and each subsequent list continues where the last one left off.
    (h₁ : ∀ n, List.Chain r ((l_seq n).getLast (hne n)) (l_seq (n + 1))):
    ∀ list_idx, reduction_seq r ⊤ (aux l_seq hne list_idx) := by
  simp [List.chain_iff_get, List.chain'_iff_get, List.getLast_eq_getElem] at h₀ h₁ ⊢
  intro list_idx elem_idx
  induction list_idx, elem_idx using aux.induct l_seq hne
  next list_idx elem_idx hlt =>
    rw [aux, dif_pos hlt, aux, aux]
    split
    case isTrue h =>
      rcases list_idx with (_ | list_idx)
      · apply h₀
        omega
      · apply (h₁ list_idx).right
        omega
    case isFalse h =>
      obtain ⟨rfl⟩: elem_idx = (l_seq list_idx).length - 1 := by omega
      simp_all
      have := List.length_pos.mpr (hne (list_idx + 1))
      rw [dif_pos (by omega)]
      · convert (h₁ list_idx).left this
        omega
  next list_idx elem_idx h₁ _ ih =>
    rw [aux, dif_neg h₁]
    convert ih using 1
    rw [aux, dif_neg (h₁ ∘ ((lt_add_one elem_idx).trans ·))]
    congr
    omega


/-- The first reduct list of an infinite reduction sequence forms a chain. -/
private lemma hchain0 (f: ℕ → α) (hf: reduction_seq r⁺ ⊤ f): List.Chain' r (inf_trans_lists f hf 0) := by
  obtain ⟨-, hchain⟩ := trans_chain'.spec (hf.inf_step 0)
  rw [inf_trans_lists, List.Chain'.eq_def]
  split <;> simp_all

/--
The last element of the `n`th reduct list forms a chain with the `n + 1`th
reduct list.
-/
private lemma hchain1 (f: ℕ → α) (hf: reduction_seq r⁺ ⊤ f):
    ∀n, List.Chain r ((inf_trans_lists f hf n).getLast (inf_trans_lists.nonempty n)) (inf_trans_lists f hf (n + 1)) := by
  intro n
  simp [inf_trans_lists]
  obtain ⟨hlast₁, -⟩ := trans_chain'.spec (hf.inf_step n)
  obtain ⟨-, hchain₂⟩:= trans_chain'.spec (hf.inf_step (n + 1))
  convert hchain₂
  rw [<-Option.some_inj, <-hlast₁, List.getLast?_eq_getLast]


/--
We form our expanded sequence by starting with `f 0`, and then continuing with
all reducts of `f 0` in the infinite transitive sequence, as generated by `aux`.
-/
private noncomputable def seq (f: ℕ → α) (hf: reduction_seq r⁺ ⊤ f): ℕ → α
| 0 => f 0
| n + 1 => aux (inf_trans_lists f hf) inf_trans_lists.nonempty 0 n

/-- `seq` contains all elements of the infinite transitive sequence. -/
private lemma seq_contains_elems (f: ℕ → α) (hf: reduction_seq r⁺ ⊤ f):
    ∀n, ∃m, f n = seq f hf m := by
  intro n
  cases n with
  | zero => use 0; simp [seq]
  | succ n =>
    simp [seq]
    obtain ⟨n', hn'⟩ := aux_elem f hf (n + 1) (by omega)
    use n' + 1

/-- `seq f hf` forms an infinite r-reduction sequence. -/
private lemma seq_inf_reduction_seq (f: ℕ → α) (hf: reduction_seq r⁺ ⊤ f):
    reduction_seq r ⊤ (seq f hf) := by
  intro n
  cases n with
  | zero =>
    simp [seq]
    have h: 0 < (inf_trans_lists f hf 0).length := by
      exact List.length_pos.mpr (inf_trans_lists.nonempty 0)
    rw [aux, dif_pos h]
    obtain ⟨-, hchain⟩ := trans_chain'.spec (hf.inf_step 0)
    rw [List.chain_iff_get] at hchain
    exact hchain.1 h
  | succ n =>
    simp [↓ENat.coe_lt_top]
    have :=
      (aux_inf_reduction_seq (inf_trans_lists f hf)
       inf_trans_lists.nonempty (hchain0 f hf) (hchain1 f hf) 0 n)
    simpa [seq]


/--
Any infinite r⁺-reduction sequence has a corresponding infinite r-reduction
sequence, which contains all of the elements of the transitive sequence and
starts with the same element.
-/
lemma inf_reduction_seq.exists_regular_of_trans (f: ℕ → α) (hf: reduction_seq r⁺ ⊤ f):
    ∃f', reduction_seq r ⊤ f' ∧
         (∀n, ∃m, f n = f' m) ∧
         f 0 = f' 0 := by
  use (seq f hf)
  and_intros
  · exact seq_inf_reduction_seq f hf
  · exact seq_contains_elems f hf
  · simp [seq]

end aux

end flatten_trans_seq

noncomputable section flatten_refl_trans_seq

/-
Building an `inf_reduction_seq.exists_regular_of_rt`
for r∗-reduction sequences is more complicated. If the
reflexive-transitive seq has a point beyond which all steps are reflexive,
the 'flattened' version would be finite, so the length of the resulting
reduction sequence is not fixed (we will use the general `reduction_seq`).

To avoid duplicating all the work done before, we use the following process to
produce an r-reduction sequence `f'` from an infinite r∗-reduction sequence `f`.
- If `f` is equivalent to a finite r∗-reduction sequence `g`, we flatten
  this finite r∗-reduction sequence using `ReductionSeq.flatten`.
- If `f` is _not_ equivalent to a finite r∗-reduction sequence, there must
  be an infinite amount of non-reflexive steps. We can therefore translate
  `f` into an infinite r⁺-reduction sequence, which we can process as above
  to produce an infinite r-reduction sequence.
-/

/--
We call an infinite reduction sequence _degenerate_ if, from some point onwards,
it only contains steps from one element to itself.
-/
def _root_.Thesis.reduction_seq.degenerate (hseq: reduction_seq r ⊤ f) :=
  ∃n, ∀m ≥ n, f m = f (m + 1)

private def transitive_step_guarantee (hseq: reduction_seq r ⊤ f) :=
  ∀n, ∃m ≥ n, f m ≠ f (m + 1) ∧ (∀m' ∈ Set.Ioc n m, f n = f m')

lemma tsg_of_not_degenerate
    (hseq: reduction_seq r∗ ⊤ f) (hndeg: ¬hseq.degenerate):
    transitive_step_guarantee hseq := by
  dsimp [reduction_seq.degenerate] at hndeg
  push_neg at hndeg
  intro n
  have spec := Nat.find_spec (hndeg n)
  have is_min := @Nat.find_min _ _ (H := hndeg n)
  use Nat.find (hndeg n)
  and_intros
  · omega
  · tauto
  · intro m' hm'
    simp at hm'
    suffices h: ∀k ≤ (m' - n), f n = f (n + k) by
      · have := h (m' - n)
        simp at this; convert this
        omega
    intro k hk
    induction k with
    | zero => rfl
    | succ k ih =>
      have: f n = f (n + k) := ih ?_
      have: f (n + k) = f (n + k + 1) := hm'.2 (n + k) ?_ ?_
      all_goals try omega
      cc

section refl_trans_seq_has_guaranteed_step

variable {f: ℕ → α} (hf: reduction_seq r∗ ⊤ f) (htsg: transitive_step_guarantee hf)

/--
From some index `n` we step to a next index `choose (hgs n) + 1`, which is the
end of a transitive step.
-/
private def trans_idx_step (n: ℕ): ℕ :=
  choose (htsg n) + 1

/--
By iterating `trans_idx_step`, we can generate a sequence of indices into `f`
which represent all transitive steps in `f`.
-/
private def trans_idxs (n: ℕ): ℕ :=
  (trans_idx_step hf htsg)^[n] 0

/--
We form the sequence by getting the element at each index given by `trans_idxs`
-/
private def trans_seq (n: ℕ): α :=
  f (trans_idxs hf htsg n)

/-- Taking a step from index `k` yields an index greater than `k`. -/
private lemma trans_idx_step_inc (k: ℕ): k < trans_idx_step hf htsg k := by
  simp only [trans_idx_step]
  linarith [choose_spec (htsg k)]

/-- Doing an extra iteration of `trans_idx_step` yields a larger index. -/
private lemma trans_idxs_inc (k: ℕ): trans_idxs hf htsg k < trans_idxs hf htsg (k + 1) := by
  simp only [trans_idxs, Function.iterate_succ', Function.comp, trans_idx_step_inc]

/-- For all n, there is an element of `trans_idxs` that is larger than n. -/
private lemma trans_idxs_tends_to_infty (n: ℕ): ∃k, n < trans_idxs hf htsg k := by
  induction n with
  | zero =>
    use 1; simp [trans_idxs]
    exact trans_idx_step_inc hf htsg 0
  | succ n ih =>
    obtain ⟨k, hk⟩ := ih
    use (k + 1)
    simp [trans_idxs_inc hf htsg k, Nat.lt_of_le_of_lt hk]

/--
If `n` is inbetween `trans_idxs f hgs k` and `trans_idxs f hgs (k + 1)`,
then `f n` must be equal to `f (trans_idxs f hgs k)`. Hence `f n` is an
element of `trans_seq f hgs`.
-/
private lemma trans_idxs_inbetween (k: ℕ):
    ∀n ∈ Set.Ico (trans_idxs hf htsg k) (trans_idxs hf htsg (k + 1)), f (trans_idxs hf htsg k) = f n := by
  set m₁ := trans_idxs hf htsg k with m₁_def
  set m₂ := trans_idxs hf htsg (k + 1) with m₂_def

  rintro n ⟨hn₁, hn₂⟩
  simp only [trans_idxs, Function.iterate_succ', Function.comp, trans_idx_step] at m₂_def
  cases hn₁.lt_or_eq
  case inr h => rw [h]
  obtain ⟨-, -, heq⟩ := choose_spec (htsg m₁)
  apply heq
  rw [Set.mem_Ioc]
  omega

/--
All `n` are sandwiched by two subsequent elements in `trans_idxs f hgs`.
Combining this lemma with `trans_idxs_inbetween` above yields the proof
that `trans_seq f hgs` contains all elements of `f`.
-/
private lemma trans_idxs_sandwich:
    ∀n, ∃k, n ∈ Set.Ico (trans_idxs hf htsg k) (trans_idxs hf htsg (k + 1)) := by
  intro n
  simp

  -- there is some `k` s.t. `trans_idxs f hgs k` is greater than n
  have hkgt := trans_idxs_tends_to_infty hf htsg n

  -- take the least k that satisfies the requirement
  have hk' := Nat.find_spec hkgt
  set k' := Nat.find hkgt with k'_def

  -- this k' cannot be zero, because trans_idxs f hgs 0 = 0.
  cases h: k'
  case zero =>
    simp [h, trans_idxs] at hk'
  case succ k =>
    -- the element in `trans_idxs f hgs` before `k'`,
    -- `k`, must be at most `n`.
    use k
    constructor; swap
    · rwa [h] at hk'
    by_contra! hlt
    have: k + 1 ≤ k := by
      rw [<-h, k'_def]
      exact Nat.find_min' hkgt hlt
    omega

include hf in
/-- `trans_seq f hgs` is an infinite r⁺-reduction sequence. -/
private lemma trans_seq_inf_reduction_seq: reduction_seq r⁺ ⊤ (trans_seq hf htsg) := by
  intro n
  simp only [Function.iterate_succ_apply', trans_seq, trans_idxs, trans_idx_step]
  set f' := (trans_idx_step hf htsg)

  obtain ⟨hc₁, hc₂, hc₃⟩ := choose_spec (htsg (f'^[n] 0))
  set c := choose (htsg (f'^[n] 0))

  have: f (f'^[n] 0) = f c := by
    by_cases heq: (f'^[n] 0 = c)
    · rw [heq]
    · apply hc₃ c
      simp [Nat.lt_of_le_of_ne hc₁ heq]

  rw [this]
  have := reflTransGen_iff_eq_or_transGen.mp <| hf.inf_step c
  tauto


/-- `trans_seq f hgs` contains all elements of `f`. -/
private lemma trans_seq_contains_elems (n): ∃m, (trans_seq hf htsg m) = f n := by
  obtain ⟨k, hk⟩ := trans_idxs_sandwich hf htsg n
  use k, trans_idxs_inbetween _ _ _ _ hk


include hf in
/--
If `hf` is not degenerate, there must be an infinite r-reduction
sequence which contains all elements of `f` and starts with `f 0`.

This lemma first translates `hf` to an infinite r⁺-reduction sequence, and
then uses the techniques for transitive reduction sequences developed above.
-/
private lemma exists_inf_regular_seq_of_not_degenerate (hnd: ¬hf.degenerate):
    ∃f', reduction_seq r ⊤ f' ∧
         (∀n, ∃m, f n = f' m) ∧
         f 0 = f' 0 := by
  have htsg := tsg_of_not_degenerate hf hnd
  let f' := trans_seq hf htsg
  let hf' := trans_seq_inf_reduction_seq hf htsg

  use (seq f' hf')
  and_intros
  · apply seq_inf_reduction_seq f' hf'
  · have h₁ := seq_contains_elems f' hf'
    have h₂ := trans_seq_contains_elems hf htsg
    intro n
    obtain ⟨m₁, hm₁⟩ := h₂ n
    obtain ⟨m₂, hm₂⟩ := h₁ m₁
    use m₂
    simp_all +zetaDelta only
  · unfold f'
    simp [seq, trans_seq, trans_idxs]


end refl_trans_seq_has_guaranteed_step

/--
If the infinite r∗-reduction sequence is degenerate, there must be
some finite r∗-reduction sequence which contains all of the elements of the
infinite r∗-reduction sequence, and starts with the same element.
-/
private lemma finite_of_degenerate (f: ℕ → α) (hf: reduction_seq r∗ ⊤ f) (hdg: hf.degenerate):
    ∃N: ℕ, ∃f', reduction_seq r∗ N f' ∧ (∀n, ∃m ≤ N, f' m = f n) ∧ f' 0 = f 0 := by
  obtain ⟨N, hN⟩ := hdg
  use N, f

  have: ∀m ≥ N, ∀k, f m = f (m + k) := by
    intro m hm k
    induction k with
    | zero => rfl
    | succ k ih =>
      rw [ih, <-add_assoc, hN (m + k) ?_]
      omega

  and_intros <;> try simp [reduction_seq, hf]
  · intro n
    by_cases hle: n ≤ N
    · use n
    · use N
      simp at hle ⊢
      obtain ⟨k, hk⟩: ∃k, n = N + k := by
        apply Nat.exists_eq_add_of_le
        linarith
      simp [hk, this N _ k]


/--
We can flatten a finite r∗-reduction sequence, by round-tripping through
the inductive `ReductionSeq` definition.
-/
private lemma finite_seq_flatten (N: ℕ) (f: ℕ → α) (hrs: reduction_seq r∗ N f):
    ∃N': ℕ, ∃f', reduction_seq r N' f' ∧ f' 0 = f 0 ∧ ∀n ≤ N, ∃m ≤ N', f' m = f n := by

  obtain ⟨ss, hseq, hmem⟩ := ReductionSeq.of_reduction_seq N f hrs
  obtain ⟨ss', hseq', hmem'⟩ := hseq.flatten

  obtain ⟨N', f', hrs', hmem₁, hmem₂⟩ := hseq'.to_reduction_seq

  use N', f', hrs', hmem₂
  intro n hn

  apply hmem₁ (f n) <| hmem' (f n) <| hmem n hn


/--
A statement that is "obvious" when written down in a pen-and-paper proof, but which
is non-trivial to formalize:

If we have an infinite r∗-reduction sequence
`a₀ ->* a₁ ->* a₂ ...`
there must be some (finite or infinite) reduction sequence
`a₀ -> ... -> a₁ -> ... -> a₂ -> ...`
-/
lemma rt_seq_imp_regular_seq (f: ℕ → α) (hf: reduction_seq r∗ ⊤ f):
    ∃N f', reduction_seq r N f' ∧ (∀n, ∃(m: ℕ) (_: m ≤ N), f n = f' m) ∧ f 0 = f' 0 := by
  by_cases hdg: hf.degenerate
  · have := finite_of_degenerate f hf hdg
    obtain ⟨N, f', hseq, heq, heq₀⟩ := this
    obtain ⟨N', f'', hrs, heq'₀, heq'⟩ := finite_seq_flatten N f' hseq
    use N', f'', hrs
    constructor
    · intro n
      obtain ⟨m, hm₁, hm₂⟩ := heq n
      obtain ⟨m', hm'₁, hm'₂⟩ := heq' m hm₁
      norm_cast
      use m', hm'₁
      cc
    · cc
  · obtain ⟨g, hg₁, hg₂, hg₃⟩ := exists_inf_regular_seq_of_not_degenerate hf hdg
    use ⊤, g
    and_intros
    · exact hg₁
    · simp [hg₂]
    · exact hg₃

end flatten_refl_trans_seq

end inf_reduction_seq
end Thesis.InfReductionSeq
