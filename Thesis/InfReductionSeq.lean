import Mathlib.Tactic
import Mathlib.Logic.Relation
import Thesis.ReductionSeq

set_option pp.privateNames true

namespace Thesis.InfReductionSeq

section inf_reduction_seq

open Relation Classical

variable {α}
variable {r: Rel α α}

/-
An infinite r⁺-reduction sequence a₀ →⁺ a₁ →⁺ ... can be flattened
to an infinite r-reduction sequence a₀ → ... → a₁ → ... which contains all aₙ.

The formalization in this section came to be as a result of a discussion in the
Lean Zulip. Many thanks to Daniel Weber and Edward van de Meent for their
suggestions :^).

https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/.E2.9C.94.20Infinite.20reduction.20sequences.20in.20abstract.20rewriting/near/453168755
-/
noncomputable section flatten_trans_seq


/--
A single transitive step `r⁺ a b` can be expanded to a list of reducts `l`,
ending in `b`, such that `List.Chain r a l`.
-/
private lemma trans_chain: r⁺ a b → ∃l, l.getLast? = some b ∧ List.Chain r a l := by
  intro hr
  induction hr using TransGen.head_induction_on with
  | @base a h =>
    use [b]; simp; exact h
  | @ih a c h₁ h₂ ih =>
    obtain ⟨l, hl, hchain⟩ := ih
    use c::l
    simp [hl, h₁, hchain]
    show (c :: l).getLast? = some b
    exact Option.mem_def.mp (List.mem_getLast?_cons hl) -- suggested by apply?


/--
`trans_chain'` chooses a list that has the properties given by `trans_chain`.
-/
private def trans_chain': r⁺ a b → List α :=
  fun h ↦ choose (trans_chain h)

/--
The list returned by `trans_chain'` has the properties given by `trans_chain`.
-/
private lemma trans_chain'.spec (h: r⁺ a b):
    (trans_chain' h).getLast? = b ∧ List.Chain r a (trans_chain' h) := by
  simp [choose_spec (trans_chain h), trans_chain']

/-- `trans_chain' h` has length at least 1. -/
private lemma trans_chain'.nonempty: 1 ≤ (trans_chain' h).length := by
  by_contra! h'
  rw [Nat.lt_one_iff, List.length_eq_zero] at h'
  apply ((trans_chain' h).getLast?_isSome).mp
  rwa [(spec h).1, Option.isSome_some]

/-- `trans_chain' h` is not the empty list. -/
private lemma trans_chain'.nonempty': trans_chain' h ≠ [] :=
  List.length_pos.mp <| Nat.one_add_le_iff.mpr nonempty

/--
An infinite r⁺-reduction sequence can be turned into an infinite
sequence of lists of reducts, as given by `trans_chain'`.
-/
private def inf_trans_lists (f: ℕ → α) (hf: reduction_seq r⁺ ⊤ f): ℕ → List α
| n => trans_chain' (hf.inf_step n)

/-- Each of the lists in `inf_trans_lists f hf` has length at least 1. -/
private lemma inf_trans_lists.nonempty: ∀n, 1 ≤ (inf_trans_lists f hf n).length
| _ => by simp [inf_trans_lists, trans_chain'.nonempty]

/-- Each of the lists in `inf_trans_lists f hf` is nonempty. -/
private lemma inf_trans_lists.nonempty': ∀n, (inf_trans_lists f hf n) ≠ []
| n => List.length_pos.mp <| Nat.one_add_le_iff.mpr <| nonempty n


/-
We now wish to define a function `ℕ → α` which produces all of the elements
in the expansion of the r⁺-reduction sequence. To do so, we define
a helper function, `aux`, which produces a sequence containing, in order,
the elements from each of the lists of reducts.
-/
section aux

variable (l_seq: ℕ → List α) (hne: ∀n, 1 ≤ (l_seq n).length)

/--
Starting at list no. `start`, get the `add`th element, going to the next
list if `add ≥ (l_seq start).length`.

This definition is largely due to Edward van de Meent on the Lean Zulip.
-/
private def aux (start: ℕ) (add: ℕ) : α :=
  if h: add < (l_seq start).length then
    (l_seq start).get ⟨add,h⟩
  else
    have : add - (l_seq start).length < add := by
      exact Nat.sub_lt_self (hne start) (Nat.le_of_not_lt h)
    aux (start + 1) (add - (l_seq start).length)

/--
If `x := aux l_seq hne (m + 1) k`, i.e. the `k`th element starting from list
`m + 1`, we can get the same element starting from the previous list `m` by
adding some `n`, which is the length of list `m`.
-/
private lemma aux_skip (m k: ℕ): ∃n, aux l_seq hne m (k + n) = aux l_seq hne (m + 1) k := by
  use (l_seq m).length
  conv => left; unfold aux; simp

/--
An extension of `aux_skip`; we can get the `k`th element starting from list `m + i`
by starting from list `m` and getting the `k + n`th element, where `n` is the
sum of the lengths of the intermediate lists.
-/
private lemma aux_skip_i (i m k: ℕ): ∃n, aux l_seq hne m (k + n) = aux l_seq hne (m + i) k := by
  induction i generalizing m with
  | zero => use 0; simp
  | succ i ih =>
    obtain ⟨n, hn⟩ := ih (m + 1)
    obtain ⟨n', hn'⟩ := aux_skip l_seq hne m (k + n)
    use (n + n')
    simp [hn, hn', <-add_assoc, add_comm i]

/--
If `f` is an infinite transitive reduction sequence, each element > 0 appears
as the last element of the `n - 1`th list in the sequence generated by `aux ...`.
-/
private lemma aux_elem' (f: ℕ → α) (hf: reduction_seq r⁺ ⊤ f) (n) (hn: n > 0):
    let ls := inf_trans_lists f hf
    f n = aux ls inf_trans_lists.nonempty (n - 1) ((ls (n - 1)).length - 1) := by
  simp +singlePass [aux]
  split
  next h =>
    · have ⟨h₁, h₂⟩ := trans_chain'.spec (hf.inf_step (n - 1))
      have heq₂ := List.getLast?_eq_getLast (trans_chain' (hf.inf_step (n - 1))) trans_chain'.nonempty'
      simp [List.getLast_eq_getElem] at heq₂
      rw [heq₂] at h₁
      simp_all [inf_trans_lists]
      congr
      omega
  next h =>
    · exfalso
      have h': 1 ≤ (inf_trans_lists f hf _).length := inf_trans_lists.nonempty (n - 1)
      omega

/--
By `aux_skip_i`, `aux_elem'` can be modified to prove each element of `f` is
reachable from the first list. Given that `aux _ _ 0` is the basis of our
eventual sequence, this essentially proves that all elements in `f` (except `f 0`)
appear in the expanded sequence.
-/
private lemma aux_elem (f: ℕ → α) (hf: reduction_seq r⁺ ⊤ f) (n: ℕ) (hn: n > 0):
    ∃n', f n = aux (inf_trans_lists f hf) inf_trans_lists.nonempty 0 n' := by
  have := aux_elem' f hf n hn
  obtain ⟨n, hn⟩ := aux_skip_i (inf_trans_lists f hf) inf_trans_lists.nonempty (n - 1) 0 ((inf_trans_lists f hf (n - 1)).length - 1)
  simp only [zero_add] at hn
  simp [<-hn] at this
  tauto

/-
If the first list forms an r-chain, and each subsequent list forms an r-chain
with the last element of the list before it, `aux l_seq hne` forms an infinite
r-reduction sequence for every start list idx `start`.

Parts of this lemma and its proof, crucially the structure and hypotheses,
are due to Edward van de Meent on the Lean Zulip.
-/
private lemma aux_inf_reduction_seq
    -- the first list by itself forms a chain
    (h₀ : List.Chain' r (l_seq 0))
    -- and each subsequent list continues where the last one left off.
    (h₁ : ∀ n, List.Chain r ((l_seq n).getLast (List.length_pos.mp (hne n))) (l_seq (n + 1))):
    ∀ start, reduction_seq r ⊤ (aux l_seq hne start) := by
  simp [List.chain_iff_get, List.chain'_iff_get, List.getLast_eq_getElem] at h₀ h₁ ⊢
  intro start add
  induction start, add using aux.induct l_seq hne
  next start add hlt =>
    rw [aux, dif_pos hlt, aux, aux]
    split
    case isTrue h =>
      rcases start with (_ | start)
      · apply h₀
        omega
      · apply (h₁ start).right
        omega
    case isFalse h =>
      obtain ⟨rfl⟩: add = (l_seq start).length - 1 := by omega
      simp_all
      have := Nat.succ_le.mp (hne (start + 1))
      simpa [dif_pos this] using (h₁ start).left this
  next start add h₁ _ ih =>
    rw [aux, dif_neg h₁]
    convert ih using 1
    rw [aux, dif_neg (h₁ ∘ ((lt_add_one add).trans ·))]
    congr
    omega


/-- The first reduct list of an infinite reduction sequence forms a chain. -/
private lemma hchain0 (f: ℕ → α) (hf: reduction_seq r⁺ ⊤ f): List.Chain' r (inf_trans_lists f hf 0) := by
  obtain ⟨-, hchain⟩ := trans_chain'.spec (hf.inf_step 0)
  rw [inf_trans_lists, List.Chain'.eq_def]
  split <;> simp_all

/--
The last element of the `n`th reduct list forms a chain with the `n + 1`th
reduct list.
-/
private lemma hchain1 (f: ℕ → α) (hf: reduction_seq r⁺ ⊤ f):
    ∀n, List.Chain r ((inf_trans_lists f hf n).getLast (inf_trans_lists.nonempty' n)) (inf_trans_lists f hf (n + 1)) := by
  intro n
  simp [inf_trans_lists]
  obtain ⟨hlast₁, -⟩ := trans_chain'.spec (hf.inf_step n)
  obtain ⟨-, hchain₂⟩:= trans_chain'.spec (hf.inf_step (n + 1))
  convert hchain₂
  rw [<-Option.some_inj, <-hlast₁, List.getLast?_eq_getLast]


/--
We form our expanded sequence by starting with `f 0`, and then continuing with
all reducts of `f 0` in the infinite transitive sequence, as generated by `aux`.
-/
private def seq (f: ℕ → α) (hf: reduction_seq r⁺ ⊤ f): ℕ → α
| 0 => f 0
| n + 1 => aux (inf_trans_lists f hf) inf_trans_lists.nonempty 0 n

/-- `seq` contains all elements of the infinite transitive sequence. -/
private lemma seq_contains_elems (f: ℕ → α) (hf: reduction_seq r⁺ ⊤ f):
    ∀n, ∃m, f n = seq f hf m := by
  intro n
  cases n with
  | zero => use 0; simp [seq]
  | succ n =>
    simp [seq]
    obtain ⟨n', hn'⟩ := aux_elem f hf (n + 1) (by omega)
    use n' + 1

/-- `seq f hf` forms an infinite r-reduction sequence. -/
private lemma seq_inf_reduction_seq (f: ℕ → α) (hf: reduction_seq r⁺ ⊤ f):
    reduction_seq r ⊤ (seq f hf) := by
  intro n
  cases n with
  | zero =>
    simp [seq]
    have h: 0 < (inf_trans_lists f hf 0).length := by
      exact Nat.succ_le.mp (inf_trans_lists.nonempty 0)
    rw [aux, dif_pos h]
    obtain ⟨-, hchain⟩ := trans_chain'.spec (hf.inf_step 0)
    rw [List.chain_iff_get] at hchain
    exact hchain.1 h
  | succ n =>
    simp [↓ENat.coe_lt_top]
    have :=
      (aux_inf_reduction_seq (inf_trans_lists f hf)
       inf_trans_lists.nonempty (hchain0 f hf) (hchain1 f hf) 0 n)
    simpa [seq]


/--
Any infinite r⁺-reduction sequence has a corresponding infinite r-reduction
sequence, which contains all of the elements of the transitive sequence and
starts with the same element.
-/
lemma inf_reduction_seq.exists_regular_of_trans (f: ℕ → α) (hf: reduction_seq r⁺ ⊤ f):
    ∃f', reduction_seq r ⊤ f' ∧
         (∀n, ∃m, f n = f' m) ∧
         f 0 = f' 0 := by
  use (seq f hf)
  and_intros
  · exact seq_inf_reduction_seq f hf
  · exact seq_contains_elems f hf
  · simp [seq]

end aux

end flatten_trans_seq

noncomputable section flatten_refl_trans_seq

/-
Building an `inf_reduction_seq.exists_regular_of_rt`
for r∗-reduction sequences is more complicated. If the
reflexive-transitive seq has a point beyond which all steps are reflexive,
the 'flattened' version would be finite, so the length of the resulting
reduction sequence is not fixed (we will use the general `reduction_seq`).

To avoid duplicating all the work done before, we use the following process to
produce an r-reduction sequence `f'` from an infinite r∗-reduction sequence `f`.
- If `f` is equivalent to a finite r∗-reduction sequence `g`, we flatten
  this finite r∗-reduction sequence using `ReductionSeq.flatten`.
- If `f` is _not_ equivalent to a finite r∗-reduction sequence, there must
  be an infinite amount of non-reflexive steps. We can therefore translate
  `f` into an infinite r⁺-reduction sequence, which we can process as above
  to produce an infinite r-reduction sequence.
-/

/--
If `guaranteed_step_weak` holds for some infinite reduction sequence, there is
always a next non-reflexive step. This guarantees that an infinite r∗-reduction
sequence can be expanded to an infinite r⁺-reduction sequence.
-/
private def guaranteed_step_weak (f: ℕ → α) := ∀n, ∃m ≥ n, f m ≠ f (m + 1)

/--
`guaranteed_step_weak` is weak in the sense that it doesn't say anything about
which `m ≥ n` exists. There must be a first `m`, and, this first `m` has the
stronger properties expressed here: all elements between `n` and `m` must
be equal.
-/
private def guaranteed_step (f: ℕ → α) := ∀n, ∃m ≥ n, f m ≠ f (m + 1) ∧ (∀m' ∈ Set.Ioc n m, f n = f m')

/-- The existence of some next step implies the existence of a first next step. -/
private lemma guaranteed_step_weak_imp_guaranteed_step (f: ℕ → α) (hgsw: guaranteed_step_weak f):
    guaranteed_step f := by
  intro n
  use (Nat.find (hgsw n))
  have ⟨hgt, hne⟩ := Nat.find_spec (hgsw n)
  use hgt, hne
  intro m' hm'
  simp at hm'
  suffices h: ∀k ≤ (m' - n), f n = f (n + k) by
    · have := h (m' - n)
      simp at this; convert this
      omega
  intro k hk
  induction k with
  | zero => rfl
  | succ k ih =>
    have: f n = f (n + k) := ih ?_
    have: f (n + k) = f (n + k + 1) := hm'.2 (n + k) ?_ ?_
    all_goals try omega
    cc

section refl_trans_seq_has_guaranteed_step

variable (f: ℕ → α) (hf: reduction_seq r∗ ⊤ f) (hgs: guaranteed_step f)

/--
From some index `n` we step to a next index `choose (hgs n) + 1`, which is the
end of a transitive step.
-/
private def trans_idx_step (n: ℕ): ℕ :=
  choose (hgs n) + 1

/--
By iterating `trans_idx_step`, we can generate a sequence of indices into `f`
which represent all transitive steps in `f`.
-/
private def trans_idxs (n: ℕ): ℕ :=
  (trans_idx_step f hgs)^[n] 0

/--
We form the sequence by getting the element at each index given by `trans_idxs`
-/
private def trans_seq (n: ℕ): α :=
  f (trans_idxs f hgs n)

/-- Taking a step from index `k` yields an index greater than `k`. -/
private lemma trans_idx_step_inc (k: ℕ): k < trans_idx_step f hgs k := by
  simp only [trans_idx_step]
  linarith [choose_spec (hgs k)]

/-- Doing an extra iteration of `trans_idx_step` yields a larger index. -/
private lemma trans_idxs_inc (k: ℕ): trans_idxs f hgs k < trans_idxs f hgs (k + 1) := by
  simp only [trans_idxs, Function.iterate_succ', Function.comp, trans_idx_step_inc]

/-- For all n, there is an element of `trans_idxs` that is larger than n. -/
private lemma trans_idxs_tends_to_infty (n: ℕ): ∃k, n < trans_idxs f hgs k := by
  induction n with
  | zero =>
    use 1; simp [trans_idxs]
    exact trans_idx_step_inc f hgs 0
  | succ n ih =>
    obtain ⟨k, hk⟩ := ih
    use (k + 1)
    simp [trans_idxs_inc f hgs k, Nat.lt_of_le_of_lt hk]

/--
If `n` is inbetween `trans_idxs f hgs k` and `trans_idxs f hgs (k + 1)`,
then `f n` must be equal to `f (trans_idxs f hgs k)`. Hence `f n` is an
element of `trans_seq f hgs`.
-/
private lemma trans_idxs_inbetween (k: ℕ):
    ∀n ∈ Set.Ico (trans_idxs f hgs k) (trans_idxs f hgs (k + 1)), f (trans_idxs f hgs k) = f n := by
  set m₁ := trans_idxs f hgs k with m₁_def
  set m₂ := trans_idxs f hgs (k + 1) with m₂_def

  rintro n ⟨hn₁, hn₂⟩
  simp only [trans_idxs, Function.iterate_succ', Function.comp, trans_idx_step] at m₂_def
  cases hn₁.lt_or_eq
  case inr h => rw [h]
  obtain ⟨-, -, heq⟩ := choose_spec (hgs m₁)
  apply heq
  rw [Set.mem_Ioc]
  omega

/--
All `n` are sandwiched by two subsequent elements in `trans_idxs f hgs`.
Combining this lemma with `trans_idxs_inbetween` above yields the proof
that `trans_seq f hgs` contains all elements of `f`.
-/
private lemma trans_idxs_sandwich: ∀n, ∃k, n ∈ Set.Ico (trans_idxs f hgs k) (trans_idxs f hgs (k + 1)) := by
  intro n
  simp

  -- there is some `k` s.t. `trans_idxs f hgs k` is greater than n
  have hkgt := trans_idxs_tends_to_infty f hgs n

  -- take the least k that satisfies the requirement
  have hk' := Nat.find_spec hkgt
  set k' := Nat.find hkgt with k'_def

  -- this k' cannot be zero, because trans_idxs f hgs 0 = 0.
  cases h: k'
  case zero =>
    simp [h, trans_idxs] at hk'
  case succ k =>
    -- the element in `trans_idxs f hgs` before `k'`,
    -- `k`, must be at most `n`.
    use k
    constructor; swap
    · rwa [h] at hk'
    by_contra! hlt
    have: k + 1 ≤ k := by
      rw [<-h, k'_def]
      exact Nat.find_min' hkgt hlt
    omega

include hf in
/-- `trans_seq f hgs` is an infinite r⁺-reduction sequence. -/
private lemma trans_seq_inf_reduction_seq: reduction_seq r⁺ ⊤ (trans_seq f hgs) := by
  intro n
  simp only [Function.iterate_succ_apply', trans_seq, trans_idxs, trans_idx_step]
  set f' := (trans_idx_step f hgs)

  obtain ⟨hc₁, hc₂, hc₃⟩ := choose_spec (hgs (f'^[n] 0))
  set c := choose (hgs (f'^[n] 0))

  have: f (f'^[n] 0) = f c := by
    by_cases heq: (f'^[n] 0 = c)
    · rw [heq]
    · apply hc₃ c
      simp [Nat.lt_of_le_of_ne hc₁ heq]

  rw [this]
  have := reflTransGen_iff_eq_or_transGen.mp <| hf.inf_step c
  tauto


/-- `trans_seq f hgs` contains all elements of `f`. -/
private lemma trans_seq_contains_elems (n): ∃m, (trans_seq f hgs m) = f n := by
  obtain ⟨k, hk⟩ := trans_idxs_sandwich f hgs n
  use k, trans_idxs_inbetween _ _ _ _ hk


include hf in
/--
If `f` satisfies the step guarantee, there must be an infinite r-reduction
sequence which contains all elements of `f` and starts with `f 0`.

This lemma first translates `f` to an infinite r⁺-reduction sequence, and
then uses the techniques for transitive reduction sequences developed above.
-/
private lemma gs_imp_exists_inf_regular_seq (hgsw: guaranteed_step_weak f):
    ∃f', reduction_seq r ⊤ f' ∧
         (∀n, ∃m, f n = f' m) ∧
         f 0 = f' 0 := by
  have hgs: guaranteed_step f := guaranteed_step_weak_imp_guaranteed_step f hgsw
  let f' := trans_seq f hgs
  let hf' := trans_seq_inf_reduction_seq f hf hgs

  use (seq f' hf')
  and_intros
  · apply seq_inf_reduction_seq f' hf'
  · have h₁ := seq_contains_elems f' hf'
    have h₂ := trans_seq_contains_elems f hgs
    intro n
    obtain ⟨m₁, hm₁⟩ := h₂ n
    obtain ⟨m₂, hm₂⟩ := h₁ m₁
    use m₂
    simp_all +zetaDelta only
  · unfold f'
    simp [seq, trans_seq, trans_idxs]


end refl_trans_seq_has_guaranteed_step

/--
If the infinite r∗-reduction sequence has no guaranteed step, there must be
some finite r∗-reduction sequence which contains all of the elements of the
infinite r∗-reduction sequence, and starts with the same element.
-/
private lemma no_gs_imp_finite (f: ℕ → α) (hf: reduction_seq r∗ ⊤ f) (hngsw: ¬guaranteed_step_weak f):
    ∃N: ℕ, ∃f', reduction_seq r∗ N f' ∧ (∀n, ∃m ≤ N, f' m = f n) ∧ f' 0 = f 0 := by
  simp [guaranteed_step_weak] at hngsw
  obtain ⟨N, hN⟩ := hngsw
  use N, f

  have: ∀m ≥ N, ∀k, f m = f (m + k) := by
    intro m hm k
    induction k with
    | zero => rfl
    | succ k ih =>
      rw [ih, <-add_assoc, hN (m + k) ?_]
      omega

  and_intros <;> try simp [reduction_seq, hf]
  · intro n
    by_cases hle: n ≤ N
    · use n
    · use N
      simp at hle ⊢
      obtain ⟨k, hk⟩: ∃k, n = N + k := by
        apply Nat.exists_eq_add_of_le
        linarith
      simp [hk, this N _ k]


/--
We can flatten a finite r∗-reduction sequence, by round-tripping through
the inductive `ReductionSeq` definition.
-/
private lemma finite_seq_flatten (N: ℕ) (f: ℕ → α) (hrs: reduction_seq r∗ N f):
    ∃N': ℕ, ∃f', reduction_seq r N' f' ∧ f' 0 = f 0 ∧ ∀n ≤ N, ∃m ≤ N', f' m = f n := by

  obtain ⟨ss, hseq, hmem⟩ := ReductionSeq.of_reduction_seq N f hrs
  obtain ⟨ss', hseq', hmem'⟩ := hseq.flatten

  obtain ⟨N', f', hrs', hmem₁, hmem₂⟩ := hseq'.to_reduction_seq

  use N', f', hrs', hmem₂
  intro n hn

  apply hmem₁ (f n) <| hmem' (f n) <| hmem n hn


/--
A statement that is "obvious" when written down in a pen-and-paper proof, but which
is non-trivial to formalize:

If we have an infinite r∗-reduction sequence
`a₀ ->* a₁ ->* a₂ ...`
there must be some (finite or infinite) reduction sequence
`a₀ -> ... -> a₁ -> ... -> a₂ -> ...`
-/
lemma rt_seq_imp_regular_seq (f: ℕ → α) (hf: reduction_seq r∗ ⊤ f):
    ∃N f', reduction_seq r N f' ∧ (∀n, ∃(m: ℕ) (_: m ≤ N), f n = f' m) ∧ f 0 = f' 0 := by
  by_cases hgsw: guaranteed_step_weak f
  · obtain ⟨g, hg₁, hg₂, hg₃⟩ := gs_imp_exists_inf_regular_seq f hf hgsw
    use ⊤, g
    and_intros
    · exact hg₁
    · simp [hg₂]
    · exact hg₃
  · have := no_gs_imp_finite f hf hgsw
    obtain ⟨N, f', hseq, heq, heq₀⟩ := this
    obtain ⟨N', f'', hrs, heq'₀, heq'⟩ := finite_seq_flatten N f' hseq
    use N', f'', hrs
    constructor
    · intro n
      obtain ⟨m, hm₁, hm₂⟩ := heq n
      obtain ⟨m', hm'₁, hm'₂⟩ := heq' m hm₁
      norm_cast
      use m', hm'₁
      cc
    · cc

end flatten_refl_trans_seq

end inf_reduction_seq
end Thesis.InfReductionSeq
