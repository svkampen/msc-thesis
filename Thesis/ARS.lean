import Mathlib.Logic.Relation
import Mathlib.Tactic
import Thesis.RelProps

namespace Thesis

open Relation

section ars_def

/--
An Abstract Rewriting System (ARS), consisting of a set `α`, index type `I`
and an indexed set of rewrite relations on `α` over `I` (`ARS.rel`).
-/
structure ARS (α I : Type*) where
  rel : I → α → α → Prop

variable {α I}
variable (A : ARS α I)

/-- The union of the indexed relations of an ARS. -/
abbrev ARS.union_rel: α → α → Prop :=
  fun x y ↦ ∃i, A.rel i x y

/-- The reflexive-transitive closure of an ARS relation. -/
abbrev ARS.rel_star: I → α → α → Prop :=
  fun i ↦ ReflTransGen (A.rel i)

/-- The reflexive-transitive closure of the union of ARS relations. -/
abbrev ARS.union_rel_star: α → α → Prop :=
  ReflTransGen A.union_rel

/--
The convertability relation ≡ generated from the union of ARS relations.
Note that this is denoted using `=` in TeReSe, which we use for true equality.
-/
def ARS.conv: α → α → Prop :=
  EqvGen A.union_rel

/-- `x ⇒ y` means x one-step reduces to y. -/
local infixr:60 (priority := high) " ⇒ " => A.union_rel

/-- `x ⇒∗ y` means x reduces to y reflexive-transitively. -/
local infixr:60 (priority := high) " ⇒∗ " => A.union_rel_star

-- I don't love this notation, but oh well..
local notation:50 (priority := high) x:51 " ⇒[" i "]" y:50 => A.rel i x y
local notation:50 (priority := high) x:51 " ⇒∗[" i "]" y:50 => A.rel_star i x y

/--
`A: ARS α I` is a sub-ARS of `B: ARS β J` if:
- α is a subtype of β (i.e. α ~ Subtype β p for some p)
- for all a, b in α, a reduces to b in B iff a reduces to b in A
- if a is in α (i.e. `p a` holds) and a reduces to b in B, b is in α (i.e. `p b` holds).
-/
def ARS.is_sub_ars_of {p: β → Prop} {J} (A: ARS {b : β // p b} I) (B: ARS β J) :=
  (∀a b, A.union_rel a b ↔ B.union_rel a b) ∧
  (∀a b, p a ∧ B.union_rel a b → p b)

/-- A sub-ARS formed from A using p. -/
structure SubARS (A: ARS α I) (p: α → Prop) (J) where
  ars : ARS {a: α // p a} J
  is_sub : ars.is_sub_ars_of A

def SubARS.prop (_: SubARS A p J) := p

/-- The sub-ARS generated by a subtype of β (represented by p) -/
def ARS.gen_sub (B: ARS β I) (p: β → Prop) : SubARS B (fun b ↦ ∃a, p a ∧ B.union_rel_star a b) Unit :=
  { ars := ⟨fun _ a b ↦ B.union_rel a b⟩,
    is_sub := by
      constructor; simp
      rintro b c ⟨⟨a, ⟨hpa, hab⟩⟩, h₂⟩
      use a, hpa, ReflTransGen.tail hab h₂ }

def ARS.reduction_graph (B: ARS β I) (b: β) : SubARS B (fun b' ↦ B.union_rel_star b b') Unit := by
  have := ARS.gen_sub B (fun b' ↦ (b' = b))
  simpa [exists_eq_left]

example (B: ARS β I) (b: β) : (ARS {b': β // B.union_rel_star b b'} Unit) = ARS {b' : β // ∃a, (a = b) ∧ B.union_rel_star a b' } Unit := by
  simp [exists_eq_left]

section cofinality

variable (r: α → α → Prop)

/--
A subtype `{a // p a}` is cofinal in r if every element `a: α` reduces to
some b in the subtype.
-/
def cofinal (p: α → Prop) := ∀a, ∃b, p b ∧ r∗ a b

section cp

variable (a: α)

def rg := A.reduction_graph a

/--
An infinite reduction sequence (described by f) is cofinal in r if the set
of all elements in the sequence is cofinal in r.
-/
def inf_cofinal_reduction {f: ℕ → α} := cofinal r (f '' Set.univ)



end cp

end cofinality

end ars_def

end Thesis
