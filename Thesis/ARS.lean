import Mathlib.Logic.Relation
import Mathlib.Tactic
import Thesis.RelProps

namespace Thesis

open Relation

section ars_def

/--
An Abstract Rewriting System (ARS), consisting of a set `α`, index type `I`
and an indexed set of rewrite relations on `α` over `I` (`ARS.rel`).
-/
structure ARS (α I : Type*) where
  rel : I → Rel α α

variable {α I}
variable (A : ARS α I)

/-- The union of the indexed relations of an ARS. -/
abbrev ARS.union_rel: Rel α α :=
  fun x y ↦ ∃i, A.rel i x y

/--
The convertability relation ≡ generated from the union of ARS relations.
Note that this is denoted using `=` in TeReSe, which we use for true equality.
-/
def ARS.conv: α → α → Prop :=
  EqvGen A.union_rel

/-- `x ⇒ y` means x one-step reduces to y. -/
local infixr:60 (priority := high) " ⇒ " => A.union_rel

/-- `x ⇒∗ y` means x reduces to y reflexive-transitively. -/
local infixr:60 (priority := high) " ⇒∗ " => A.union_rel∗

-- I don't love this notation, but oh well..
local notation:50 (priority := high) x:51 " ⇒[" i "]" y:50 => A.rel i x y
local notation:50 (priority := high) x:51 " ⇒∗[" i "]" y:50 => (A.rel i)∗ x y

/--
`A: ARS α I` is a sub-ARS of `B: ARS β J` if:
- α is a subtype of β (i.e. α ~ Subtype β p for some p)
- for all a, b in α, a reduces to b in B iff a reduces to b in A
- if a is in α (i.e. `p a` holds) and a reduces to b in B, b is in α (i.e. `p b` holds).
-/
def ARS.is_sub_ars_of {p: β → Prop} {J} (A: ARS {b : β // p b} I) (B: ARS β J) :=
  (∀a b, A.union_rel a b ↔ B.union_rel a b) ∧
  (∀a b, p a ∧ B.union_rel a b → p b)

/-- A sub-ARS formed from A using p. -/
structure SubARS (A: ARS α I) (p: α → Prop) (J) where
  ars : ARS {a: α // p a} J
  is_sub : ars.is_sub_ars_of A

def SubARS.prop (_: SubARS A p J) := p

/-- The sub-ARS generated by a subtype of β (represented by p) -/
def ARS.gen_sub (B: ARS β I) (p: β → Prop) : SubARS B (fun b ↦ ∃a, p a ∧ B.union_rel∗ a b) Unit :=
  { ars := ⟨fun _ a b ↦ B.union_rel a b⟩,
    is_sub := by
      constructor; simp
      rintro b c ⟨⟨a, ⟨hpa, hab⟩⟩, h₂⟩
      use a, hpa, ReflTransGen.tail hab h₂ }

def ARS.reduction_graph (B: ARS β I) (b: β) : SubARS B (fun b' ↦ B.union_rel∗ b b') Unit := by
  have := ARS.gen_sub B (fun b' ↦ (b' = b))
  simpa [exists_eq_left]

example (B: ARS β I) (b: β) : (ARS {b': β // B.union_rel∗ b b'} Unit) = ARS {b' : β // ∃a, (a = b) ∧ B.union_rel∗ a b' } Unit := by
  simp [exists_eq_left]

lemma SubARS.star_prop₁ (S: SubARS A p J): (∀a b, S.ars.union_rel∗ a b ↔ A.union_rel∗ a b) := by
  intro a b
  constructor <;> intro h'
  · induction h' with
    | refl => exact ReflTransGen.refl
    | tail h₁ h₂ ih =>
      apply ReflTransGen.tail ih
      rwa [<-S.is_sub.left]
  · rcases a with ⟨a', ha'⟩
    rcases b with ⟨b', hb'⟩
    simp [Subtype.mk] at h'
    induction h' using ReflTransGen.head_induction_on with
    | refl => exact ReflTransGen.refl
    | head h₁ _h₂ ih =>
      rename_i b c
      have hc : p c := S.is_sub.right b c ⟨ha', h₁⟩
      apply ReflTransGen.head _ (ih hc)
      simp [S.is_sub.left]
      exact h₁

lemma SubARS.star_prop₂ (S: SubARS A p J): (∀a b, p a ∧ A.union_rel∗ a b → p b) := by
  rintro a b ⟨hpa, hab⟩
  induction hab with
  | refl => exact hpa
  | tail h₁ h₂ ih =>
      rename_i b c
      have := S.is_sub.right b c
      tauto

lemma SubARS.down_confluent (S: SubARS A p J): confluent (A.union_rel) → confluent (S.ars.union_rel) := by
  intro hc a b c hhyp
  have hhyp' : A.union_rel∗ a b ∧ A.union_rel∗ a c := by
    constructor <;> (rw [<-S.star_prop₁ _ a _]; simp only [hhyp])
  have ⟨d, hd⟩ := hc _ _ _ hhyp'
  have hpd : p d := S.star_prop₂ _ b _ ⟨b.property, hd.left⟩
  use ⟨d, hpd⟩
  constructor <;> (simp [S.star_prop₁ _ _ ⟨d, hpd⟩]; simp [hd])

lemma SubARS.down_sn (S: SubARS A p J): strongly_normalizing (A.union_rel) -> strongly_normalizing (S.ars.union_rel) := by
  unfold strongly_normalizing
  intro hsn
  contrapose! hsn
  obtain ⟨f, hf⟩ := hsn
  use (λn => f n)
  intro n
  apply (S.is_sub.left _ _).mp
  exact hf n

-- etc, sub-ARS also preserves WCR, subcommutative, DP, WN, WF, UN, NF, Ind, Inc, FB, CP
-- prove them as needed

end ars_def

end Thesis
