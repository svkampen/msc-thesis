import Mathlib.Logic.Relation
import Mathlib.Tactic
import Thesis.RelProps

namespace Thesis

open Relation

section ars_def

/--
An Abstract Rewriting System (ARS), consisting of a set `α`, index type `I`
and an indexed set of rewrite relations on `α` over `I` (`ARS.rel`).
-/
@[ext]
structure ARS (α I : Type*) where
  rel : I → Rel α α

variable {α I}
variable (A : ARS α I)

/-- The union of the indexed relations of an ARS. -/
abbrev ARS.union_rel: Rel α α :=
  fun x y ↦ ∃i, A.rel i x y

/-- The union of reduction relations with an index smaller than i. -/
@[simp]
abbrev ARS.union_lt [PartialOrder I] (A: ARS α I): I → Rel α α :=
  fun i x y ↦ ∃j, j < i ∧ A.rel j x y

lemma ARS.union_lt_max [LinearOrder I] (A: ARS α I) (a b: α):
    A.union_lt i a b → A.union_lt (max i j) a b := by
  intro h
  cases (max_cases i j) with
  | inl heq => rwa [heq.1]
  | inr heq =>
    rw [heq.1]
    obtain ⟨k, hk⟩ := h
    use k, ?_, hk.2
    trans i <;> aesop

lemma ARS.union_lt_trans [LinearOrder I] (A: ARS α I) (a b: α) {i j} (hij: i ≤ j):
    A.union_lt i a b → A.union_lt j a b := by
  rintro ⟨k, hklt, hkrel⟩
  use k, ?_, hkrel
  apply lt_of_lt_of_le hklt hij



/--
The convertability relation ≡ generated from the union of ARS relations.
Note that this is denoted using `=` in TeReSe, which we use for true equality.
-/
abbrev ARS.conv: Rel α α :=
  EqvGen A.union_rel

/-- `x ⇒ y` means x one-step reduces to y. -/
local infixr:60 (priority := high) " ⇒ " => A.union_rel

/-- `x ⇒∗ y` means x reduces to y reflexive-transitively. -/
local infixr:60 (priority := high) " ⇒∗ " => A.union_rel∗

-- I don't love this notation, but oh well..
local notation:50 (priority := high) x:51 " ⇒[" i "]" y:50 => A.rel i x y
local notation:50 (priority := high) x:51 " ⇒∗[" i "]" y:50 => (A.rel i)∗ x y

/--
`S: ARS {b: β // p b} I` is a sub-ARS of `B: ARS β I` if:
- `S.rel i` is the _restriction_ of `B.rel i` to `{b // p b}`, that is
  `a` reduces to `b` in `S.rel i` iff `a` reduces to `b` in `B.rel i`.
- `S` is _closed_ under `B.rel i`; if `a` reduces to `b` in `B.rel i`
  and `a` is in `S`, `b` must be in `S`.
-/
@[ext]
structure SubARS (B: ARS β I) where
  p: β → Prop
  ars: ARS {b: β // p b} I
  restrict: ∀i a b, ars.rel i a b ↔ B.rel i a b
  closed: ∀i a b, p a ∧ B.rel i a b → p b

@[simp]
abbrev SubARS.Subtype {A: ARS β I} (S: SubARS A) := {b // S.p b}

lemma SubARS.restrict_union {A: ARS α I} (S: SubARS A): (∀a b, S.ars.union_rel a b ↔ A.union_rel a b) := by
  intro a b
  constructor
  all_goals (
    intro h'
    obtain ⟨i, hi⟩ := h'
    use i
    rw [S.restrict] at *
    assumption)

lemma SubARS.closed_union {A: ARS α I} (S: SubARS A): ∀a b, S.p a ∧ A.union_rel a b → S.p b := by
  rintro a b ⟨h₁, h₂⟩
  obtain ⟨i, hi⟩ := h₂
  apply S.closed
  tauto


lemma SubARS.restrict_union_lt {A: ARS α I} [PartialOrder I] (S: SubARS A):
    (∀i a b, S.ars.union_lt i a b ↔ A.union_lt i a b) := by
  intro i a b
  simp [ARS.union_lt]
  constructor
  all_goals (
    intro h'
    obtain ⟨j, hj⟩ := h'
    use j, hj.left
    rw [S.restrict] at *
    tauto)

lemma SubARS.closed_union_lt {A: ARS α I} [PartialOrder I] (S: SubARS A):
    ∀i a b, S.p a ∧ A.union_lt i a b → S.p b := by
  rintro i a b ⟨h₁, h₂⟩
  obtain ⟨i, hi⟩ := h₂
  apply S.closed
  tauto


/-- The sub-ARS generated by a subtype of β (represented by p) -/
def ARS.gen_sub (B: ARS β I) (p: β → Prop) : SubARS B :=
  { p := (fun b ↦ ∃a, p a ∧ B.union_rel∗ a b)
    ars := ⟨fun i a b ↦ B.rel i a b⟩,
    restrict := by simp,
    closed := by
      rintro i a b ⟨⟨a', ha'⟩, h₂⟩
      use a', ha'.left
      apply ReflTransGen.tail ha'.right (Exists.intro i h₂)
  }

def ARS.reduction_graph (B: ARS β I) (b: β) : SubARS B := by
  have := ARS.gen_sub B (fun b' ↦ (b' = b))
  simpa [exists_eq_left]

@[simp]
lemma ARS.reduction_graph_p: (A.reduction_graph a).p = (A.union_rel∗ a ·) := by
  simp [ARS.reduction_graph, ARS.gen_sub]

/--
The component of `a ∈ α` w.r.t. conversion is the sub-ARS `component a`
with set of elements { a' | a ≡ a' } and the reduction relation restricted
to this convertability class.
-/
def ARS.component (a: α): SubARS A where
  p := (A.conv a ·)
  ars := ⟨fun i a b ↦ A.rel i a b⟩ -- reduction relation is the same as A, modulo types
  restrict := by simp
  closed := by
    rintro i x y ⟨hconv, hstep⟩
    apply EqvGen.trans _ _ _ hconv
    apply EqvGen.rel _ _ (Exists.intro i hstep)

def ARS.components: Set (SubARS A) :=
  A.component '' Set.univ

lemma component_unique (c₁ c₂: SubARS A) (hc₁: c₁ ∈ A.components) (hc₂: c₂ ∈ A.components) (a: α):
    (c₁.p a ∧ c₂.p a) → c₁ = c₂ := by
  rintro ⟨ha₁, ha₂⟩
  obtain ⟨x, _, rfl⟩ := hc₁
  obtain ⟨y, _, rfl⟩ := hc₂
  have prop_eq: (A.component x).p = (A.component y).p := by
    ext b
    simp [ARS.component, ARS.conv] at ha₁ ha₂ ⊢
    constructor <;>
    · intro hb
      apply EqvGen.trans _ _ _ (by assumption)
      apply EqvGen.trans _ _ _ _ hb
      exact EqvGen.symm _ _ (by assumption)
  ext
  · simp only [prop_eq]
  · simp only [ARS.component]
    -- the mathematical argument here is simple; because the subtypes
    -- contain the same elements, the types are the same, and the rewrite
    -- relations are just inherited from the parent ARS A, so both SubARS'es
    -- are equivalent. Lean can't easily figure this out, but applications of
    -- the congr(!) tactic, which uses congruence lemma's, can sometimes help[1]
    -- [1]: https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/How.20to.20prove.20HEq.20between.20dependent.20functions.3F/near/430604617
    congr! 2 -- for some reason, this needs to be split up into 2/4.
    congr! 4 -- don't ask me why. the order of applications matters, I guess.

@[simp]
lemma ARS.component_p: (A.component a).p = (A.conv a ·) := by
  simp [ARS.component]

private lemma restrict_aux {p: α → Prop}
    {s: α → α → Prop} {r: {b // p b} → {b // p b} → Prop}
    (hrestrict: ∀a b, r a b ↔ s a b) (hclosure: ∀a b, p a ∧ s a b → p b):
    ∀a b, r∗ a b ↔ s∗ a b := by
  intro a b
  constructor <;> intro h'
  · induction h' with
    | refl => exact ReflTransGen.refl
    | tail h₁ h₂ ih =>
      exact ReflTransGen.tail ih <| (hrestrict _ _).mp h₂
  · rcases a with ⟨a', ha'⟩
    simp [Subtype.mk] at h'
    induction h' using ReflTransGen.head_induction_on with
    | refl => exact ReflTransGen.refl
    | head h₁ _h₂ ih =>
      rename_i b c
      have hc : p c := hclosure b c (by tauto)
      apply ReflTransGen.head _ (ih hc)
      simp [hrestrict]
      exact h₁


/--
The restriction property of a sub-ARS extends to the reflexive-transitive closure
of its reduction relations.
-/
lemma SubARS.star_restrict {A: ARS α I} (S: SubARS A):
    (∀i a b, (S.ars.rel i)∗ a b ↔ (A.rel i)∗ a b) :=
  fun i ↦ restrict_aux (S.restrict i) (S.closed i)

/--
The restriction property of a sub-ARS extends to the reflexive-transitive closure
of the union of its reduction relations.
-/
lemma SubARS.star_restrict_union {A: ARS α I} (S: SubARS A):
    (∀a b, S.ars.union_rel∗ a b ↔ A.union_rel∗ a b) :=
  restrict_aux S.restrict_union S.closed_union


@[simp]
lemma SubARS.star_restrict_union_lt {A: ARS α I} [PartialOrder I] (S: SubARS A):
    (∀i a b, (S.ars.union_lt i)∗ a b ↔ (A.union_lt i)∗ a b) :=
  fun i ↦ restrict_aux (S.restrict_union_lt i) (S.closed_union_lt i)


private lemma closure_aux {p: α → Prop} {r: α → α → Prop} (hclosure: ∀a b, p a ∧ r a b → p b):
    ∀a b, p a ∧ r∗ a b → p b := by
  introv h
  rcases h with ⟨hpa, hab⟩
  induction hab with
  | refl => exact hpa
  | tail h₁ h₂ ih =>
      rename_i b c
      have := hclosure b c
      tauto

/--
The closure property of a sub-ARS extends to the reflexive-transitive closure
of its reduction relations.
-/
lemma SubARS.star_closed {A: ARS α I} (S: SubARS A): (∀i a b, S.p a ∧ (A.rel i)∗ a b → S.p b) :=
  fun i ↦ closure_aux (S.closed i)

/--
The closure property of a sub-ARS extends to the reflexive-transitive closure
of the union of its reduction relations.
-/
lemma SubARS.star_closed_union {A: ARS α I} (S: SubARS A): (∀a b, S.p a ∧ (A.union_rel∗ a b) → S.p b) :=
  closure_aux (S.closed_union)

lemma SubARS.star_closed_union_lt {A: ARS α I} [PartialOrder I] (S: SubARS A):
    (∀i a b, S.p a ∧ (A.union_lt i)∗ a b → S.p b) :=
  fun i ↦ closure_aux <| S.closed_union_lt i


private lemma down_confluent_aux {p: α → Prop}
    {s: α → α → Prop} {r: {b // p b} → {b // p b} → Prop}
    (hrestrict: ∀a b, r∗ a b ↔ s∗ a b) (hclosure: ∀a b, p a ∧ s∗ a b → p b):
    confluent s → confluent r := by
  rintro hc a b c ⟨rab, rac⟩

  have ⟨sab, sac⟩: s∗ a b ∧ s∗ a c := by
    constructor <;> rwa [<-hrestrict a _]

  have ⟨d, hd⟩ := hc _ _ _ ⟨sab, sac⟩
  have hpd: p d := hclosure b _ ⟨b.property, hd.left⟩
  use ⟨d, hpd⟩
  simp [hrestrict _ ⟨d, hpd⟩, hd]

/-- A sub-ARS of a confluent ARS is confluent. -/
lemma SubARS.down_confluent (S: SubARS A): ∀i, confluent (A.rel i) → confluent (S.ars.rel i) :=
  fun i ↦ down_confluent_aux (S.star_restrict i) (S.star_closed i)

lemma SubARS.down_confluent_union (S: SubARS A): confluent A.union_rel → confluent S.ars.union_rel :=
  down_confluent_aux S.star_restrict_union S.star_closed_union


/-- A sub-ARS of a strongly normalizing ARS is strongly normalizing. -/
lemma SubARS.down_sn (S: SubARS A): ∀i, strongly_normalizing (A.rel i) -> strongly_normalizing (S.ars.rel i) := by
  unfold strongly_normalizing
  intro i hsn
  contrapose! hsn
  obtain ⟨f, hf⟩ := hsn
  use (λn => f n)
  intro n
  apply (S.restrict i _ _).mp
  exact hf n

-- etc, sub-ARS also preserves WCR, subcommutative, DP, WN, WF, UN, NF, Ind, Inc, FB, CP
-- prove them as needed

end ars_def

end Thesis
