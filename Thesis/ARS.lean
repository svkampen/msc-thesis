import Mathlib.Logic.Relation
import Mathlib.Tactic
import Thesis.RelProps

namespace Thesis

open Relation

section ars_def

/--
An Abstract Rewriting System (ARS), consisting of a set `α`, index type `I`
and an indexed set of rewrite relations on `α` over `I` (`ARS.rel`).
-/
@[ext]
structure ARS (α I : Type*) where
  rel : I → Rel α α

variable {α I}
variable (A : ARS α I)

/-- The union of the indexed relations of an ARS. -/
abbrev ARS.union_rel: Rel α α :=
  fun x y ↦ ∃i, A.rel i x y

/-- The union of reduction relations with an index smaller than i. -/
@[simp]
abbrev ARS.union_lt [PartialOrder I] (A: ARS α I): I → Rel α α :=
  fun i x y ↦ ∃j, j < i ∧ A.rel j x y

lemma ARS.union_lt_max [LinearOrder I] (A: ARS α I) (a b: α):
    A.union_lt i a b → A.union_lt (max i j) a b := by
  intro h
  cases (max_cases i j) with
  | inl heq => rwa [heq.1]
  | inr heq =>
    rw [heq.1]
    obtain ⟨k, hk⟩ := h
    use k, ?_, hk.2
    trans i <;> aesop

lemma ARS.union_lt_trans [LinearOrder I] (A: ARS α I) (a b: α) {i j} (hij: i ≤ j):
    A.union_lt i a b → A.union_lt j a b := by
  rintro ⟨k, hklt, hkrel⟩
  use k, ?_, hkrel
  apply lt_of_lt_of_le hklt hij



/--
The convertability relation ≡ generated from the union of ARS relations.
Note that this is denoted using `=` in TeReSe, which we use for true equality.
-/
abbrev ARS.conv: Rel α α :=
  EqvGen A.union_rel

/-- `x ⇒ y` means x one-step reduces to y. -/
local infixr:60 (priority := high) " ⇒ " => A.union_rel

/-- `x ⇒∗ y` means x reduces to y reflexive-transitively. -/
local infixr:60 (priority := high) " ⇒∗ " => A.union_rel∗

-- I don't love this notation, but oh well..
local notation:50 (priority := high) x:51 " ⇒[" i "]" y:50 => A.rel i x y
local notation:50 (priority := high) x:51 " ⇒∗[" i "]" y:50 => (A.rel i)∗ x y

/--
`S: ARS {b: β // p b} I` is a sub-ARS of `B: ARS β I` if:
- `S.rel i` is the _restriction_ of `B.rel i` to `{b // p b}`, that is
  `a` reduces to `b` in `S.rel i` iff `a` reduces to `b` in `B.rel i`.
- `S` is _closed_ under `B.rel i`; if `a` reduces to `b` in `B.rel i`
  and `a` is in `S`, `b` must be in `S`.
-/
@[ext]
structure SubARS (B: ARS β I) where
  p: β → Prop
  ars: ARS {b: β // p b} I
  restrict: ∀i a b, ars.rel i a b ↔ B.rel i a b
  closed: ∀i a b, p a ∧ B.rel i a b → p b

@[simp]
abbrev SubARS.Subtype {A: ARS β I} (S: SubARS A) := {b // S.p b}

lemma SubARS.restrict_union {A: ARS α I} (S: SubARS A): (∀a b, S.ars.union_rel a b ↔ A.union_rel a b) := by
  intro a b
  constructor
  all_goals (
    intro h'
    obtain ⟨i, hi⟩ := h'
    use i
    rw [S.restrict] at *
    assumption)

lemma SubARS.closed_union {A: ARS α I} (S: SubARS A): ∀a b, S.p a ∧ A.union_rel a b → S.p b := by
  rintro a b ⟨h₁, h₂⟩
  obtain ⟨i, hi⟩ := h₂
  apply S.closed
  tauto


lemma SubARS.restrict_union_lt {A: ARS α I} [PartialOrder I] (S: SubARS A):
    (∀i a b, S.ars.union_lt i a b ↔ A.union_lt i a b) := by
  intro i a b
  simp [ARS.union_lt]
  constructor
  all_goals (
    intro h'
    obtain ⟨j, hj⟩ := h'
    use j, hj.left
    rw [S.restrict] at *
    tauto)

lemma SubARS.closed_union_lt {A: ARS α I} [PartialOrder I] (S: SubARS A):
    ∀i a b, S.p a ∧ A.union_lt i a b → S.p b := by
  rintro i a b ⟨h₁, h₂⟩
  obtain ⟨i, hi⟩ := h₂
  apply S.closed
  tauto


/-- The sub-ARS generated by a subtype of β (represented by p) -/
def ARS.gen_sub (B: ARS β I) (p: β → Prop) : SubARS B :=
  { p := (fun b ↦ ∃a, p a ∧ B.union_rel∗ a b)
    ars := ⟨fun i a b ↦ B.rel i a b⟩,
    restrict := by simp,
    closed := by
      rintro i a b ⟨⟨a', ha'⟩, h₂⟩
      use a', ha'.left
      apply ReflTransGen.tail ha'.right (Exists.intro i h₂)
  }

def ARS.reduction_graph (B: ARS β I) (b: β) : SubARS B := by
  have := ARS.gen_sub B (fun b' ↦ (b' = b))
  simpa [exists_eq_left]

@[simp]
lemma ARS.reduction_graph_p: (A.reduction_graph a).p = (A.union_rel∗ a ·) := by
  simp [ARS.reduction_graph, ARS.gen_sub]

@[ext]
structure Component extends SubARS A where
  component_restrict: ∀{a b}, p a → p b → A.conv a b
  component_closed: ∀{a b}, p a → A.conv a b → p b
  component_nonempty: ∃a, p a

/--
The component of `a ∈ α` w.r.t. conversion is the sub-ARS `component a`
with set of elements { a' | a ≡ a' } and the reduction relation restricted
to this convertability class.
-/
def ARS.component (a: α): Component A where
  p := (A.conv a ·)
  ars := ⟨fun i a b ↦ A.rel i a b⟩ -- reduction relation is the same as A, modulo types
  restrict := by simp
  closed := by
    rintro i x y ⟨hconv, hstep⟩
    exact EqvGen.trans a x y hconv <| EqvGen.rel x y ⟨i, hstep⟩
  component_restrict := (EqvGen.trans _ _ _ ·.symm)
  component_closed := EqvGen.trans _ _ _
  component_nonempty := ⟨a, by rfl⟩

def ARS.components: Set (Component A) :=
  A.component '' Set.univ

lemma component_unique {A: ARS α I} {c₁ c₂: Component A} (a: α):
    c₁.p a → c₂.p a → c₁ = c₂ := by
  rintro ha₁ ha₂
  have prop_eq: c₁.p = c₂.p := by
    ext b
    constructor
    · exact fun hb ↦ c₂.component_closed ha₂ (c₁.component_restrict ha₁ hb)
    · exact fun hb ↦ c₁.component_closed ha₁ (c₂.component_restrict ha₂ hb)
  ext
  · simp only [prop_eq]
  · congr! 1
    ext
    · exact Eq.to_iff (congrFun prop_eq _)
    · have: ∀i a b, c₁.ars.rel i a b → c₂.ars.rel i ⟨a.val, by rw [<-prop_eq];exact a.prop⟩ ⟨b.val, by rw [<-prop_eq];exact b.prop⟩ := by
        intro i a b
        rw [c₁.restrict, c₂.restrict]
        simp

      have (i: I) (a b): c₁.ars.rel i a b ↔ A.rel i a b := c₁.restrict i a b

      -- this is a fairly magical intermediate proof.
      -- we absolutely need hpq to be subst-able, which requires us to massage c₁ and c₂ into
      -- a shape that makes replacement well-typed. That requires us to pass c₁.ars and c₂.ars
      -- as arbitrary ARSes A and B, which are not dependent on c₁.p and c₂.p, which would inhibit
      -- replacement. We still need the restriction properties that c₁ and c₂ give us, though, so we
      -- need to pass those in separately.
      have {p q: α → Prop} (hpq: p = q) (A: ARS (Subtype p) I) (B: ARS (Subtype q) I) (C: ARS α I)
        (hres₁: ∀i a b, A.rel i a b ↔ C.rel i a b) (hres₂: ∀i a b, B.rel i a b ↔ C.rel i a b): HEq A B := by
        subst hpq
        apply heq_of_eq
        ext i a b
        rw [hres₁, hres₂]

      apply this prop_eq c₁.ars c₂.ars A c₁.restrict c₂.restrict


lemma ARS.component_root_mem {A: ARS α I}: (A.component a).p a := by
  simp [ARS.component]
  rfl

lemma component_mem_eq {A: ARS α I} {x: Component A} (helem: x.p b):
    (A.component b) = x :=
  component_unique b ARS.component_root_mem helem

@[simp]
lemma ARS.component_p: (A.component a).p = (A.conv a ·) := by
  simp [ARS.component]

private lemma restrict_aux {p: α → Prop}
    {s: α → α → Prop} {r: {b // p b} → {b // p b} → Prop}
    (hrestrict: ∀a b, r a b ↔ s a b) (hclosure: ∀a b, p a ∧ s a b → p b):
    ∀a b, r∗ a b ↔ s∗ a b := by
  intro a b
  constructor <;> intro h'
  · induction h' with
    | refl => exact ReflTransGen.refl
    | tail h₁ h₂ ih =>
      exact ReflTransGen.tail ih <| (hrestrict _ _).mp h₂
  · rcases a with ⟨a', ha'⟩
    simp [Subtype.mk] at h'
    induction h' using ReflTransGen.head_induction_on with
    | refl => exact ReflTransGen.refl
    | head h₁ _h₂ ih =>
      rename_i b c
      have hc : p c := hclosure b c (by tauto)
      apply ReflTransGen.head _ (ih hc)
      simp [hrestrict]
      exact h₁


/--
The restriction property of a sub-ARS extends to the reflexive-transitive closure
of its reduction relations.
-/
lemma SubARS.star_restrict {A: ARS α I} (S: SubARS A):
    (∀i a b, (S.ars.rel i)∗ a b ↔ (A.rel i)∗ a b) :=
  fun i ↦ restrict_aux (S.restrict i) (S.closed i)

/--
The restriction property of a sub-ARS extends to the reflexive-transitive closure
of the union of its reduction relations.
-/
lemma SubARS.star_restrict_union {A: ARS α I} (S: SubARS A):
    (∀a b, S.ars.union_rel∗ a b ↔ A.union_rel∗ a b) :=
  restrict_aux S.restrict_union S.closed_union


@[simp]
lemma SubARS.star_restrict_union_lt {A: ARS α I} [PartialOrder I] (S: SubARS A):
    (∀i a b, (S.ars.union_lt i)∗ a b ↔ (A.union_lt i)∗ a b) :=
  fun i ↦ restrict_aux (S.restrict_union_lt i) (S.closed_union_lt i)


private lemma closure_aux {p: α → Prop} {r: α → α → Prop} (hclosure: ∀a b, p a ∧ r a b → p b):
    ∀a b, p a ∧ r∗ a b → p b := by
  introv h
  rcases h with ⟨hpa, hab⟩
  induction hab with
  | refl => exact hpa
  | tail h₁ h₂ ih =>
      rename_i b c
      have := hclosure b c
      tauto

/--
The closure property of a sub-ARS extends to the reflexive-transitive closure
of its reduction relations.
-/
lemma SubARS.star_closed {A: ARS α I} (S: SubARS A): (∀i a b, S.p a ∧ (A.rel i)∗ a b → S.p b) :=
  fun i ↦ closure_aux (S.closed i)

/--
The closure property of a sub-ARS extends to the reflexive-transitive closure
of the union of its reduction relations.
-/
lemma SubARS.star_closed_union {A: ARS α I} (S: SubARS A): (∀a b, S.p a ∧ (A.union_rel∗ a b) → S.p b) :=
  closure_aux (S.closed_union)

lemma SubARS.star_closed_union_lt {A: ARS α I} [PartialOrder I] (S: SubARS A):
    (∀i a b, S.p a ∧ (A.union_lt i)∗ a b → S.p b) :=
  fun i ↦ closure_aux <| S.closed_union_lt i


private lemma down_confluent_aux {p: α → Prop}
    {s: α → α → Prop} {r: {b // p b} → {b // p b} → Prop}
    (hrestrict: ∀a b, r∗ a b ↔ s∗ a b) (hclosure: ∀a b, p a ∧ s∗ a b → p b):
    confluent s → confluent r := by
  rintro hc a b c ⟨rab, rac⟩

  have ⟨sab, sac⟩: s∗ a b ∧ s∗ a c := by
    constructor <;> rwa [<-hrestrict a _]

  have ⟨d, hd⟩ := hc _ _ _ ⟨sab, sac⟩
  have hpd: p d := hclosure b _ ⟨b.property, hd.left⟩
  use ⟨d, hpd⟩
  simp [hrestrict _ ⟨d, hpd⟩, hd]

/-- A sub-ARS of a confluent ARS is confluent. -/
lemma SubARS.down_confluent (S: SubARS A): ∀i, confluent (A.rel i) → confluent (S.ars.rel i) :=
  fun i ↦ down_confluent_aux (S.star_restrict i) (S.star_closed i)

lemma SubARS.down_confluent_union (S: SubARS A): confluent A.union_rel → confluent S.ars.union_rel :=
  down_confluent_aux S.star_restrict_union S.star_closed_union


/-- A sub-ARS of a strongly normalizing ARS is strongly normalizing. -/
lemma SubARS.down_sn (S: SubARS A): ∀i, strongly_normalizing (A.rel i) -> strongly_normalizing (S.ars.rel i) := by
  unfold strongly_normalizing
  intro i hsn
  contrapose! hsn
  obtain ⟨f, hf⟩ := hsn
  use (λn => f n)
  intro n
  apply (S.restrict i _ _).mp
  exact hf n

-- etc, sub-ARS also preserves WCR, subcommutative, DP, WN, WF, UN, NF, Ind, Inc, FB, CP
-- prove them as needed

end ars_def

end Thesis
