import Mathlib.Logic.Relation
import Mathlib.Tactic
import Thesis.BasicProperties

/-!

# Abstract Rewriting Systems
Here, we define the basic structure of an abstract rewriting system.
We also define some derived structures, namely that of a sub-ARS and a component.

-/

namespace Thesis

open Relation

section ars_def

/--
An Abstract Rewriting System (ARS), consisting of a set `α`, index type `I`
and an indexed set of rewrite relations on `α` over `I` (`ARS.rel`).
-/
@[ext]
structure ARS (α I : Type*) where
  /-- The rewrite relations for this ARS. -/
  rel : I → Rel α α

variable {α I}
variable (A : ARS α I)

/-- The union of the indexed relations of an ARS. -/
abbrev ARS.union_rel: Rel α α :=
  fun x y ↦ ∃i, A.rel i x y

/-- The union of reduction relations with an index smaller than i. -/
@[simp]
abbrev ARS.union_lt [PartialOrder I] (A: ARS α I): I → Rel α α :=
  fun i x y ↦ ∃j, j < i ∧ A.rel j x y

/--
If a -> b with an index smaller than i, then certainly a -> b with an index smaller than (max i j).
-/
lemma ARS.union_lt_max [LinearOrder I] (A: ARS α I) (a b: α):
    A.union_lt i a b → A.union_lt (max i j) a b := by
  intro h
  rcases (max_cases i j) with (⟨heq₁, -⟩ | ⟨heq₁, heq₂⟩)
  · rwa [heq₁]
  · rw [heq₁]
    obtain ⟨k, hlt, hrel⟩ := h
    have hlt': k < j := gt_trans heq₂ hlt
    use k, hlt', hrel

/--
If `i ≤ j`, then `A.union_lt i` is a subset of `A.union_lt j`.
-/
lemma ARS.union_lt_trans [LinearOrder I] (A: ARS α I) (a b: α) {i j} (hij: i ≤ j):
    A.union_lt i a b → A.union_lt j a b := by
  rintro ⟨k, hklt, hkrel⟩
  have hkj := lt_of_lt_of_le hklt hij
  use k, hkj, hkrel

/--
The convertability relation ≡ generated from the union of ARS relations.
Note that this is denoted using `=` in TeReSe, which we use for equality.
-/
abbrev ARS.conv: Rel α α :=
  A.union_rel≡

/--
`SubARS B` is a sub-ARS of B.
-/
@[ext]
structure SubARS (B: ARS β I) where
  /-- This SubARS contains the elements in the subtype `{b // p b}`. -/
  p: β → Prop
  /-- The underlying ARS of this SubARS. -/
  ars: ARS {b: β // p b} I
  /-- `SubARS.ars.rel i` is the _restriction_ of `B.rel i` to the subtype. -/
  restrict: ∀(i: I) (a b: {b // p b}), ars.rel i a b ↔ B.rel i a b
  /-- `{b // p b}` is _closed_ under `B.rel i` -/
  closed: ∀(i: I) (a b: β), p a ∧ B.rel i a b → p b

attribute [simp] SubARS.restrict

/-- The subtype of this SubARS. -/
@[simp]
abbrev SubARS.Subtype {A: ARS β I} (S: SubARS A) := {b // S.p b}

/-- The restriction property of a SubARS extends to the union of rewrite relations. -/
@[simp]
lemma SubARS.restrict_union {A: ARS α I} (S: SubARS A): (∀a b, S.ars.union_rel a b ↔ A.union_rel a b) := by
  intro a b
  simp [ARS.union_rel]

/-- The closure property of a SubARS extends to the union of rewrite relations. -/
lemma SubARS.closed_union {A: ARS α I} (S: SubARS A): ∀a b, S.p a ∧ A.union_rel a b → S.p b := by
  rintro a b ⟨h₁, h₂⟩
  obtain ⟨i, hi⟩ := h₂
  apply S.closed
  tauto


/-- The restriction property of a SubARS extends to the (partial) union of rewrite relations. -/
lemma SubARS.restrict_union_lt {A: ARS α I} [PartialOrder I] (S: SubARS A):
    (∀i a b, S.ars.union_lt i a b ↔ A.union_lt i a b) := by
  simp [ARS.union_lt]

/-- The closure property of a SubARS extends to the (partial) union of rewrite relations. -/
lemma SubARS.closed_union_lt {A: ARS α I} [PartialOrder I] (S: SubARS A):
    ∀i a b, S.p a ∧ A.union_lt i a b → S.p b := by
  rintro i a b ⟨h₁, h₂⟩
  obtain ⟨i, hi⟩ := h₂
  apply S.closed
  tauto


/-- The sub-ARS generated by a subset of β -/
def SubARS.generate (B: ARS β I) (s: Set β) : SubARS B where
  p := (fun b ↦ ∃a, a ∈ s ∧ B.union_rel∗ a b)
  ars := ⟨fun i a b ↦ B.rel i a b⟩
  restrict := by simp
  closed := by aesop (add unsafe 25% ReflTransGen.tail)

/--
The reduction graph of an element b in an ARS B is the sub-ARS containing all reducts of b.
-/
def ARS.reduction_graph (B: ARS β I) (b: β) : SubARS B :=
  SubARS.generate B {b}

@[simp]
lemma ARS.reduction_graph_p: (A.reduction_graph a).p = (A.union_rel∗ a ·) := by
  simp [ARS.reduction_graph, SubARS.generate]


/--
A component of A is a sub-ARS of A containing elements that are convertible to one another.
-/
@[ext]
structure Component extends SubARS A where
  component_restrict: ∀{a b}, p a → p b → A.conv a b
  component_closed: ∀{a b}, p a → A.conv a b → p b
  component_nonempty: ∃a, p a

/--
The component of `a ∈ α` w.r.t. conversion is the sub-ARS `component a`
with set of elements { a' | a ≡ a' } and the reduction relation restricted
to this convertability class.
-/
def ARS.component (a: α): Component A where
  p := (A.conv a ·)
  ars := ⟨fun i a b ↦ A.rel i a b⟩ -- reduction relation is the same as A, modulo types
  restrict := by simp
  closed := by
    rintro i x y ⟨hconv, hstep⟩
    exact EqvGen.trans a x y hconv <| EqvGen.rel x y ⟨i, hstep⟩
  component_restrict := (EqvGen.trans _ _ _ ·.symm)
  component_closed := EqvGen.trans _ _ _
  component_nonempty := ⟨a, by rfl⟩

/-- The set of components of this ARS. -/
def ARS.components: Set (Component A) :=
  A.component '' Set.univ

/--
A component is unique; that is to say, if any element appears in two components, the components
must be the equal to one another.
-/
lemma component_unique {A: ARS α I} {c₁ c₂: Component A} (a: α):
    c₁.p a → c₂.p a → c₁ = c₂ := by
  rintro ha₁ ha₂
  have prop_eq: c₁.p = c₂.p := by
    ext b
    constructor
    · exact fun hb ↦ c₂.component_closed ha₂ (c₁.component_restrict ha₁ hb)
    · exact fun hb ↦ c₁.component_closed ha₁ (c₂.component_restrict ha₂ hb)
  ext
  · simp only [prop_eq]
  · congr! 1
    ext
    · exact Eq.to_iff (congrFun prop_eq _)
    · -- this is a very load-bearing intermediate proof.
      -- we absolutely need hpq to be subst-able, which requires us to massage c₁ and c₂ into
      -- a shape that makes replacement well-typed. That requires us to pass c₁.ars and c₂.ars
      -- as arbitrary ARSes A and B, which are not dependent on c₁.p and c₂.p, which would inhibit
      -- replacement. We still need the restriction properties that c₁ and c₂ give us, though, so we
      -- need to pass those in separately.
      have {p q: α → Prop} (hpq: p = q) (A: ARS (Subtype p) I) (B: ARS (Subtype q) I) (C: ARS α I)
        (hres₁: ∀i a b, A.rel i a b ↔ C.rel i a b) (hres₂: ∀i a b, B.rel i a b ↔ C.rel i a b): HEq A B := by
        subst hpq
        apply heq_of_eq
        ext i a b
        rw [hres₁, hres₂]

      apply this prop_eq c₁.ars c₂.ars A c₁.restrict c₂.restrict


/-- The element from which a component is derived is trivially a member of that component. -/
lemma ARS.component_root_mem {A: ARS α I}: (A.component a).p a := by
  simp [ARS.component]
  rfl

lemma component_mem_eq {A: ARS α I} {x: Component A} (helem: x.p b):
    (A.component b) = x :=
  component_unique b ARS.component_root_mem helem

@[simp]
lemma ARS.component_p: (A.component a).p = (A.conv a ·) := by
  simp [ARS.component]

private lemma restrict_aux {p: α → Prop}
    {s: α → α → Prop} {r: {b // p b} → {b // p b} → Prop}
    (hrestrict: ∀a b, r a b ↔ s a b) (hclosure: ∀a b, p a ∧ s a b → p b):
    ∀a b, r∗ a b ↔ s∗ a b := by
  intro a b
  constructor <;> intro h'
  · induction h' with
    | refl => exact ReflTransGen.refl
    | tail _ h ih =>
      exact ReflTransGen.tail ih <| (hrestrict _ _).mp h
  · rcases a with ⟨a', ha'⟩
    simp [Subtype.mk] at h'
    induction h' using ReflTransGen.head_induction_on with
    | refl => exact ReflTransGen.refl
    | head h₁ _h₂ ih =>
      rename_i b c
      have hc : p c := hclosure b c (by tauto)
      apply ReflTransGen.head _ (ih hc)
      simp [hrestrict]
      exact h₁


/--
The restriction property of a sub-ARS extends to the reflexive-transitive closure
of its reduction relations.
-/
@[simp]
lemma SubARS.star_restrict {A: ARS α I} (S: SubARS A):
    (∀i a b, (S.ars.rel i)∗ a b ↔ (A.rel i)∗ a b) :=
  fun i ↦ restrict_aux (S.restrict i) (S.closed i)

/--
The restriction property of a sub-ARS extends to the reflexive-transitive closure
of the union of its reduction relations.
-/
@[simp]
lemma SubARS.star_restrict_union {A: ARS α I} (S: SubARS A):
    (∀a b, S.ars.union_rel∗ a b ↔ A.union_rel∗ a b) :=
  restrict_aux S.restrict_union S.closed_union

/--
The restriction property of a sub-ARS extends to the reflexive-transitive closure
of the (partial) union of its reduction relations.
-/
@[simp]
lemma SubARS.star_restrict_union_lt {A: ARS α I} [PartialOrder I] (S: SubARS A):
    (∀i a b, (S.ars.union_lt i)∗ a b ↔ (A.union_lt i)∗ a b) :=
  fun i ↦ restrict_aux (S.restrict_union_lt i) (S.closed_union_lt i)


private lemma closure_aux {p: α → Prop} {r: α → α → Prop} (hclosure: ∀a b, p a ∧ r a b → p b):
    ∀a b, p a ∧ r∗ a b → p b := by
  introv h
  rcases h with ⟨hpa, hab⟩
  induction hab with
  | refl => exact hpa
  | tail h₁ h₂ ih =>
      rename_i b c
      have := hclosure b c
      tauto

/--
The closure property of a sub-ARS extends to the reflexive-transitive closure
of its reduction relations.
-/
lemma SubARS.star_closed {A: ARS α I} (S: SubARS A): (∀i a b, S.p a ∧ (A.rel i)∗ a b → S.p b) :=
  fun i ↦ closure_aux (S.closed i)

/--
The closure property of a sub-ARS extends to the reflexive-transitive closure
of the union of its reduction relations.
-/
lemma SubARS.star_closed_union {A: ARS α I} (S: SubARS A): (∀a b, S.p a ∧ (A.union_rel∗ a b) → S.p b) :=
  closure_aux (S.closed_union)

/--
The closure property of a sub-ARS extends to the reflexive-transitive closure
of the (partial) union of its reduction relations.
-/
lemma SubARS.star_closed_union_lt {A: ARS α I} [PartialOrder I] (S: SubARS A):
    (∀i a b, S.p a ∧ (A.union_lt i)∗ a b → S.p b) :=
  fun i ↦ closure_aux <| S.closed_union_lt i


private lemma down_confluent_aux {p: α → Prop}
    {s: α → α → Prop} {r: {b // p b} → {b // p b} → Prop}
    (hrestrict: ∀a b, r∗ a b ↔ s∗ a b) (hclosure: ∀a b, p a ∧ s∗ a b → p b):
    confluent s → confluent r := by
  rintro hc a b c ⟨rab, rac⟩

  have ⟨sab, sac⟩: s∗ a b ∧ s∗ a c := by
    constructor <;> rwa [<-hrestrict a _]

  have ⟨d, hd⟩ := hc ⟨sab, sac⟩
  have hpd: p d := hclosure b _ ⟨b.property, hd.left⟩
  use ⟨d, hpd⟩
  simp [hrestrict _ ⟨d, hpd⟩, hd]

/-- A sub-ARS of a confluent ARS is confluent. -/
lemma SubARS.down_confluent (S: SubARS A): ∀i, confluent (A.rel i) → confluent (S.ars.rel i) :=
  fun i ↦ down_confluent_aux (S.star_restrict i) (S.star_closed i)

lemma SubARS.down_confluent_union (S: SubARS A): confluent A.union_rel → confluent S.ars.union_rel :=
  down_confluent_aux S.star_restrict_union S.star_closed_union


/-- A sub-ARS of a strongly normalizing ARS is strongly normalizing. -/
lemma SubARS.down_sn (S: SubARS A): ∀i, strongly_normalizing (A.rel i) -> strongly_normalizing (S.ars.rel i) := by
  unfold strongly_normalizing
  intro i hsn
  contrapose! hsn
  obtain ⟨f, hf⟩ := hsn
  use (λn => f n)
  simpa using hf

/-- A sub-ARS of a weakly confluent ARS is weakly confluent. -/
lemma SubARS.down_wcr_union (S: SubARS A): weakly_confluent (A.union_rel) → weakly_confluent (S.ars.union_rel) := by
  intro hwc
  rintro a b c ⟨hab, hac⟩

  simp at hab hac
  obtain ⟨d, hd₁, hd₂⟩ := hwc ⟨hab, hac⟩

  let d': { b // S.p b } := ⟨d, S.star_closed_union b d ⟨b.prop, hd₁⟩⟩
  use d'
  simp_all


-- etc, sub-ARS also preserves subcommutative, DP, WN, WF, UN, NF, Ind, Inc, FB, CP

end ars_def

variable (A: ARS α I) (S: SubARS A)

end Thesis
