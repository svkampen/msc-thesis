<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Std.Data.DHashMap.Raw</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Std.Data.DHashMap.Raw";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Std</span>.<span class="name">Data</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init/Data/BEq.html">Init.Data.BEq</a></li><li><a href="../../.././Init/Data/Hashable.html">Init.Data.Hashable</a></li><li><a href="../../.././Std/Data/DHashMap/Internal/Defs.html">Std.Data.DHashMap.Internal.Defs</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Std.Data.DHashMap.Raw" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.empty"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">empty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.instEmptyCollection"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instEmptyCollection</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.instInhabited"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instInhabited</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.insert"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">insert</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.instSingletonSigmaOfBEqOfHashable"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instSingletonSigmaOfBEqOfHashable</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.instInsertSigmaOfBEqOfHashable"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instInsertSigmaOfBEqOfHashable</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.instLawfulSingletonSigma"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instLawfulSingletonSigma</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.insertIfNew"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">insertIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.containsThenInsert"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">containsThenInsert</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.getThenInsertIfNew?"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">getThenInsertIfNew?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.containsThenInsertIfNew"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">containsThenInsertIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.get?"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">get?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.contains"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">contains</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.instMembershipOfBEqOfHashable"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instMembershipOfBEqOfHashable</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.instDecidableMem"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instDecidableMem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.get"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">get</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.getD"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">getD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.get!"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">get!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.erase"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">erase</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.Const.get?"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">get?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.Const.get"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">get</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.Const.getD"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">getD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.Const.get!"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">get!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.Const.getThenInsertIfNew?"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">getThenInsertIfNew?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.getKey?"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">getKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.getKey"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">getKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.getKeyD"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">getKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.getKey!"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">getKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.isEmpty"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.filterMap"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.map"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.filter"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.foldM"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">foldM</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.fold"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">fold</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.forM"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">forM</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.forIn"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">forIn</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.instForMSigma"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instForMSigma</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.instForInSigma"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instForInSigma</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.toList"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">toList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.toArray"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">toArray</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.Const.toList"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">toList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.Const.toArray"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">toArray</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.keys"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.keysArray"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">keysArray</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.values"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">values</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.valuesArray"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">valuesArray</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.insertMany"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">insertMany</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.Const.insertMany"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">insertMany</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.Const.insertManyUnit"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">insertManyUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.ofList"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">ofList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.union"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">union</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.instUnionOfBEqOfHashable"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instUnionOfBEqOfHashable</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.Const.ofList"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">ofList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.Const.unitOfList"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">unitOfList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.Const.unitOfArray"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">unitOfArray</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.Internal.numBuckets"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Internal</span>.<span class="name">numBuckets</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.instRepr"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instRepr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.size_buckets_pos"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">size_buckets_pos</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.empty"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">empty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.emptyc"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">emptyc</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.insert"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">insert</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.containsThenInsert"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">containsThenInsert</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.containsThenInsertIfNew"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">containsThenInsertIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.erase"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">erase</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.insertIfNew"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">insertIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.getThenInsertIfNew?"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">getThenInsertIfNew?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.filter"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.Const.getThenInsertIfNew?"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">Const</span>.<span class="name">getThenInsertIfNew?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.insertMany"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">insertMany</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.Const.insertMany"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">Const</span>.<span class="name">insertMany</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.Const.insertManyUnit"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">Const</span>.<span class="name">insertManyUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.ofList"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">ofList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.Const.ofList"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">Const</span>.<span class="name">ofList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.Const.unitOfList"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">Const</span>.<span class="name">unitOfList</span></a></div></nav><main>
<div class="mod_doc"><p>The type <code>DHashMap.Raw</code> itself is defined in the module <code>Std.Data.DHashmap.RawDef</code> for import
structure reasons.</p></div><div class="decl" id="Std.DHashMap.Raw.empty"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L45-L52">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.empty"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">empty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(capacity : <a href="../../.././Init/Prelude.html#Nat">Nat</a> := <span class="fn">8</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span></div></div><p>Creates a new empty hash map. The optional parameter <code>capacity</code> can be supplied to presize the
map so that it can hold the given number of mappings without reallocating. It is also possible to
use the empty collection notations <code>∅</code> and <code>{}</code> to create an empty hash map with the default
capacity.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.empty">Std.DHashMap.Raw.empty</a> <span class="fn">capacity</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.empty">Std.DHashMap.Internal.Raw₀.empty</a> <span class="fn">capacity</span>)</span>.val</span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.empty" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.instEmptyCollection"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L54-L55">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.instEmptyCollection"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instEmptyCollection</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Core.html#EmptyCollection">EmptyCollection</a> <span class="fn">(<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Std.DHashMap.Raw.instEmptyCollection</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">emptyCollection</span> := <span class="fn">Std.DHashMap.Raw.empty</span> }</span></span></li></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.instInhabited"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L57-L58">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.instInhabited"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instInhabited</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Std.DHashMap.Raw.instInhabited</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a> }</span></span></li></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.insert"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L60-L66">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.insert"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">insert</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span></div></div><p>Inserts the given mapping into the map, replacing an existing mapping for the key if there is one.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">m</span>.insert</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.buckets</span>.size</span></span> then <span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.insert">Std.DHashMap.Internal.Raw₀.insert</a> <span class="fn">⟨<span class="fn">m</span>, <span class="fn">h</span>⟩</span> <span class="fn">a</span> <span class="fn">b</span>)</span>.val</span> else <span class="fn">m</span></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.insert" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.instSingletonSigmaOfBEqOfHashable"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L68-L69">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.instSingletonSigmaOfBEqOfHashable"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instSingletonSigmaOfBEqOfHashable</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Core.html#Singleton">Singleton</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span> <span class="fn">(<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Std.DHashMap.Raw.instSingletonSigmaOfBEqOfHashable</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{
    <span class="fn">singleton</span> := <span class="fn">fun (<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt;
      <span class="fn">match <span class="fn">x</span> with
      | <span class="fn">⟨<span class="fn">a</span>, <span class="fn">b</span>⟩</span> =&gt; <span class="fn"><span class="fn"><span class="fn">Std.DHashMap.Raw.empty</span>.insert</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.instInsertSigmaOfBEqOfHashable"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L71-L72">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.instInsertSigmaOfBEqOfHashable"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instInsertSigmaOfBEqOfHashable</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Core.html#Insert">Insert</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span> <span class="fn">(<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Std.DHashMap.Raw.instInsertSigmaOfBEqOfHashable</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{
    <span class="fn">insert</span> := <span class="fn">fun (<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) (<span class="fn">s</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>) =&gt;
      <span class="fn">match <span class="fn">x</span> with
      | <span class="fn">⟨<span class="fn">a</span>, <span class="fn">b</span>⟩</span> =&gt; <span class="fn"><span class="fn"><span class="fn">s</span>.insert</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.instLawfulSingletonSigma"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L74-L75">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.instLawfulSingletonSigma"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instLawfulSingletonSigma</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Core.html#LawfulSingleton">LawfulSingleton</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span> <span class="fn">(<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.insertIfNew"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L77-L84">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.insertIfNew"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">insertIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span></div></div><p>If there is no mapping for the given key, inserts the given mapping into the map. Otherwise,
returns the map unaltered.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">m</span>.insertIfNew</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.buckets</span>.size</span></span> then <span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.insertIfNew">Std.DHashMap.Internal.Raw₀.insertIfNew</a> <span class="fn">⟨<span class="fn">m</span>, <span class="fn">h</span>⟩</span> <span class="fn">a</span> <span class="fn">b</span>)</span>.val</span> else <span class="fn">m</span></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.insertIfNew" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.containsThenInsert"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L86-L96">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.containsThenInsert"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">containsThenInsert</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Bool">Bool</a> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span></span></div></div><p>Checks whether a key is present in a map, and unconditionally inserts a value for the key.</p><p>Equivalent to (but potentially faster than) calling <code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.contains">contains</a></code> followed by <code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.insert">insert</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">m</span>.containsThenInsert</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.buckets</span>.size</span></span> then
    <span class="fn">match <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.containsThenInsert">Std.DHashMap.Internal.Raw₀.containsThenInsert</a> <span class="fn">⟨<span class="fn">m</span>, <span class="fn">h</span>⟩</span> <span class="fn">a</span> <span class="fn">b</span></span> with
    | <span class="fn">(<span class="fn">replaced</span>, <span class="fn">⟨<span class="fn">r</span>, <span class="fn">property</span>⟩</span>)</span> =&gt; <span class="fn">(<span class="fn">replaced</span>, <span class="fn">r</span>)</span></span>
  else <span class="fn">(<a href="../../.././Init/Prelude.html#Bool.false">false</a>, <span class="fn">m</span>)</span></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.containsThenInsert" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.getThenInsertIfNew?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L98-L114">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.getThenInsertIfNew?"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">getThenInsertIfNew?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span></span></div></div><p>Checks whether a key is present in a map, returning the associated value, and inserts a value for
the key if it was not found.</p><p>If the returned value is <code>some v</code>, then the returned map is unaltered. If it is <code>none</code>, then the
returned map has a new value inserted.</p><p>Equivalent to (but potentially faster than) calling <code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.get?">get?</a></code> followed by <code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.insertIfNew">insertIfNew</a></code>.</p><p>Uses the <code><a href="../../.././Init/Core.html#LawfulBEq">LawfulBEq</a></code> instance to cast the retrieved value to the correct type.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">m</span>.getThenInsertIfNew?</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.buckets</span>.size</span></span> then
    <span class="fn">match <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.getThenInsertIfNew?">Std.DHashMap.Internal.Raw₀.getThenInsertIfNew?</a> <span class="fn">⟨<span class="fn">m</span>, <span class="fn">h</span>⟩</span> <span class="fn">a</span> <span class="fn">b</span></span> with
    | <span class="fn">(<span class="fn">previous</span>, <span class="fn">⟨<span class="fn">r</span>, <span class="fn">property</span>⟩</span>)</span> =&gt; <span class="fn">(<span class="fn">previous</span>, <span class="fn">r</span>)</span></span>
  else <span class="fn">(<span class="fn">none</span>, <span class="fn">m</span>)</span></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.getThenInsertIfNew?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.containsThenInsertIfNew"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L116-L129">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.containsThenInsertIfNew"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">containsThenInsertIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Bool">Bool</a> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span></span></div></div><p>Checks whether a key is present in a map and inserts a value for the key if it was not found.</p><p>If the returned <code><a href="../../.././Init/Prelude.html#Bool">Bool</a></code> is <code>true</code>, then the returned map is unaltered. If the <code><a href="../../.././Init/Prelude.html#Bool">Bool</a></code> is <code>false</code>, then
the returned map has a new value inserted.</p><p>Equivalent to (but potentially faster than) calling <code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.contains">contains</a></code> followed by <code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.insertIfNew">insertIfNew</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.containsThenInsertIfNew" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.get?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L131-L139">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.get?"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">get?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span></div></div><p>Tries to retrieve the mapping for the given key, returning <code>none</code> if no such mapping is present.</p><p>Uses the <code><a href="../../.././Init/Core.html#LawfulBEq">LawfulBEq</a></code> instance to cast the retrieved value to the correct type.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">m</span>.get?</span> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.buckets</span>.size</span></span> then <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.get?">Std.DHashMap.Internal.Raw₀.get?</a> <span class="fn">⟨<span class="fn">m</span>, <span class="fn">h</span>⟩</span> <span class="fn">a</span></span> else <span class="fn">none</span></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.get?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.contains"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L141-L151">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.contains"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">contains</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Bool">Bool</a></div></div><p>Returns <code>true</code> if there is a mapping for the given key. There is also a <code>Prop</code>-valued version
of this: <code>a ∈ m</code> is equivalent to <code>m.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.contains">contains</a> a = true</code>.</p><p>Observe that this is different behavior than for lists: for lists, <code>∈</code> uses <code>=</code> and <code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.contains">contains</a></code> uses
<code>==</code> for comparisons, while for hash maps, both use <code>==</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">m</span>.contains</span> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.buckets</span>.size</span></span> then <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.contains">Std.DHashMap.Internal.Raw₀.contains</a> <span class="fn">⟨<span class="fn">m</span>, <span class="fn">h</span>⟩</span> <span class="fn">a</span></span> else <a href="../../.././Init/Prelude.html#Bool.false">false</a></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.contains" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.instMembershipOfBEqOfHashable"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L153-L154">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.instMembershipOfBEqOfHashable"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instMembershipOfBEqOfHashable</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">(<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Std.DHashMap.Raw.instMembershipOfBEqOfHashable</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">mem</span> := <span class="fn">fun (<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>) (<span class="fn">a</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn"><span class="fn"><span class="fn">m</span>.contains</span> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.instDecidableMem"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L156-L157">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.instDecidableMem"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instDecidableMem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn">a</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">m</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Std.DHashMap.Raw.instDecidableMem</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#inferInstanceAs">inferInstanceAs</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">m</span>.contains</span> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a>)</span>)</span></span></span></li></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.get"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L159-L167">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.get"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">get</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">m</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></div></div><p>Retrieves the mapping for the given key. Ensures that such a mapping exists by requiring a proof
of <code>a ∈ m</code>.</p><p>Uses the <code><a href="../../.././Init/Core.html#LawfulBEq">LawfulBEq</a></code> instance to cast the retrieved value to the correct type.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">m</span>.get</span> <span class="fn">a</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.get">Std.DHashMap.Internal.Raw₀.get</a> <span class="fn">⟨<span class="fn">m</span>, <span class="fn">⋯</span>⟩</span> <span class="fn">a</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.get" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.getD"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L169-L178">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.getD"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">getD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(fallback : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></div></div><p>Tries to retrieve the mapping for the given key, returning <code>fallback</code> if no such mapping is present.</p><p>Uses the <code><a href="../../.././Init/Core.html#LawfulBEq">LawfulBEq</a></code> instance to cast the retrieved value to the correct type.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">m</span>.getD</span> <span class="fn">a</span> <span class="fn">fallback</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.buckets</span>.size</span></span> then <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.getD">Std.DHashMap.Internal.Raw₀.getD</a> <span class="fn">⟨<span class="fn">m</span>, <span class="fn">h</span>⟩</span> <span class="fn">a</span> <span class="fn">fallback</span></span> else <span class="fn">fallback</span></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.getD" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.get!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L180-L189">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.get!"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">get!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></div></div><p>Tries to retrieve the mapping for the given key, panicking if no such mapping is present.</p><p>Uses the <code><a href="../../.././Init/Core.html#LawfulBEq">LawfulBEq</a></code> instance to cast the retrieved value to the correct type.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">m</span>.get!</span> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.buckets</span>.size</span></span> then <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.get!">Std.DHashMap.Internal.Raw₀.get!</a> <span class="fn">⟨<span class="fn">m</span>, <span class="fn">h</span>⟩</span> <span class="fn">a</span></span> else <span class="fn">default</span></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.get!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.erase"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L191-L195">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.erase"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">erase</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span></div></div><p>Removes the mapping for the given key if it exists.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">m</span>.erase</span> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.buckets</span>.size</span></span> then <span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.erase">Std.DHashMap.Internal.Raw₀.erase</a> <span class="fn">⟨<span class="fn">m</span>, <span class="fn">h</span>⟩</span> <span class="fn">a</span>)</span>.val</span> else <span class="fn">m</span></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.erase" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.Const.get?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L201-L207">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.get?"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">get?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></div></div><p>Tries to retrieve the mapping for the given key, returning <code>none</code> if no such mapping is present.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.get?">Std.DHashMap.Raw.Const.get?</a> <span class="fn">m</span> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.buckets</span>.size</span></span> then <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.Const.get?">Std.DHashMap.Internal.Raw₀.Const.get?</a> <span class="fn">⟨<span class="fn">m</span>, <span class="fn">h</span>⟩</span> <span class="fn">a</span></span> else <span class="fn">none</span></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.Const.get?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.Const.get"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L209-L215">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.get"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">get</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">m</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">β</span></div></div><p>Retrieves the mapping for the given key. Ensures that such a mapping exists by requiring a proof of
<code>a ∈ m</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.get">Std.DHashMap.Raw.Const.get</a> <span class="fn">m</span> <span class="fn">a</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.Const.get">Std.DHashMap.Internal.Raw₀.Const.get</a> <span class="fn">⟨<span class="fn">m</span>, <span class="fn">⋯</span>⟩</span> <span class="fn">a</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.Const.get" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.Const.getD"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L217-L223">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.getD"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">getD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(fallback : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">β</span></div></div><p>Tries to retrieve the mapping for the given key, returning <code>fallback</code> if no such mapping is present.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.getD">Std.DHashMap.Raw.Const.getD</a> <span class="fn">m</span> <span class="fn">a</span> <span class="fn">fallback</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.buckets</span>.size</span></span> then <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.Const.getD">Std.DHashMap.Internal.Raw₀.Const.getD</a> <span class="fn">⟨<span class="fn">m</span>, <span class="fn">h</span>⟩</span> <span class="fn">a</span> <span class="fn">fallback</span></span> else <span class="fn">fallback</span></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.Const.getD" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.Const.get!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L225-L229">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.get!"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">get!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">β</span></div></div><p>Tries to retrieve the mapping for the given key, panicking if no such mapping is present.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.get!">Std.DHashMap.Raw.Const.get!</a> <span class="fn">m</span> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.buckets</span>.size</span></span> then <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.Const.get!">Std.DHashMap.Internal.Raw₀.Const.get!</a> <span class="fn">⟨<span class="fn">m</span>, <span class="fn">h</span>⟩</span> <span class="fn">a</span></span> else <span class="fn">default</span></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.Const.get!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.Const.getThenInsertIfNew?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L231-L245">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.getThenInsertIfNew?"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">getThenInsertIfNew?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span></span></div></div><p>Equivalent to (but potentially faster than) calling <code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.get?">Const.get?</a></code> followed by <code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.insertIfNew">insertIfNew</a></code>.</p><p>Checks whether a key is present in a map, returning the associated value, and inserts a value for
the key if it was not found.</p><p>If the returned value is <code>some v</code>, then the returned map is unaltered. If it is <code>none</code>, then the
returned map has a new value inserted.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.Const.getThenInsertIfNew?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.getKey?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L249-L256">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.getKey?"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">getKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span></div></div><p>Checks if a mapping for the given key exists and returns the key if it does, otherwise <code>none</code>.
The result in the <code>some</code> case is guaranteed to be pointer equal to the key in the map.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">m</span>.getKey?</span> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.buckets</span>.size</span></span> then <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.getKey?">Std.DHashMap.Internal.Raw₀.getKey?</a> <span class="fn">⟨<span class="fn">m</span>, <span class="fn">h</span>⟩</span> <span class="fn">a</span></span> else <span class="fn">none</span></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.getKey?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.getKey"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L258-L264">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.getKey"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">getKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">m</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Retrieves the key from the mapping that matches <code>a</code>. Ensures that such a mapping exists by
requiring a proof of <code>a ∈ m</code>. The result is guaranteed to be pointer equal to the key in the map.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">m</span>.getKey</span> <span class="fn">a</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.getKey">Std.DHashMap.Internal.Raw₀.getKey</a> <span class="fn">⟨<span class="fn">m</span>, <span class="fn">⋯</span>⟩</span> <span class="fn">a</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.getKey" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.getKeyD"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L266-L273">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.getKeyD"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">getKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a fallback : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Checks if a mapping for the given key exists and returns the key if it does, otherwise <code>fallback</code>.
If a mapping exists the result is guaranteed to be pointer equal to the key in the map.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">m</span>.getKeyD</span> <span class="fn">a</span> <span class="fn">fallback</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.buckets</span>.size</span></span> then <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.getKeyD">Std.DHashMap.Internal.Raw₀.getKeyD</a> <span class="fn">⟨<span class="fn">m</span>, <span class="fn">h</span>⟩</span> <span class="fn">a</span> <span class="fn">fallback</span></span> else <span class="fn">fallback</span></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.getKeyD" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.getKey!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L275-L282">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.getKey!"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">getKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Checks if a mapping for the given key exists and returns the key if it does, otherwise panics.
If no panic occurs the result is guaranteed to be pointer equal to the key in the map.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">m</span>.getKey!</span> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.buckets</span>.size</span></span> then <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.getKey!">Std.DHashMap.Internal.Raw₀.getKey!</a> <span class="fn">⟨<span class="fn">m</span>, <span class="fn">h</span>⟩</span> <span class="fn">a</span></span> else <span class="fn">default</span></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.getKey!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.isEmpty"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L284-L292">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.isEmpty"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Bool">Bool</a></div></div><p>Returns <code>true</code> if the hash map contains no mappings.</p><p>Note that if your <code><a href="../../.././Init/Prelude.html#BEq">BEq</a></code> instance is not reflexive or your <code><a href="../../.././Init/Prelude.html#Hashable">Hashable</a></code> instance is not
lawful, then it is possible that this function returns <code>false</code> even though is not possible
to get anything out of the hash map.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">m</span>.isEmpty</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn">m</span>.size</span> <a href="../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">0</span>)</span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.isEmpty" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><p>We currently do not provide lemmas for the functions below.</p></div><div class="decl" id="Std.DHashMap.Raw.filterMap"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L298-L306">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.filterMap"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">γ</span></span></div></div><p>Updates the values of the hash map by applying the given function to all mappings, keeping
only those mappings where the function returns <code>some</code> value.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.filterMap">Std.DHashMap.Raw.filterMap</a> <span class="fn">f</span> <span class="fn">m</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.buckets</span>.size</span></span> then <span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.filterMap">Std.DHashMap.Internal.Raw₀.filterMap</a> <span class="fn">f</span> <span class="fn">⟨<span class="fn">m</span>, <span class="fn">h</span>⟩</span>)</span>.val</span> else <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.filterMap" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.map"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L308-L312">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.map"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">γ</span></span></div></div><p>Updates the values of the hash map by applying the given function to all mappings.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.map">Std.DHashMap.Raw.map</a> <span class="fn">f</span> <span class="fn">m</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.buckets</span>.size</span></span> then <span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.map">Std.DHashMap.Internal.Raw₀.map</a> <span class="fn">f</span> <span class="fn">⟨<span class="fn">m</span>, <span class="fn">h</span>⟩</span>)</span>.val</span> else <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.map" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.filter"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L314-L318">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.filter"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span></div></div><p>Removes all mappings of the hash map for which the given function returns <code>false</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.filter">Std.DHashMap.Raw.filter</a> <span class="fn">f</span> <span class="fn">m</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.buckets</span>.size</span></span> then <span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.filter">Std.DHashMap.Internal.Raw₀.filter</a> <span class="fn">f</span> <span class="fn">⟨<span class="fn">m</span>, <span class="fn">h</span>⟩</span>)</span>.val</span> else <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.filter" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.foldM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L320-L325">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.foldM"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">foldM</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{δ : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><a href="../../.././foundational_types.html">Type</a> w → <a href="../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">δ</span> → <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">m</span> <span class="fn">δ</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(init : <span class="fn">δ</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">δ</span></span></div></div><p>Monadically computes a value by folding the given function over the mappings in the hash
map in some order.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.foldM">Std.DHashMap.Raw.foldM</a> <span class="fn">f</span> <span class="fn">init</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Data/Array/Basic.html#Array.foldlM">Array.foldlM</a>
    <span class="fn">(fun (<span class="fn">acc</span> : <span class="fn">δ</span>) (<span class="fn">l</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/AssocList/Basic.html#Std.DHashMap.Internal.AssocList">Std.DHashMap.Internal.AssocList</a> <span class="fn">α</span> <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/AssocList/Basic.html#Std.DHashMap.Internal.AssocList.foldlM">Std.DHashMap.Internal.AssocList.foldlM</a> <span class="fn">f</span> <span class="fn">acc</span> <span class="fn">l</span></span>)</span> <span class="fn">init</span>
    <span class="fn"><span class="fn">b</span>.buckets</span></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.foldM" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.fold"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L327-L329">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.fold"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">fold</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{δ : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">δ</span> → <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn">δ</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(init : <span class="fn">δ</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">δ</span></div></div><p>Folds the given function over the mappings in the hash map in some order.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.fold">Std.DHashMap.Raw.fold</a> <span class="fn">f</span> <span class="fn">init</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.foldM">Std.DHashMap.Raw.foldM</a> <span class="fn">f</span> <span class="fn">init</span> <span class="fn">b</span>)</span>.run</span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.fold" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.forM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L331-L333">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.forM"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">forM</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><a href="../../.././foundational_types.html">Type</a> w → <a href="../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">m</span> <a href="../../.././Init/Prelude.html#PUnit">PUnit</a></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <a href="../../.././Init/Prelude.html#PUnit">PUnit</a></span></div></div><p>Carries out a monadic action on each mapping in the hash map in some order.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.forM">Std.DHashMap.Raw.forM</a> <span class="fn">f</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Data/Array/Basic.html#Array.forM">Array.forM</a> <span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/AssocList/Basic.html#Std.DHashMap.Internal.AssocList.forM">Std.DHashMap.Internal.AssocList.forM</a> <span class="fn">f</span>)</span> <span class="fn"><span class="fn">b</span>.buckets</span></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.forM" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.forIn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L335-L337">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.forIn"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">forIn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{δ : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><a href="../../.././foundational_types.html">Type</a> w → <a href="../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">m</span> <span class="fn">(<a href="../../.././Init/Core.html#ForInStep">ForInStep</a> <span class="fn">δ</span>)</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(init : <span class="fn">δ</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">δ</span></span></div></div><p>Support for the <code>for</code> loop construct in <code>do</code> blocks.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.forIn">Std.DHashMap.Raw.forIn</a> <span class="fn">f</span> <span class="fn">init</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Core.html#ForIn.forIn">forIn</a> <span class="fn"><span class="fn">b</span>.buckets</span> <span class="fn">init</span> <span class="fn">fun (<span class="fn">bucket</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/AssocList/Basic.html#Std.DHashMap.Internal.AssocList">Std.DHashMap.Internal.AssocList</a> <span class="fn">α</span> <span class="fn">β</span></span>) (<span class="fn">acc</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn"><span class="fn">bucket</span>.forInStep</span> <span class="fn">acc</span> <span class="fn">f</span></span></span></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.forIn" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.instForMSigma"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L339-L340">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.instForMSigma"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instForMSigma</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><a href="../../.././foundational_types.html">Type</a> w → <a href="../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Control/Basic.html#ForM">ForM</a> <span class="fn">m</span> <span class="fn">(<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span>)</span> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Std.DHashMap.Raw.instForMSigma</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{
    <span class="fn">forM</span> := <span class="fn">fun [<span class="fn"><a href="../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>] (<span class="fn">m_1</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>) (<span class="fn">f</span> : <span class="fn"><span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span> → <span class="fn"><span class="fn">m</span> <a href="../../.././Init/Prelude.html#PUnit">PUnit</a></span></span>) =&gt;
      <span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.forM">Std.DHashMap.Raw.forM</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">⟨<span class="fn">a</span>, <span class="fn">b</span>⟩</span></span>)</span> <span class="fn">m_1</span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.instForInSigma"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L342-L343">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.instForInSigma"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instForInSigma</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><a href="../../.././foundational_types.html">Type</a> w → <a href="../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Core.html#ForIn">ForIn</a> <span class="fn">m</span> <span class="fn">(<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span>)</span> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.toList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L345-L347">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.toList"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">toList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></div></div><p>Transforms the hash map into a list of mappings in some order.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">m</span>.toList</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.fold">Std.DHashMap.Raw.fold</a> <span class="fn">(fun (<span class="fn">acc</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>) (<span class="fn">k</span> : <span class="fn">α</span>) (<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>) =&gt; <span class="fn"><span class="fn">⟨<span class="fn">k</span>, <span class="fn">v</span>⟩</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">acc</span></span>)</span> <span class="fn">[]</span> <span class="fn">m</span></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.toList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.toArray"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L349-L351">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.toArray"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">toArray</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></div></div><p>Transforms the hash map into an array of mappings in some order.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">m</span>.toArray</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.fold">Std.DHashMap.Raw.fold</a> <span class="fn">(fun (<span class="fn">acc</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>) (<span class="fn">k</span> : <span class="fn">α</span>) (<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>) =&gt; <span class="fn"><span class="fn"><span class="fn">acc</span>.push</span> <span class="fn">⟨<span class="fn">k</span>, <span class="fn">v</span>⟩</span></span>)</span> <span class="fn">#[]</span> <span class="fn">m</span></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.toArray" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.Const.toList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L353-L355">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.toList"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">toList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">(<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span></div></div><p>Transforms the hash map into a list of mappings in some order.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.toList">Std.DHashMap.Raw.Const.toList</a> <span class="fn">m</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.fold">Std.DHashMap.Raw.fold</a> <span class="fn">(fun (<span class="fn">acc</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">(<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span>) (<span class="fn">k</span> : <span class="fn">α</span>) (<span class="fn">v</span> : <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">(<span class="fn">k</span>, <span class="fn">v</span>)</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">acc</span></span>)</span> <span class="fn">[]</span> <span class="fn">m</span></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.Const.toList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.Const.toArray"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L357-L359">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.toArray"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">toArray</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <span class="fn">(<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span></div></div><p>Transforms the hash map into an array of mappings in some order.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.toArray">Std.DHashMap.Raw.Const.toArray</a> <span class="fn">m</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.fold">Std.DHashMap.Raw.fold</a> <span class="fn">(fun (<span class="fn">acc</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <span class="fn">(<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span>) (<span class="fn">k</span> : <span class="fn">α</span>) (<span class="fn">v</span> : <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn"><span class="fn">acc</span>.push</span> <span class="fn">(<span class="fn">k</span>, <span class="fn">v</span>)</span></span>)</span> <span class="fn">#[]</span> <span class="fn">m</span></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.Const.toArray" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.keys"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L361-L363">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.keys"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span></div></div><p>Returns a list of all keys present in the hash map in some order.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">m</span>.keys</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.fold">Std.DHashMap.Raw.fold</a> <span class="fn">(fun (<span class="fn">acc</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>) (<span class="fn">k</span> : <span class="fn">α</span>) (<span class="fn">x</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>) =&gt; <span class="fn"><span class="fn">k</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">acc</span></span>)</span> <span class="fn">[]</span> <span class="fn">m</span></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.keys" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.keysArray"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L365-L367">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.keysArray"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">keysArray</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p>Returns an array of all keys present in the hash map in some order.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">m</span>.keysArray</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.fold">Std.DHashMap.Raw.fold</a> <span class="fn">(fun (<span class="fn">acc</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span>) (<span class="fn">k</span> : <span class="fn">α</span>) (<span class="fn">x</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>) =&gt; <span class="fn"><span class="fn"><span class="fn">acc</span>.push</span> <span class="fn">k</span></span>)</span> <span class="fn">#[]</span> <span class="fn">m</span></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.keysArray" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.values"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L369-L371">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.values"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">values</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">β</span></span></div></div><p>Returns a list of all values present in the hash map in some order.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">m</span>.values</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.fold">Std.DHashMap.Raw.fold</a> <span class="fn">(fun (<span class="fn">acc</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">β</span></span>) (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">v</span> : <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">v</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">acc</span></span>)</span> <span class="fn">[]</span> <span class="fn">m</span></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.values" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.valuesArray"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L373-L375">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.valuesArray"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">valuesArray</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <span class="fn">β</span></span></div></div><p>Returns an array of all values present in the hash map in some order.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">m</span>.valuesArray</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.fold">Std.DHashMap.Raw.fold</a> <span class="fn">(fun (<span class="fn">acc</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <span class="fn">β</span></span>) (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">v</span> : <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn"><span class="fn">acc</span>.push</span> <span class="fn">v</span></span>)</span> <span class="fn">#[]</span> <span class="fn">m</span></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.valuesArray" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.insertMany"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L377-L385">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.insertMany"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">insertMany</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ρ : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#ForIn">ForIn</a> <a href="../../.././Init/Control/Id.html#Id">Id</a> <span class="fn">ρ</span> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(l : <span class="fn">ρ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span></div></div><p>Inserts multiple mappings into the hash map by iterating over the given collection and calling
<code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.insert">insert</a></code>. If the same key appears multiple times, the last occurrence takes precedence.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">m</span>.insertMany</span> <span class="fn">l</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.buckets</span>.size</span></span> then <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.insertMany">Std.DHashMap.Internal.Raw₀.insertMany</a> <span class="fn">⟨<span class="fn">m</span>, <span class="fn">h</span>⟩</span> <span class="fn">l</span>)</span>.val</span>.val</span> else <span class="fn">m</span></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.insertMany" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.Const.insertMany"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L387-L391">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.insertMany"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">insertMany</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ρ : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#ForIn">ForIn</a> <a href="../../.././Init/Control/Id.html#Id">Id</a> <span class="fn">ρ</span> <span class="fn">(<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(l : <span class="fn">ρ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span></div></div><p>Inserts multiple mappings into the hash map by iterating over the given collection and calling
<code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.insert">insert</a></code>. If the same key appears multiple times, the last occurrence takes precedence.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.insertMany">Std.DHashMap.Raw.Const.insertMany</a> <span class="fn">m</span> <span class="fn">l</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.buckets</span>.size</span></span> then <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.Const.insertMany">Std.DHashMap.Internal.Raw₀.Const.insertMany</a> <span class="fn">⟨<span class="fn">m</span>, <span class="fn">h</span>⟩</span> <span class="fn">l</span>)</span>.val</span>.val</span> else <span class="fn">m</span></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.Const.insertMany" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.Const.insertManyUnit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L393-L404">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.insertManyUnit"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">insertManyUnit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ρ : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#ForIn">ForIn</a> <a href="../../.././Init/Control/Id.html#Id">Id</a> <span class="fn">ρ</span> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(l : <span class="fn">ρ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></span></div></div><p>Inserts multiple keys with the value <code>()</code> into the hash map by iterating over the given collection
and calling <code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.insert">insert</a></code>. If the same key appears multiple times, the last occurrence takes precedence.</p><p>This is mainly useful to implement <code>HashSet.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.insertMany">insertMany</a></code>, so if you are considering using this,
<code>HashSet</code> or <code>HashSet.Raw</code> might be a better fit for you.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.insertManyUnit">Std.DHashMap.Raw.Const.insertManyUnit</a> <span class="fn">m</span> <span class="fn">l</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.buckets</span>.size</span></span> then <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.Const.insertManyUnit">Std.DHashMap.Internal.Raw₀.Const.insertManyUnit</a> <span class="fn">⟨<span class="fn">m</span>, <span class="fn">h</span>⟩</span> <span class="fn">l</span>)</span>.val</span>.val</span> else <span class="fn">m</span></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.Const.insertManyUnit" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.ofList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L406-L409">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.ofList"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">ofList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(l : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span></div></div><p>Creates a hash map from a list of mappings. If the same key appears multiple times, the last
occurrence takes precedence.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.ofList">Std.DHashMap.Raw.ofList</a> <span class="fn">l</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a>.insertMany</span> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.ofList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.union"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L411-L413">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.union"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">union</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(m₁ m₂ : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span></div></div><p>Computes the union of the given hash maps, by traversing <code>m₂</code> and inserting its elements into <code>m₁</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">m₁</span>.union</span> <span class="fn">m₂</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.fold">Std.DHashMap.Raw.fold</a> <span class="fn">(fun (<span class="fn">acc</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>) (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn"><span class="fn">acc</span>.insert</span> <span class="fn">x</span></span>)</span> <span class="fn">m₁</span> <span class="fn">m₂</span></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.union" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.instUnionOfBEqOfHashable"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L415-L415">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.instUnionOfBEqOfHashable"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instUnionOfBEqOfHashable</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Core.html#Union">Union</a> <span class="fn">(<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Std.DHashMap.Raw.instUnionOfBEqOfHashable</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">union</span> := <span class="fn">Std.DHashMap.Raw.union</span> }</span></span></li></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.Const.ofList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L417-L419">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.ofList"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">ofList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(l : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">(<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span></div></div><p>Creates a hash map from a list of mappings. If the same key appears multiple times, the last
occurrence takes precedence.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.ofList">Std.DHashMap.Raw.Const.ofList</a> <span class="fn">l</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.insertMany">Std.DHashMap.Raw.Const.insertMany</a> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.Const.ofList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.Const.unitOfList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L421-L427">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.unitOfList"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">unitOfList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(l : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></span></div></div><p>Creates a hash map from a list of keys, associating the value <code>()</code> with each key.</p><p>This is mainly useful to implement <code>HashSet.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.ofList">ofList</a></code>, so if you are considering using this,
<code>HashSet</code> or <code>HashSet.Raw</code> might be a better fit for you.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.unitOfList">Std.DHashMap.Raw.Const.unitOfList</a> <span class="fn">l</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.insertManyUnit">Std.DHashMap.Raw.Const.insertManyUnit</a> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.Const.unitOfList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.Const.unitOfArray"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L429-L435">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.unitOfArray"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">unitOfArray</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(l : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></span></div></div><p>Creates a hash map from an array of keys, associating the value <code>()</code> with each key.</p><p>This is mainly useful to implement <code>HashSet.ofArray</code>, so if you are considering using this,
<code>HashSet</code> or <code>HashSet.Raw</code> might be a better fit for you.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.unitOfArray">Std.DHashMap.Raw.Const.unitOfArray</a> <span class="fn">l</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.insertManyUnit">Std.DHashMap.Raw.Const.insertManyUnit</a> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.Const.unitOfArray" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.Internal.numBuckets"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L437-L443">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Internal.numBuckets"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Internal</span>.<span class="name">numBuckets</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Nat">Nat</a></div></div><p>Returns the number of buckets in the internal representation of the hash map. This function may be
useful for things like monitoring system health, but it should be considered an internal
implementation detail.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Internal.numBuckets">Std.DHashMap.Raw.Internal.numBuckets</a> <span class="fn">m</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">m</span>.buckets</span>.size</span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.Internal.numBuckets" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.instRepr"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L445-L446">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.instRepr"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instRepr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Data/Repr.html#Repr">Repr</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><a href="../../.././Init/Data/Repr.html#Repr">Repr</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/Repr.html#Repr">Repr</a> <span class="fn">(<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Std.DHashMap.Raw.instRepr</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{
    <span class="fn">reprPrec</span> := <span class="fn">fun (<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>) (<span class="fn">prec</span> : <a href="../../.././Init/Prelude.html#Nat">Nat</a>) =&gt;
      <span class="fn"><a href="../../.././Init/Data/Repr.html#Repr.addAppParen">Repr.addAppParen</a> <span class="fn">(<span class="fn"><a href="../../.././Init/Data/Format/Basic.html#Std.Format.text">Std.Format.text</a> <span class="fn">&quot;Std.DHashMap.Raw.ofList &quot;</span></span> <a href="../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn"><a href="../../.././Init/Data/Repr.html#reprArg">reprArg</a> <span class="fn"><span class="fn">m</span>.toList</span></span>)</span> <span class="fn">prec</span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.WF"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L452-L488">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span> → <a href="../../.././foundational_types.html">Prop</a></span></div></div><p>Well-formedness predicate for hash maps. Users of <code>DHashMap</code> will not need to interact with
this. Users of <code>DHashMap.Raw</code> will need to provide proofs of <code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></code> to lemmas and should use lemmas
like <code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.empty">WF.empty</a></code> and <code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.insert">WF.insert</a></code> (which are always named exactly like the operations they are about)
to show that map operations preserve well-formedness. The constructors of this type are internal
implementation details and should not be accessed by users.</p><ul class="constructors"><li class="constructor" id="Std.DHashMap.Raw.WF.wf">wf: <span class="fn">∀ {<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u} {<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>} [<span class="fn">inst</span> : <span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>] [<span class="fn">inst_1</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>] {<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>},
  <span class="fn"><span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.buckets</span>.size</span></span> → <span class="fn"><span class="fn">(∀ [<span class="fn">inst_2</span> : <span class="fn"><a href="../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>] [<span class="fn">inst_3</span> : <span class="fn"><a href="../../.././Init/Data/Hashable.html#LawfulHashable">LawfulHashable</a> <span class="fn">α</span></span>], <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw.WFImp">Std.DHashMap.Internal.Raw.WFImp</a> <span class="fn">m</span></span>)</span> → <span class="fn"><span class="fn">m</span>.WF</span></span></span></span><div class="inductive_ctor_doc"><p>Internal implementation detail of the hash map</p></div></li><li class="constructor" id="Std.DHashMap.Raw.WF.empty₀">empty₀: <span class="fn">∀ {<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u} {<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>} [<span class="fn">inst</span> : <span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>] [<span class="fn">inst_1</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>] {<span class="fn">c</span> : <a href="../../.././Init/Prelude.html#Nat">Nat</a>},
  <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.empty">Std.DHashMap.Internal.Raw₀.empty</a> <span class="fn">c</span>)</span>.val</span>.WF</span></span><div class="inductive_ctor_doc"><p>Internal implementation detail of the hash map</p></div></li><li class="constructor" id="Std.DHashMap.Raw.WF.insert₀">insert₀: <span class="fn">∀ {<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u} {<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>} [<span class="fn">inst</span> : <span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>] [<span class="fn">inst_1</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>] {<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>} {<span class="fn">h</span> : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.buckets</span>.size</span></span>}
  {<span class="fn">a</span> : <span class="fn">α</span>} {<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}, <span class="fn"><span class="fn"><span class="fn">m</span>.WF</span> → <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.insert">Std.DHashMap.Internal.Raw₀.insert</a> <span class="fn">⟨<span class="fn">m</span>, <span class="fn">h</span>⟩</span> <span class="fn">a</span> <span class="fn">b</span>)</span>.val</span>.WF</span></span></span><div class="inductive_ctor_doc"><p>Internal implementation detail of the hash map</p></div></li><li class="constructor" id="Std.DHashMap.Raw.WF.containsThenInsert₀">containsThenInsert₀: <span class="fn">∀ {<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u} {<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>} [<span class="fn">inst</span> : <span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>] [<span class="fn">inst_1</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>] {<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>} {<span class="fn">h</span> : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.buckets</span>.size</span></span>}
  {<span class="fn">a</span> : <span class="fn">α</span>} {<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}, <span class="fn"><span class="fn"><span class="fn">m</span>.WF</span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.containsThenInsert">Std.DHashMap.Internal.Raw₀.containsThenInsert</a> <span class="fn">⟨<span class="fn">m</span>, <span class="fn">h</span>⟩</span> <span class="fn">a</span> <span class="fn">b</span>)</span>.snd</span>.val</span>.WF</span></span></span><div class="inductive_ctor_doc"><p>Internal implementation detail of the hash map</p></div></li><li class="constructor" id="Std.DHashMap.Raw.WF.containsThenInsertIfNew₀">containsThenInsertIfNew₀: <span class="fn">∀ {<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u} {<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>} [<span class="fn">inst</span> : <span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>] [<span class="fn">inst_1</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>] {<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>} {<span class="fn">h</span> : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.buckets</span>.size</span></span>}
  {<span class="fn">a</span> : <span class="fn">α</span>} {<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}, <span class="fn"><span class="fn"><span class="fn">m</span>.WF</span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.containsThenInsertIfNew">Std.DHashMap.Internal.Raw₀.containsThenInsertIfNew</a> <span class="fn">⟨<span class="fn">m</span>, <span class="fn">h</span>⟩</span> <span class="fn">a</span> <span class="fn">b</span>)</span>.snd</span>.val</span>.WF</span></span></span><div class="inductive_ctor_doc"><p>Internal implementation detail of the hash map</p></div></li><li class="constructor" id="Std.DHashMap.Raw.WF.erase₀">erase₀: <span class="fn">∀ {<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u} {<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>} [<span class="fn">inst</span> : <span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>] [<span class="fn">inst_1</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>] {<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>} {<span class="fn">h</span> : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.buckets</span>.size</span></span>}
  {<span class="fn">a</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn"><span class="fn">m</span>.WF</span> → <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.erase">Std.DHashMap.Internal.Raw₀.erase</a> <span class="fn">⟨<span class="fn">m</span>, <span class="fn">h</span>⟩</span> <span class="fn">a</span>)</span>.val</span>.WF</span></span></span><div class="inductive_ctor_doc"><p>Internal implementation detail of the hash map</p></div></li><li class="constructor" id="Std.DHashMap.Raw.WF.insertIfNew₀">insertIfNew₀: <span class="fn">∀ {<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u} {<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>} [<span class="fn">inst</span> : <span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>] [<span class="fn">inst_1</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>] {<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>} {<span class="fn">h</span> : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.buckets</span>.size</span></span>}
  {<span class="fn">a</span> : <span class="fn">α</span>} {<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}, <span class="fn"><span class="fn"><span class="fn">m</span>.WF</span> → <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.insertIfNew">Std.DHashMap.Internal.Raw₀.insertIfNew</a> <span class="fn">⟨<span class="fn">m</span>, <span class="fn">h</span>⟩</span> <span class="fn">a</span> <span class="fn">b</span>)</span>.val</span>.WF</span></span></span><div class="inductive_ctor_doc"><p>Internal implementation detail of the hash map</p></div></li><li class="constructor" id="Std.DHashMap.Raw.WF.getThenInsertIfNew?₀">getThenInsertIfNew?₀: <span class="fn">∀ {<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u} {<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>} [<span class="fn">inst</span> : <span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>] [<span class="fn">inst_1</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>] [<span class="fn">inst_2</span> : <span class="fn"><a href="../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>] {<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>}
  {<span class="fn">h</span> : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.buckets</span>.size</span></span>} {<span class="fn">a</span> : <span class="fn">α</span>} {<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>},
  <span class="fn"><span class="fn"><span class="fn">m</span>.WF</span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.getThenInsertIfNew?">Std.DHashMap.Internal.Raw₀.getThenInsertIfNew?</a> <span class="fn">⟨<span class="fn">m</span>, <span class="fn">h</span>⟩</span> <span class="fn">a</span> <span class="fn">b</span>)</span>.snd</span>.val</span>.WF</span></span></span><div class="inductive_ctor_doc"><p>Internal implementation detail of the hash map</p></div></li><li class="constructor" id="Std.DHashMap.Raw.WF.filter₀">filter₀: <span class="fn">∀ {<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u} {<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>} [<span class="fn">inst</span> : <span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>] [<span class="fn">inst_1</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>] {<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>} {<span class="fn">h</span> : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.buckets</span>.size</span></span>}
  {<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></span>}, <span class="fn"><span class="fn"><span class="fn">m</span>.WF</span> → <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.filter">Std.DHashMap.Internal.Raw₀.filter</a> <span class="fn">f</span> <span class="fn">⟨<span class="fn">m</span>, <span class="fn">h</span>⟩</span>)</span>.val</span>.WF</span></span></span><div class="inductive_ctor_doc"><p>Internal implementation detail of the hash map</p></div></li><li class="constructor" id="Std.DHashMap.Raw.WF.constGetThenInsertIfNew?₀">constGetThenInsertIfNew?₀: <span class="fn">∀ {<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u} {<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> v} [<span class="fn">inst</span> : <span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>] [<span class="fn">inst_1</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>] {<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span>}
  {<span class="fn">h</span> : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.buckets</span>.size</span></span>} {<span class="fn">a</span> : <span class="fn">α</span>} {<span class="fn">b</span> : <span class="fn">β</span>},
  <span class="fn"><span class="fn"><span class="fn">m</span>.WF</span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.Const.getThenInsertIfNew?">Std.DHashMap.Internal.Raw₀.Const.getThenInsertIfNew?</a> <span class="fn">⟨<span class="fn">m</span>, <span class="fn">h</span>⟩</span> <span class="fn">a</span> <span class="fn">b</span>)</span>.snd</span>.val</span>.WF</span></span></span><div class="inductive_ctor_doc"><p>Internal implementation detail of the hash map</p></div></li></ul><details id="instances-for-list-Std.DHashMap.Raw.WF" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.WF.size_buckets_pos"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L490-L501">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.size_buckets_pos"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">size_buckets_pos</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">m</span>.WF</span> → <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.buckets</span>.size</span></span></span></div></div><p>Internal implementation detail of the hash map</p></div></div><div class="decl" id="Std.DHashMap.Raw.WF.empty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L503-L504">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.empty"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">empty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.empty">Std.DHashMap.Raw.empty</a> <span class="fn">c</span>)</span>.WF</span></div></div></div></div><div class="decl" id="Std.DHashMap.Raw.WF.emptyc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L506-L507">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.emptyc"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">emptyc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a>.WF</span></div></div></div></div><div class="decl" id="Std.DHashMap.Raw.WF.insert"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L509-L511">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.insert"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">insert</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">m</span>.WF</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">m</span>.insert</span> <span class="fn">a</span> <span class="fn">b</span>)</span>.WF</span></div></div></div></div><div class="decl" id="Std.DHashMap.Raw.WF.containsThenInsert"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L513-L515">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.containsThenInsert"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">containsThenInsert</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">m</span>.WF</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">m</span>.containsThenInsert</span> <span class="fn">a</span> <span class="fn">b</span>)</span>.snd</span>.WF</span></div></div></div></div><div class="decl" id="Std.DHashMap.Raw.WF.containsThenInsertIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L517-L519">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.containsThenInsertIfNew"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">containsThenInsertIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">m</span>.WF</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">m</span>.containsThenInsertIfNew</span> <span class="fn">a</span> <span class="fn">b</span>)</span>.snd</span>.WF</span></div></div></div></div><div class="decl" id="Std.DHashMap.Raw.WF.erase"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L521-L522">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.erase"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">erase</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">m</span>.WF</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">m</span>.erase</span> <span class="fn">a</span>)</span>.WF</span></div></div></div></div><div class="decl" id="Std.DHashMap.Raw.WF.insertIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L524-L526">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.insertIfNew"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">insertIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">m</span>.WF</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">m</span>.insertIfNew</span> <span class="fn">a</span> <span class="fn">b</span>)</span>.WF</span></div></div></div></div><div class="decl" id="Std.DHashMap.Raw.WF.getThenInsertIfNew?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L528-L530">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.getThenInsertIfNew?"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">getThenInsertIfNew?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">m</span>.WF</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">m</span>.getThenInsertIfNew?</span> <span class="fn">a</span> <span class="fn">b</span>)</span>.snd</span>.WF</span></div></div></div></div><div class="decl" id="Std.DHashMap.Raw.WF.filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L532-L534">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.filter"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">m</span>.WF</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.filter">Std.DHashMap.Raw.filter</a> <span class="fn">f</span> <span class="fn">m</span>)</span>.WF</span></div></div></div></div><div class="decl" id="Std.DHashMap.Raw.WF.Const.getThenInsertIfNew?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L536-L538">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.Const.getThenInsertIfNew?"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">Const</span>.<span class="name">getThenInsertIfNew?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">m</span>.WF</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.getThenInsertIfNew?">Std.DHashMap.Raw.Const.getThenInsertIfNew?</a> <span class="fn">m</span> <span class="fn">a</span> <span class="fn">b</span>)</span>.snd</span>.WF</span></div></div></div></div><div class="decl" id="Std.DHashMap.Raw.WF.insertMany"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L540-L543">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.insertMany"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">insertMany</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ρ : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#ForIn">ForIn</a> <a href="../../.././Init/Control/Id.html#Id">Id</a> <span class="fn">ρ</span> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l : <span class="fn">ρ</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">m</span>.WF</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">m</span>.insertMany</span> <span class="fn">l</span>)</span>.WF</span></div></div></div></div><div class="decl" id="Std.DHashMap.Raw.WF.Const.insertMany"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L545-L548">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.Const.insertMany"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">Const</span>.<span class="name">insertMany</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ρ : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#ForIn">ForIn</a> <a href="../../.././Init/Control/Id.html#Id">Id</a> <span class="fn">ρ</span> <span class="fn">(<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l : <span class="fn">ρ</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">m</span>.WF</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.insertMany">Std.DHashMap.Raw.Const.insertMany</a> <span class="fn">m</span> <span class="fn">l</span>)</span>.WF</span></div></div></div></div><div class="decl" id="Std.DHashMap.Raw.WF.Const.insertManyUnit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L550-L553">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.Const.insertManyUnit"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">Const</span>.<span class="name">insertManyUnit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ρ : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#ForIn">ForIn</a> <a href="../../.././Init/Control/Id.html#Id">Id</a> <span class="fn">ρ</span> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l : <span class="fn">ρ</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">m</span>.WF</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.insertManyUnit">Std.DHashMap.Raw.Const.insertManyUnit</a> <span class="fn">m</span> <span class="fn">l</span>)</span>.WF</span></div></div></div></div><div class="decl" id="Std.DHashMap.Raw.WF.ofList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L555-L557">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.ofList"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">ofList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.ofList">Std.DHashMap.Raw.ofList</a> <span class="fn">l</span>)</span>.WF</span></div></div></div></div><div class="decl" id="Std.DHashMap.Raw.WF.Const.ofList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L559-L561">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.Const.ofList"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">Const</span>.<span class="name">ofList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">(<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.ofList">Std.DHashMap.Raw.Const.ofList</a> <span class="fn">l</span>)</span>.WF</span></div></div></div></div><div class="decl" id="Std.DHashMap.Raw.WF.Const.unitOfList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Raw.lean#L563-L565">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.Const.unitOfList"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">Const</span>.<span class="name">unitOfList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.unitOfList">Std.DHashMap.Raw.Const.unitOfList</a> <span class="fn">l</span>)</span>.WF</span></div></div></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>