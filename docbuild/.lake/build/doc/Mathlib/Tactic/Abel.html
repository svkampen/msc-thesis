<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Tactic.Abel</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Tactic.Abel";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/Tactic/TryThis.html">Mathlib.Tactic.TryThis</a></li><li><a href="../.././Mathlib/Util/AtomM.html">Mathlib.Util.AtomM</a></li><li><a href="../.././Mathlib/Tactic/NormNum/Basic.html">Mathlib.Tactic.NormNum.Basic</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Tactic.Abel" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.Context"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">Context</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.mkContext"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">mkContext</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.M"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">M</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.Context.app"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">Context</span>.<span class="name">app</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.Context.mkApp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">Context</span>.<span class="name">mkApp</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.addG"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">addG</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.iapp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">iapp</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.termg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">termg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.mkTerm"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">mkTerm</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.intToExpr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">intToExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.NormalExpr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">NormalExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.instInhabitedNormalExpr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">instInhabitedNormalExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.NormalExpr.e"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">NormalExpr</span>.<span class="name">e</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.instCoeNormalExprExpr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">instCoeNormalExprExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.NormalExpr.term'"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">NormalExpr</span>.<span class="name">term'</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.NormalExpr.zero'"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">NormalExpr</span>.<span class="name">zero'</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.const_add_term"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">const_add_term</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.const_add_termg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">const_add_termg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term_add_const"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_add_const</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term_add_constg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_add_constg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term_add_term"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_add_term</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term_add_termg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_add_termg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.zero_term"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">zero_term</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.zero_termg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">zero_termg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.evalAdd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">evalAdd</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term_neg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_neg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.evalNeg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">evalNeg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.smul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">smul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.smulg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">smulg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.zero_smul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">zero_smul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.zero_smulg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">zero_smulg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term_smul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_smul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term_smulg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_smulg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.evalSMul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">evalSMul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term_atom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_atom</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term_atomg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_atomg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term_atom_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_atom_pf</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term_atom_pfg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_atom_pfg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.evalAtom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">evalAtom</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.unfold_sub"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">unfold_sub</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.unfold_smul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">unfold_smul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.unfold_smulg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">unfold_smulg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.unfold_zsmul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">unfold_zsmul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.subst_into_smul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">subst_into_smul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.subst_into_smulg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">subst_into_smulg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.subst_into_smul_upcast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">subst_into_smul_upcast</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.subst_into_add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">subst_into_add</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.subst_into_addg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">subst_into_addg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.subst_into_negg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">subst_into_negg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.evalSMul'"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">evalSMul'</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">eval</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.abel1"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abel1</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.abel1!"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abel1!</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term_eq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.termg_eq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">termg_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.NormalExpr.isAtom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">NormalExpr</span>.<span class="name">isAtom</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.AbelMode"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">AbelMode</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.AbelNF.Config"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">AbelNF</span>.<span class="name">Config</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.elabAbelNFConfig"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">elabAbelNFConfig</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.abelNFCore"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abelNFCore</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.abelNFCore.go"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abelNFCore</span>.<span class="name">go</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.abelNFCore.evalAtom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abelNFCore</span>.<span class="name">evalAtom</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.abelNFTarget"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abelNFTarget</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.abelNFLocalDecl"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abelNFLocalDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.abel_term"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abel_term</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.abel!_term"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abel!_term</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.abelNF"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abelNF</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.tacticAbel_nf!__"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">tacticAbel_nf!__</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.abelNFConv"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abelNFConv</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.elabAbelNFConv"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">elabAbelNFConv</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.convAbel_nf!_"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">convAbel_nf!_</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.abel"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abel</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.tacticAbel!"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">tacticAbel!</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.abelConv"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abelConv</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.convAbel!"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">convAbel!</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="The-abel-tactic">The <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> tactic <a class="hover-link" href="#The-abel-tactic">#</a></h1><p>Evaluate expressions in the language of additive, commutative monoids and groups.</p></div><div class="decl" id="Mathlib.Tactic.Abel.Context"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L28-L43">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">Context</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>The <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context">Context</a></code> for a call to <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code>.</p><p>Stores a few options for this call, and caches some common subexpressions
such as typeclass instances and <code>0 : <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.α">α</a></code>.</p><ul class="structure_fields" id="Mathlib.Tactic.Abel.Context.mk"><li id="Mathlib.Tactic.Abel.Context.α" class="structure_field"><div class="structure_field_info">α : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></div><div class="structure_field_doc"><p>The type of the ambient additive commutative group or monoid.</p></div></li><li id="Mathlib.Tactic.Abel.Context.univ" class="structure_field"><div class="structure_field_info">univ : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a></div><div class="structure_field_doc"><p>The universe level for <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.α">α</a></code>.</p></div></li><li id="Mathlib.Tactic.Abel.Context.α0" class="structure_field"><div class="structure_field_info">α0 : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></div><div class="structure_field_doc"><p>The expression representing <code>0 : <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.α">α</a></code>.</p></div></li><li id="Mathlib.Tactic.Abel.Context.isGroup" class="structure_field"><div class="structure_field_info">isGroup : <a href="../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>Specify whether we are in an additive commutative group or an additive commutative monoid.</p></div></li><li id="Mathlib.Tactic.Abel.Context.inst" class="structure_field"><div class="structure_field_info">inst : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></div><div class="structure_field_doc"><p>The <code><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.α">α</a></code> or <code><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.α">α</a></code> expression.</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.Abel.Context" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.mkContext"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L45-L55">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.mkContext"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">mkContext</span></a></span><span class="decl_args">
<span class="fn">(e : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context">Mathlib.Tactic.Abel.Context</a></span></div></div><p>Populate a <code>context</code> object for evaluating <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.e">e</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.mkContext" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.M"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L57-L60">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">M</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../.././foundational_types.html">Type</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>The monad for <code>Abel</code> contains, in addition to the <code>AtomM</code> state,
some information about the current type we are working over, so that we can consistently
use group lemmas or monoid lemmas as appropriate.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">Mathlib.Tactic.Abel.M</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#ReaderT">ReaderT</a> <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context">Mathlib.Tactic.Abel.Context</a> <a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">Mathlib.Tactic.AtomM</a></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.M" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.Context.app"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L62-L65">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.app"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">Context</span>.<span class="name">app</span></a></span><span class="decl_args">
<span class="fn">(c : <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context">Mathlib.Tactic.Abel.Context</a>)</span></span>
<span class="decl_args">
<span class="fn">(n : <a href="../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(inst : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span> → <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>Apply the function <code>n : ∀ {α} [inst : AddWhatever α], _</code> to the
implicit parameters in the context, and the given list of arguments.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.app</span> <span class="fn">n</span> <span class="fn">inst</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lean/Expr.html#Lean.mkAppN">Lean.mkAppN</a> <span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../.././Lean/Expr.html#Lean.Expr.const">Lean.Expr.const</a> <span class="fn">n</span> <span class="fn">[<span class="fn"><span class="fn">c</span>.univ</span>]</span>)</span>.app</span> <span class="fn"><span class="fn">c</span>.α</span>)</span>.app</span> <span class="fn">inst</span>)</span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.Context.app" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.Context.mkApp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L67-L74">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.mkApp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">Context</span>.<span class="name">mkApp</span></a></span><span class="decl_args">
<span class="fn">(c : <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context">Mathlib.Tactic.Abel.Context</a>)</span></span>
<span class="decl_args">
<span class="fn">(n inst : <a href="../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(l : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>Apply the function <code>n : ∀ {α} [inst α], _</code> to the implicit parameters in the
context, and the given list of arguments.</p><p>Compared to <code>context.<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.app">app</a></code>, this takes the name of the typeclass, rather than an
inferred typeclass instance.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.mkApp</span> <span class="fn">n</span> <span class="fn">inst</span> <span class="fn">l</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../.././Lean/Meta/SynthInstance.html#Lean.Meta.synthInstance">Lean.Meta.synthInstance</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../.././Lean/Expr.html#Lean.Expr.const">Lean.Expr.const</a> <span class="fn">inst</span> <span class="fn">[<span class="fn"><span class="fn">c</span>.univ</span>]</span>)</span>.app</span> <span class="fn"><span class="fn">c</span>.α</span>)</span></span>
  <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<span class="fn"><span class="fn">c</span>.app</span> <span class="fn">n</span> <span class="fn">__do_lift</span> <span class="fn">l</span>)</span></span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.Context.mkApp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.addG"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L76-L83">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.addG"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">addG</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Lean.Name">Lean.Name</a> → <a href="../.././Init/Prelude.html#Lean.Name">Lean.Name</a></span></div></div><p>Add the letter &quot;g&quot; to the end of the name, e.g. turning <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">term</a></code> into <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">termg</a></code>.</p><p>This is used to choose between declarations taking <code><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a></code> and those
taking <code><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a></code> instances.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.addG">Mathlib.Tactic.Abel.addG</a> <span class="fn">(<span class="fn"><span class="fn">p</span>.str</span> <span class="fn">s</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">p</span>.str</span> <span class="fn">(<span class="fn">s</span> <a href="../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">&quot;g&quot;</span>)</span></span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.addG">Mathlib.Tactic.Abel.addG</a> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.addG" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.iapp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L85-L91">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.iapp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">iapp</span></a></span><span class="decl_args">
<span class="fn">(n : <a href="../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(xs : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">Mathlib.Tactic.Abel.M</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>Apply the function <code>n : ∀ {α} [AddComm{Monoid,Group} α]</code> to the given list of arguments.</p><p>Will use the <code>AddComm{Monoid,Group}</code> instance that has been cached in the context.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.iapp">Mathlib.Tactic.Abel.iapp</a> <span class="fn">n</span> <span class="fn">xs</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">c</span> ← <span class="fn">read</span>
  <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<span class="fn"><span class="fn">c</span>.app</span> <span class="fn">(if <span class="fn"><span class="fn"><span class="fn">c</span>.isGroup</span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Bool.true">true</a></span> then <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.addG">Mathlib.Tactic.Abel.addG</a> <span class="fn">n</span></span> else <span class="fn">n</span>)</span> <span class="fn"><span class="fn">c</span>.inst</span> <span class="fn">xs</span>)</span></span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.iapp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.term"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L93-L94">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(n : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(x a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>A type synonym used by <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> to represent <code>n • x + a</code> in an additive commutative monoid.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">Mathlib.Tactic.Abel.term</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">n</span> <a href="../.././Mathlib/Algebra/Group/Operations.html#HSMul.hSMul">•</a> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">a</span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.term" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.termg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L95-L96">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">termg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(n : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(x a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>A type synonym used by <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> to represent <code>n • x + a</code> in an additive commutative group.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">Mathlib.Tactic.Abel.termg</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">n</span> <a href="../.././Mathlib/Algebra/Group/Operations.html#HSMul.hSMul">•</a> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">a</span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.termg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.mkTerm"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L98-L99">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.mkTerm"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">mkTerm</span></a></span><span class="decl_args">
<span class="fn">(n x a : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">Mathlib.Tactic.Abel.M</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>Evaluate a term with coefficient <code>n</code>, atom <code>x</code> and successor terms <code>a</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.mkTerm">Mathlib.Tactic.Abel.mkTerm</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.iapp">Mathlib.Tactic.Abel.iapp</a> <span class="fn">`Mathlib.Tactic.Abel.term</span> <span class="fn">#[<span class="fn">n</span>, <span class="fn">x</span>, <span class="fn">a</span>]</span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.mkTerm" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.intToExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L101-L103">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.intToExpr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">intToExpr</span></a></span><span class="decl_args">
<span class="fn">(n : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">Mathlib.Tactic.Abel.M</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>Interpret an integer as a coefficient to a term.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.intToExpr">Mathlib.Tactic.Abel.intToExpr</a> <span class="fn">n</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn">read</span>
  <span class="fn"><a href="../.././Init/Prelude.html#liftM">liftM</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../.././Lean/Expr.html#Lean.mkConst">Lean.mkConst</a> <span class="fn">(if <span class="fn"><span class="fn"><span class="fn">__do_lift</span>.isGroup</span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Bool.true">true</a></span> then <span class="fn">`Int</span> else <span class="fn">`Nat</span>)</span>)</span>.ofInt</span> <span class="fn">n</span>)</span></span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.intToExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.NormalExpr"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L105-L113">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">NormalExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>A normal form for <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code>.
Expressions are represented as a list of terms of the form <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.e">e</a> = n • x</code>,
where <code>n : ℤ</code> and <code>x</code> is an arbitrary element of the additive commutative monoid or group.
We explicitly track the <code>Expr</code> forms of <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.e">e</a></code> and <code>n</code>, even though they could be reconstructed,
for efficiency.</p><ul class="constructors"><li class="constructor" id="Mathlib.Tactic.Abel.NormalExpr.zero">zero: <span class="fn"><a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">Mathlib.Tactic.Abel.NormalExpr</a></span></li><li class="constructor" id="Mathlib.Tactic.Abel.NormalExpr.nterm">nterm: <span class="fn"><a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <span class="fn"><span class="fn"><a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a></span> → <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Nat">ℕ</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span> → <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">Mathlib.Tactic.Abel.NormalExpr</a> → <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">Mathlib.Tactic.Abel.NormalExpr</a></span></span></span></span></li></ul><details id="instances-for-list-Mathlib.Tactic.Abel.NormalExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.instInhabitedNormalExpr"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L113-L113">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.instInhabitedNormalExpr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">instInhabitedNormalExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">Mathlib.Tactic.Abel.NormalExpr</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.instInhabitedNormalExpr">Mathlib.Tactic.Abel.instInhabitedNormalExpr</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.zero">Mathlib.Tactic.Abel.NormalExpr.zero</a> <span class="fn">default</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.NormalExpr.e"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L115-L118">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.e"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">NormalExpr</span>.<span class="name">e</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">Mathlib.Tactic.Abel.NormalExpr</a> → <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>Extract the expression from a normal form.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.zero">Mathlib.Tactic.Abel.NormalExpr.zero</a> <span class="fn">e</span>)</span>.e</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">e</span></span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.nterm">Mathlib.Tactic.Abel.NormalExpr.nterm</a> <span class="fn">e</span> <span class="fn">n</span> <span class="fn">x_1</span> <span class="fn">a</span>)</span>.e</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">e</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.NormalExpr.e" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.instCoeNormalExprExpr"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L120-L120">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.instCoeNormalExprExpr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">instCoeNormalExprExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Coe.html#Coe">Coe</a> <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">Mathlib.Tactic.Abel.NormalExpr</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.instCoeNormalExprExpr">Mathlib.Tactic.Abel.instCoeNormalExprExpr</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">coe</span> := <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.e">Mathlib.Tactic.Abel.NormalExpr.e</a> }</span></span></li></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.NormalExpr.term'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L122-L124">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.term'"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">NormalExpr</span>.<span class="name">term'</span></a></span><span class="decl_args">
<span class="fn">(n : <span class="fn"><a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn"><a href="../.././Init/Prelude.html#Nat">ℕ</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">Mathlib.Tactic.Abel.NormalExpr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">Mathlib.Tactic.Abel.M</a> <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">Mathlib.Tactic.Abel.NormalExpr</a></span></div></div><p>Construct the normal form representing a single term.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.term'">Mathlib.Tactic.Abel.NormalExpr.term'</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.mkTerm">Mathlib.Tactic.Abel.mkTerm</a> <span class="fn"><span class="fn">n</span>.1</span> <span class="fn"><span class="fn">x</span>.2</span> <span class="fn"><span class="fn">a</span>.e</span></span>
  <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.nterm">Mathlib.Tactic.Abel.NormalExpr.nterm</a> <span class="fn">__do_lift</span> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span>)</span></span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.NormalExpr.term'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.NormalExpr.zero'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L126-L127">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.zero'"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">NormalExpr</span>.<span class="name">zero'</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">Mathlib.Tactic.Abel.M</a> <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">Mathlib.Tactic.Abel.NormalExpr</a></span></div></div><p>Construct the normal form representing zero.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.zero'">Mathlib.Tactic.Abel.NormalExpr.zero'</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn">read</span>
  <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.zero">Mathlib.Tactic.Abel.NormalExpr.zero</a> <span class="fn"><span class="fn">__do_lift</span>.α0</span>)</span></span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.NormalExpr.zero'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.const_add_term"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L131-L133">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.const_add_term"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">const_add_term</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(k : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(n : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(x a a' : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">k</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">k</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">Mathlib.Tactic.Abel.term</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span></span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">Mathlib.Tactic.Abel.term</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a'</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.const_add_termg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L135-L137">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.const_add_termg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">const_add_termg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(k : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(n : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(x a a' : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">k</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">k</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">Mathlib.Tactic.Abel.termg</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span></span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">Mathlib.Tactic.Abel.termg</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a'</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.term_add_const"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L139-L141">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_const"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_add_const</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(n : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(x a k a' : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">k</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">Mathlib.Tactic.Abel.term</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">k</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">Mathlib.Tactic.Abel.term</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a'</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.term_add_constg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L143-L145">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_constg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_add_constg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(n : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(x a k a' : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">k</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">Mathlib.Tactic.Abel.termg</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">k</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">Mathlib.Tactic.Abel.termg</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a'</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.term_add_term"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L147-L149">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_term"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_add_term</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(n₁ : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(x a₁ : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(n₂ : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(a₂ : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(n' : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(a' : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn"><span class="fn">n₁</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">n₂</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">n'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn"><span class="fn">a₁</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">a₂</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">Mathlib.Tactic.Abel.term</a> <span class="fn">n₁</span> <span class="fn">x</span> <span class="fn">a₁</span></span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">Mathlib.Tactic.Abel.term</a> <span class="fn">n₂</span> <span class="fn">x</span> <span class="fn">a₂</span></span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">Mathlib.Tactic.Abel.term</a> <span class="fn">n'</span> <span class="fn">x</span> <span class="fn">a'</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.term_add_termg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L151-L155">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_termg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_add_termg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(n₁ : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(x a₁ : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(n₂ : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(a₂ : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(n' : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(a' : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn"><span class="fn">n₁</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">n₂</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">n'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn"><span class="fn">a₁</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">a₂</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">Mathlib.Tactic.Abel.termg</a> <span class="fn">n₁</span> <span class="fn">x</span> <span class="fn">a₁</span></span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">Mathlib.Tactic.Abel.termg</a> <span class="fn">n₂</span> <span class="fn">x</span> <span class="fn">a₂</span></span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">Mathlib.Tactic.Abel.termg</a> <span class="fn">n'</span> <span class="fn">x</span> <span class="fn">a'</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.zero_term"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L157-L158">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_term"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">zero_term</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(x a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">Mathlib.Tactic.Abel.term</a> <span class="fn">0</span> <span class="fn">x</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.zero_termg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L160-L161">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_termg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">zero_termg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(x a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">Mathlib.Tactic.Abel.termg</a> <span class="fn">0</span> <span class="fn">x</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.evalAdd"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L163-L189">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalAdd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">evalAdd</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">Mathlib.Tactic.Abel.NormalExpr</a> →
  <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">Mathlib.Tactic.Abel.NormalExpr</a> → <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">Mathlib.Tactic.Abel.M</a> <span class="fn">(<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">Mathlib.Tactic.Abel.NormalExpr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span></span></div></div><p>Interpret the sum of two expressions in <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code>'s normal form.</p></div></div><div class="decl" id="Mathlib.Tactic.Abel.term_neg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L191-L193">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_neg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_neg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(n : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(x a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(n' : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(a' : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">n</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">n'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Neg.neg">-</a><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">Mathlib.Tactic.Abel.termg</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span></span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">Mathlib.Tactic.Abel.termg</a> <span class="fn">n'</span> <span class="fn">x</span> <span class="fn">a'</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.evalNeg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L195-L206">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalNeg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">evalNeg</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">Mathlib.Tactic.Abel.NormalExpr</a> → <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">Mathlib.Tactic.Abel.M</a> <span class="fn">(<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">Mathlib.Tactic.Abel.NormalExpr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span></span></div></div><p>Interpret a negated expression in <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code>'s normal form.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.evalNeg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.smul"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L208-L209">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">smul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(n : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>A synonym for <code>•</code>, used internally in <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul">Mathlib.Tactic.Abel.smul</a> <span class="fn">n</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">n</span> <a href="../.././Mathlib/Algebra/Group/Operations.html#HSMul.hSMul">•</a> <span class="fn">x</span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.smul" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.smulg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L210-L211">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">smulg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(n : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>A synonym for <code>•</code>, used internally in <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">Mathlib.Tactic.Abel.smulg</a> <span class="fn">n</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">n</span> <a href="../.././Mathlib/Algebra/Group/Operations.html#HSMul.hSMul">•</a> <span class="fn">x</span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.smulg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.zero_smul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L213-L214">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_smul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">zero_smul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(c : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul">Mathlib.Tactic.Abel.smul</a> <span class="fn">c</span> <span class="fn">0</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.zero_smulg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L216-L217">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_smulg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">zero_smulg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(c : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">Mathlib.Tactic.Abel.smulg</a> <span class="fn">c</span> <span class="fn">0</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.term_smul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L219-L222">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_smul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_smul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(c n : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(x a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(n' : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(a' : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn"><span class="fn">c</span> <a href="../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">n</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">n'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul">Mathlib.Tactic.Abel.smul</a> <span class="fn">c</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul">Mathlib.Tactic.Abel.smul</a> <span class="fn">c</span> <span class="fn">(<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">Mathlib.Tactic.Abel.term</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">Mathlib.Tactic.Abel.term</a> <span class="fn">n'</span> <span class="fn">x</span> <span class="fn">a'</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.term_smulg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L224-L227">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_smulg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_smulg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(c n : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(x a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(n' : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(a' : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn"><span class="fn">c</span> <a href="../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">n</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">n'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">Mathlib.Tactic.Abel.smulg</a> <span class="fn">c</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">Mathlib.Tactic.Abel.smulg</a> <span class="fn">c</span> <span class="fn">(<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">Mathlib.Tactic.Abel.termg</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">Mathlib.Tactic.Abel.termg</a> <span class="fn">n'</span> <span class="fn">x</span> <span class="fn">a'</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.evalSMul"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L229-L238">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalSMul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">evalSMul</span></a></span><span class="decl_args">
<span class="fn">(k : <span class="fn"><a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">Mathlib.Tactic.Abel.NormalExpr</a> → <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">Mathlib.Tactic.Abel.M</a> <span class="fn">(<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">Mathlib.Tactic.Abel.NormalExpr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span></span></div></div><p>Auxiliary function for <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalSMul'">evalSMul'</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.evalSMul" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.term_atom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L240-L240">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_atom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">Mathlib.Tactic.Abel.term</a> <span class="fn">1</span> <span class="fn">x</span> <span class="fn">0</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.term_atomg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L241-L241">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atomg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_atomg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">Mathlib.Tactic.Abel.termg</a> <span class="fn">1</span> <span class="fn">x</span> <span class="fn">0</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.term_atom_pf"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L242-L243">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atom_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_atom_pf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(x x' : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">Mathlib.Tactic.Abel.term</a> <span class="fn">1</span> <span class="fn">x'</span> <span class="fn">0</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.term_atom_pfg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L244-L245">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atom_pfg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_atom_pfg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(x x' : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">Mathlib.Tactic.Abel.termg</a> <span class="fn">1</span> <span class="fn">x'</span> <span class="fn">0</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.evalAtom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L247-L254">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalAtom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">evalAtom</span></a></span><span class="decl_args">
<span class="fn">(e : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">Mathlib.Tactic.Abel.M</a> <span class="fn">(<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">Mathlib.Tactic.Abel.NormalExpr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span></div></div><p>Interpret an expression as an atom for <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code>'s normal form.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.evalAtom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.unfold_sub"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L256-L257">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_sub"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">unfold_sub</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#SubtractionMonoid">SubtractionMonoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a b c : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><a href="../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">b</span></span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.unfold_smul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L259-L260">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_smul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">unfold_smul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(n : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(x y : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul">Mathlib.Tactic.Abel.smul</a> <span class="fn">n</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">n</span> <a href="../.././Mathlib/Algebra/Group/Operations.html#HSMul.hSMul">•</a> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.unfold_smulg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L262-L263">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_smulg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">unfold_smulg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(n : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(x y : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">Mathlib.Tactic.Abel.smulg</a> <span class="fn">(<a href="../.././Init/Data/Int/Basic.html#Int.ofNat">Int.ofNat</a> <span class="fn">n</span>)</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">↑<span class="fn">n</span></span> <a href="../.././Mathlib/Algebra/Group/Operations.html#HSMul.hSMul">•</a> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.unfold_zsmul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L265-L266">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_zsmul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">unfold_zsmul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(n : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(x y : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">Mathlib.Tactic.Abel.smulg</a> <span class="fn">n</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">n</span> <a href="../.././Mathlib/Algebra/Group/Operations.html#HSMul.hSMul">•</a> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.subst_into_smul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L268-L270">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">subst_into_smul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(l : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(r : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(tl : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(tr t : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(prl : <span class="fn"><span class="fn">l</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">tl</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(prr : <span class="fn"><span class="fn">r</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">tr</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(prt : <span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul">Mathlib.Tactic.Abel.smul</a> <span class="fn">tl</span> <span class="fn">tr</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">t</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul">Mathlib.Tactic.Abel.smul</a> <span class="fn">l</span> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">t</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.subst_into_smulg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L272-L274">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smulg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">subst_into_smulg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(l : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(r : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(tl : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(tr t : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(prl : <span class="fn"><span class="fn">l</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">tl</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(prr : <span class="fn"><span class="fn">r</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">tr</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(prt : <span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">Mathlib.Tactic.Abel.smulg</a> <span class="fn">tl</span> <span class="fn">tr</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">t</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">Mathlib.Tactic.Abel.smulg</a> <span class="fn">l</span> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">t</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.subst_into_smul_upcast"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L276-L279">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smul_upcast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">subst_into_smul_upcast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(l : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(r : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(tl : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(zl : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(tr t : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(prl₁ : <span class="fn"><span class="fn">l</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">tl</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(prl₂ : <span class="fn"><span class="fn">↑<span class="fn">tl</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">zl</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(prr : <span class="fn"><span class="fn">r</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">tr</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(prt : <span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">Mathlib.Tactic.Abel.smulg</a> <span class="fn">zl</span> <span class="fn">tr</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">t</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul">Mathlib.Tactic.Abel.smul</a> <span class="fn">l</span> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">t</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.subst_into_add"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L281-L283">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">subst_into_add</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(l r tl tr t : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(prl : <span class="fn"><span class="fn">l</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">tl</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(prr : <span class="fn"><span class="fn">r</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">tr</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(prt : <span class="fn"><span class="fn"><span class="fn">tl</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">tr</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">t</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">t</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.subst_into_addg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L285-L287">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_addg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">subst_into_addg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(l r tl tr t : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(prl : <span class="fn"><span class="fn">l</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">tl</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(prr : <span class="fn"><span class="fn">r</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">tr</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(prt : <span class="fn"><span class="fn"><span class="fn">tl</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">tr</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">t</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">t</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.subst_into_negg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L289-L291">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_negg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">subst_into_negg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a ta t : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(pra : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">ta</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(prt : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">ta</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">t</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">t</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.evalSMul'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L293-L321">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalSMul'"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">evalSMul'</span></a></span><span class="decl_args">
<span class="fn">(eval : <span class="fn"><a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">Mathlib.Tactic.Abel.M</a> <span class="fn">(<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">Mathlib.Tactic.Abel.NormalExpr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(is_smulg : <a href="../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(orig e₁ e₂ : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">Mathlib.Tactic.Abel.M</a> <span class="fn">(<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">Mathlib.Tactic.Abel.NormalExpr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span></div></div><p>Normalize a term <code>orig</code> of the form <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul">smul</a> e₁ e₂</code> or <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">smulg</a> e₁ e₂</code>.
Normalized terms use <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul">smul</a></code> for monoids and <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">smulg</a></code> for groups,
so there are actually four cases to handle:</p><ul>
<li>Using <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul">smul</a></code> in a monoid just simplifies the pieces using <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smul">subst_into_smul</a></code></li>
<li>Using <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">smulg</a></code> in a group just simplifies the pieces using <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smulg">subst_into_smulg</a></code></li>
<li>Using <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul">smul</a> a b</code> in a group requires converting <code>a</code> from a nat to an int and
then simplifying <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">smulg</a> ↑a b</code> using <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smul_upcast">subst_into_smul_upcast</a></code></li>
<li>Using <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">smulg</a></code> in a monoid is impossible (or at least out of scope),
because you need a group argument to write a <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">smulg</a></code> term</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.evalSMul'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.eval"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L323-L367">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">eval</span></a></span><span class="decl_args">
<span class="fn">(e : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">Mathlib.Tactic.Abel.M</a> <span class="fn">(<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">Mathlib.Tactic.Abel.NormalExpr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span></div></div><p>Evaluate an expression into its <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> normal form, by recursing into subexpressions.</p></div></div><div class="decl" id="Mathlib.Tactic.Abel.abel1"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L369-L377">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abel1</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Tactic for solving equations in the language of
<em>additive</em>, commutative monoids and groups.
This version of <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> fails if the target is not an equality
that is provable by the axioms of commutative monoids/groups.</p><p><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1!">abel1!</a></code> will use a more aggressive reducibility setting to identify atoms.
This can prove goals that <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> cannot, but is more expensive.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.abel1" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.abel1!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L399-L399">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1!"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abel1!</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Tactic for solving equations in the language of
<em>additive</em>, commutative monoids and groups.
This version of <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> fails if the target is not an equality
that is provable by the axioms of commutative monoids/groups.</p><p><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1!">abel1!</a></code> will use a more aggressive reducibility setting to identify atoms.
This can prove goals that <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> cannot, but is more expensive.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1!">Mathlib.Tactic.Abel.abel1!</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Mathlib.Tactic.Abel.abel1!</span> <span class="fn">1024</span> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;abel1!&quot;</span> <a href="../.././Init/Prelude.html#Bool.false">false</a>)</span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.abel1!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.term_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L401-L401">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_eq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(n : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(x a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">Mathlib.Tactic.Abel.term</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">n</span> <a href="../.././Mathlib/Algebra/Group/Operations.html#HSMul.hSMul">•</a> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.termg_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L402-L403">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg_eq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">termg_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(n : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(x a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">Mathlib.Tactic.Abel.termg</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">n</span> <a href="../.././Mathlib/Algebra/Group/Operations.html#HSMul.hSMul">•</a> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">a</span></span></span></div></div><p>A type synonym used by <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> to represent <code>n • x + a</code> in an additive commutative group.</p></div></div><div class="decl" id="Mathlib.Tactic.Abel.NormalExpr.isAtom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L405-L408">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.isAtom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">NormalExpr</span>.<span class="name">isAtom</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">Mathlib.Tactic.Abel.NormalExpr</a> → <a href="../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>True if this represents an atomic expression.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.nterm">Mathlib.Tactic.Abel.NormalExpr.nterm</a> <span class="fn">e</span> <span class="fn">(<span class="fn">fst</span>, <span class="fn">1</span>)</span> <span class="fn">x_1</span> <span class="fn">(<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.zero">Mathlib.Tactic.Abel.NormalExpr.zero</a> <span class="fn">e_1</span>)</span>)</span>.isAtom</span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Bool.true">true</a></span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">x</span>.isAtom</span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.NormalExpr.isAtom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.AbelMode"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L410-L415">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">AbelMode</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>The normalization style for <code>abel_nf</code>.</p><ul class="constructors"><li class="constructor" id="Mathlib.Tactic.Abel.AbelMode.term">term: <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode">Mathlib.Tactic.Abel.AbelMode</a><div class="inductive_ctor_doc"><p>The default form</p></div></li><li class="constructor" id="Mathlib.Tactic.Abel.AbelMode.raw">raw: <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode">Mathlib.Tactic.Abel.AbelMode</a><div class="inductive_ctor_doc"><p>Raw form: the representation <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> uses internally.</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.Abel.AbelMode" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.AbelNF.Config"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L417-L424">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">AbelNF</span>.<span class="name">Config</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>Configuration for <code>abel_nf</code>.</p><ul class="structure_fields" id="Mathlib.Tactic.Abel.AbelNF.Config.mk"><li id="Mathlib.Tactic.Abel.AbelNF.Config.red" class="structure_field"><div class="structure_field_info">red : <a href="../.././Init/MetaTypes.html#Lean.Meta.TransparencyMode">Lean.Meta.TransparencyMode</a></div><div class="structure_field_doc"><p>the reducibility setting to use when comparing atoms for defeq</p></div></li><li id="Mathlib.Tactic.Abel.AbelNF.Config.recursive" class="structure_field"><div class="structure_field_info">recursive : <a href="../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>if true, atoms inside ring expressions will be reduced recursively</p></div></li><li id="Mathlib.Tactic.Abel.AbelNF.Config.mode" class="structure_field"><div class="structure_field_info">mode : <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode">Mathlib.Tactic.Abel.AbelMode</a></div><div class="structure_field_doc"><p>The normalization style.</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.Abel.AbelNF.Config" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.elabAbelNFConfig"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L426-L427">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.elabAbelNFConfig"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">elabAbelNFConfig</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a> → <span class="fn"><a href="../.././Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM">Lean.Elab.Tactic.TacticM</a> <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config">Mathlib.Tactic.Abel.AbelNF.Config</a></span></span></div></div><p>Function elaborating <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config">AbelNF.Config</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.elabAbelNFConfig" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.abelNFCore"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L429-L474">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFCore"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abelNFCore</span></a></span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Init/System/IO.html#IO.Ref">IO.Ref</a> <a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.State">Mathlib.Tactic.AtomM.State</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(cfg : <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config">Mathlib.Tactic.Abel.AbelNF.Config</a>)</span></span>
<span class="decl_args">
<span class="fn">(e : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result">Lean.Meta.Simp.Result</a></span></div></div><p>The core of <code>abel_nf</code>, which rewrites the expression <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.e">e</a></code> into <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> normal form.</p><ul>
<li><code>s</code>: a reference to the mutable state of <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code>, for persisting across calls.
This ensures that atom ordering is used consistently.</li>
<li><code>cfg</code>: the configuration options</li>
<li><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.e">e</a></code>: the expression to rewrite</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.abelNFCore" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.abelNFCore.go"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L457-L470">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFCore.go"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abelNFCore</span>.<span class="name">go</span></a></span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Init/System/IO.html#IO.Ref">IO.Ref</a> <a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.State">Mathlib.Tactic.AtomM.State</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(cfg : <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config">Mathlib.Tactic.Abel.AbelNF.Config</a>)</span></span>
<span class="decl_args">
<span class="fn">(ctx : <a href="../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Context">Lean.Meta.Simp.Context</a>)</span></span>
<span class="decl_args">
<span class="fn">(simp : <span class="fn"><a href="../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result">Lean.Meta.Simp.Result</a> → <span class="fn"><a href="../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.SimpM">Lean.Meta.SimpM</a> <a href="../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result">Lean.Meta.Simp.Result</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(root : <a href="../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(parent : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result">Lean.Meta.Simp.Result</a></span></div></div><p>The recursive case of <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNF">abelNF</a></code>.</p><ul>
<li><code>root</code>: true when the function is called directly from <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFCore">abelNFCore</a></code>
and false when called by <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalAtom">evalAtom</a></code> in recursive mode.</li>
<li><code>parent</code>: The input expression to simplify. In <code>pre</code> we make use of both <code>parent</code> and <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.e">e</a></code>
to determine if we are at the top level in order to prevent a loop
<code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFCore.go">go</a> -&gt; <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.eval">eval</a> -&gt; <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalAtom">evalAtom</a> -&gt; <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFCore.go">go</a></code> which makes no progress.</li>
</ul></div></div><div class="decl" id="Mathlib.Tactic.Abel.abelNFCore.evalAtom"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L473-L473">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFCore.evalAtom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abelNFCore</span>.<span class="name">evalAtom</span></a></span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Init/System/IO.html#IO.Ref">IO.Ref</a> <a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.State">Mathlib.Tactic.AtomM.State</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(cfg : <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config">Mathlib.Tactic.Abel.AbelNF.Config</a>)</span></span>
<span class="decl_args">
<span class="fn">(ctx : <a href="../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Context">Lean.Meta.Simp.Context</a>)</span></span>
<span class="decl_args">
<span class="fn">(simp : <span class="fn"><a href="../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result">Lean.Meta.Simp.Result</a> → <span class="fn"><a href="../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.SimpM">Lean.Meta.SimpM</a> <a href="../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result">Lean.Meta.Simp.Result</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result">Lean.Meta.Simp.Result</a></span></span></div></div><p>The <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalAtom">evalAtom</a></code> implementation passed to <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.eval">eval</a></code> calls <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFCore.go">go</a></code> if <code>cfg.<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.recursive">recursive</a></code> is true,
and does nothing otherwise.</p></div></div><div class="decl" id="Mathlib.Tactic.Abel.abelNFTarget"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L477-L487">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFTarget"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abelNFTarget</span></a></span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Init/System/IO.html#IO.Ref">IO.Ref</a> <a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.State">Mathlib.Tactic.AtomM.State</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(cfg : <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config">Mathlib.Tactic.Abel.AbelNF.Config</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM">Lean.Elab.Tactic.TacticM</a> <a href="../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Use <code>abel_nf</code> to rewrite the main goal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.abelNFTarget" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.abelNFLocalDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L489-L498">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFLocalDecl"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abelNFLocalDecl</span></a></span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Init/System/IO.html#IO.Ref">IO.Ref</a> <a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.State">Mathlib.Tactic.AtomM.State</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(cfg : <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config">Mathlib.Tactic.Abel.AbelNF.Config</a>)</span></span>
<span class="decl_args">
<span class="fn">(fvarId : <a href="../.././Lean/Expr.html#Lean.FVarId">Lean.FVarId</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM">Lean.Elab.Tactic.TacticM</a> <a href="../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Use <code>abel_nf</code> to rewrite hypothesis <code>h</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.abelNFLocalDecl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.abel_term"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L500-L501">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel_term"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abel_term</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Unsupported legacy syntax from mathlib3, which allowed passing additional terms to <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.abel_term" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.abel!_term"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L502-L503">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel!_term"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abel!_term</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Unsupported legacy syntax from mathlib3, which allowed passing additional terms to <code>abel!</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.abel!_term" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.abelNF"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L505-L521">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNF"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abelNF</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Simplification tactic for expressions in the language of abelian groups,
which rewrites all group expressions into a normal form.</p><ul>
<li><code>abel_nf!</code> will use a more aggressive reducibility setting to identify atoms.</li>
<li><code>abel_nf (config := cfg)</code> allows for additional configuration:<ul>
<li><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.red">red</a></code>: the reducibility setting (overridden by <code>!</code>)</li>
<li><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.recursive">recursive</a></code>: if true, <code>abel_nf</code> will also recurse into atoms</li>
</ul>
</li>
<li><code>abel_nf</code> works as both a tactic and a conv tactic.
In tactic mode, <code>abel_nf at h</code> can be used to rewrite in a hypothesis.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.abelNF" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.tacticAbel_nf!__"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L523-L524">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.tacticAbel_nf!__"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">tacticAbel_nf!__</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Simplification tactic for expressions in the language of abelian groups,
which rewrites all group expressions into a normal form.</p><ul>
<li><code>abel_nf!</code> will use a more aggressive reducibility setting to identify atoms.</li>
<li><code>abel_nf (config := cfg)</code> allows for additional configuration:<ul>
<li><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.red">red</a></code>: the reducibility setting (overridden by <code>!</code>)</li>
<li><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.recursive">recursive</a></code>: if true, <code>abel_nf</code> will also recurse into atoms</li>
</ul>
</li>
<li><code>abel_nf</code> works as both a tactic and a conv tactic.
In tactic mode, <code>abel_nf at h</code> can be used to rewrite in a hypothesis.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.tacticAbel_nf!__" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.abelNFConv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L526-L526">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFConv"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abelNFConv</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Simplification tactic for expressions in the language of abelian groups,
which rewrites all group expressions into a normal form.</p><ul>
<li><code>abel_nf!</code> will use a more aggressive reducibility setting to identify atoms.</li>
<li><code>abel_nf (config := cfg)</code> allows for additional configuration:<ul>
<li><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.red">red</a></code>: the reducibility setting (overridden by <code>!</code>)</li>
<li><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.recursive">recursive</a></code>: if true, <code>abel_nf</code> will also recurse into atoms</li>
</ul>
</li>
<li><code>abel_nf</code> works as both a tactic and a conv tactic.
In tactic mode, <code>abel_nf at h</code> can be used to rewrite in a hypothesis.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.abelNFConv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.elabAbelNFConv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L528-L534">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.elabAbelNFConv"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">elabAbelNFConv</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.Tactic">Lean.Elab.Tactic.Tactic</a></div></div><p>Elaborator for the <code>abel_nf</code> tactic.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.elabAbelNFConv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.convAbel_nf!_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L536-L536">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.convAbel_nf!_"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">convAbel_nf!_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Simplification tactic for expressions in the language of abelian groups,
which rewrites all group expressions into a normal form.</p><ul>
<li><code>abel_nf!</code> will use a more aggressive reducibility setting to identify atoms.</li>
<li><code>abel_nf (config := cfg)</code> allows for additional configuration:<ul>
<li><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.red">red</a></code>: the reducibility setting (overridden by <code>!</code>)</li>
<li><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.recursive">recursive</a></code>: if true, <code>abel_nf</code> will also recurse into atoms</li>
</ul>
</li>
<li><code>abel_nf</code> works as both a tactic and a conv tactic.
In tactic mode, <code>abel_nf at h</code> can be used to rewrite in a hypothesis.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.convAbel_nf!_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.abel"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L550-L551">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abel</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Tactic for evaluating expressions in abelian groups.</p><ul>
<li><code>abel!</code> will use a more aggressive reducibility setting to determine equality of atoms.</li>
<li><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1">abel1</a></code> fails if the target is not an equality.</li>
</ul><p>For example:</p><pre><code>example [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
example [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">Mathlib.Tactic.Abel.abel</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Mathlib.Tactic.Abel.abel</span> <span class="fn">1024</span> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;abel&quot;</span> <a href="../.././Init/Prelude.html#Bool.false">false</a>)</span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.abel" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.tacticAbel!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L552-L553">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.tacticAbel!"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">tacticAbel!</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Tactic for evaluating expressions in abelian groups.</p><ul>
<li><code>abel!</code> will use a more aggressive reducibility setting to determine equality of atoms.</li>
<li><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1">abel1</a></code> fails if the target is not an equality.</li>
</ul><p>For example:</p><pre><code>example [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
example [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.tacticAbel!">Mathlib.Tactic.Abel.tacticAbel!</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Mathlib.Tactic.Abel.tacticAbel!</span> <span class="fn">1024</span> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;abel!&quot;</span> <a href="../.././Init/Prelude.html#Bool.false">false</a>)</span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.tacticAbel!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.abelConv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L561-L562">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelConv"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abelConv</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The tactic <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> evaluates expressions in abelian groups.
This is the conv tactic version, which rewrites a target which is an abel equality to <code><a href="../.././Init/Prelude.html#True">True</a></code>.</p><p>See also the <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> tactic.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelConv">Mathlib.Tactic.Abel.abelConv</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Mathlib.Tactic.Abel.abelConv</span> <span class="fn">1024</span> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;abel&quot;</span> <a href="../.././Init/Prelude.html#Bool.false">false</a>)</span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.abelConv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.convAbel!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L563-L564">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.convAbel!"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">convAbel!</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The tactic <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> evaluates expressions in abelian groups.
This is the conv tactic version, which rewrites a target which is an abel equality to <code><a href="../.././Init/Prelude.html#True">True</a></code>.</p><p>See also the <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> tactic.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.convAbel!">Mathlib.Tactic.Abel.convAbel!</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Mathlib.Tactic.Abel.convAbel!</span> <span class="fn">1024</span> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;abel!&quot;</span> <a href="../.././Init/Prelude.html#Bool.false">false</a>)</span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.convAbel!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>