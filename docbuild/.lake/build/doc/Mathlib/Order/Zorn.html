<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Order.Zorn</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Order.Zorn";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Order</span>.<span class="name">Zorn</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Order/Zorn.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/Order/Chain.html">Mathlib.Order.Chain</a></li><li><a href="../.././Mathlib/Order/Minimal.html">Mathlib.Order.Minimal</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Order.Zorn" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#exists_maximal_of_chains_bounded"><span class="name">exists_maximal_of_chains_bounded</span></a></div><div class="nav_link"><a class="break_within" href="#exists_maximal_of_nonempty_chains_bounded"><span class="name">exists_maximal_of_nonempty_chains_bounded</span></a></div><div class="nav_link"><a class="break_within" href="#zorn_le"><span class="name">zorn_le</span></a></div><div class="nav_link"><a class="break_within" href="#zorn_le_nonempty"><span class="name">zorn_le_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#zorn_le₀"><span class="name">zorn_le₀</span></a></div><div class="nav_link"><a class="break_within" href="#zorn_le_nonempty₀"><span class="name">zorn_le_nonempty₀</span></a></div><div class="nav_link"><a class="break_within" href="#zorn_le_nonempty_Ici₀"><span class="name">zorn_le_nonempty_Ici₀</span></a></div><div class="nav_link"><a class="break_within" href="#zorn_subset"><span class="name">zorn_subset</span></a></div><div class="nav_link"><a class="break_within" href="#zorn_subset_nonempty"><span class="name">zorn_subset_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#zorn_superset"><span class="name">zorn_superset</span></a></div><div class="nav_link"><a class="break_within" href="#zorn_superset_nonempty"><span class="name">zorn_superset_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#IsChain.exists_maxChain"><span class="name">IsChain</span>.<span class="name">exists_maxChain</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Zorn-s-lemmas">Zorn's lemmas <a class="hover-link" href="#Zorn-s-lemmas">#</a></h1><p>This file proves several formulations of Zorn's Lemma.</p><h2 class="markdown-heading" id="Variants">Variants <a class="hover-link" href="#Variants">#</a></h2><p>The primary statement of Zorn's lemma is <code><a href="../.././Mathlib/Order/Zorn.html#exists_maximal_of_chains_bounded">exists_maximal_of_chains_bounded</a></code>. Then it is specialized
to particular relations:</p><ul>
<li><code>(≤)</code> with <code><a href="../.././Mathlib/Order/Zorn.html#zorn_le">zorn_le</a></code></li>
<li><code>(⊆)</code> with <code><a href="../.././Mathlib/Order/Zorn.html#zorn_subset">zorn_subset</a></code></li>
<li><code>(⊇)</code> with <code><a href="../.././Mathlib/Order/Zorn.html#zorn_superset">zorn_superset</a></code></li>
</ul><p>Lemma names carry modifiers:</p><ul>
<li><code>₀</code>: Quantifies over a set, as opposed to over a type.</li>
<li><code>_nonempty</code>: Doesn't ask to prove that the empty chain is bounded and lets you give an element
that will be smaller than the maximal element found (the maximal element is no smaller than any
other element, but it can also be incomparable to some).</li>
</ul><h2 class="markdown-heading" id="How-to">How-to <a class="hover-link" href="#How-to">#</a></h2><p>This file comes across as confusing to those who haven't yet used it, so here is a detailed
walkthrough:</p><ol>
<li>Know what relation on which type/set you're looking for. See Variants above. You can discharge
some conditions to Zorn's lemma directly using a <code>_nonempty</code> variant.</li>
<li>Write down the definition of your type/set, put a <code>suffices ∃ m, ∀ a, m ≺ a → a ≺ m by ...</code>
(or whatever you actually need) followed by an <code>apply some_version_of_zorn</code>.</li>
<li>Fill in the details. This is where you start talking about chains.</li>
</ol><p>A typical proof using Zorn could look like this</p><pre><code class="language-lean"><a href="../.././Mathlib/Tactic/Lemma.html#lemma">lemma</a> zorny_lemma : zorny_statement := by
  let s : <a href="../.././Mathlib/Data/Set/Defs.html#Set">Set</a> α := {x | whatever x}
  suffices ∃ x ∈ s, ∀ y ∈ s, y ⊆ x → y = x by -- or with another operator xxx
    proof_post_zorn
  apply <a href="../.././Mathlib/Order/Zorn.html#zorn_subset">zorn_subset</a> -- or another variant
  rintro c hcs hc
  obtain <a href="../.././Init/Prelude.html#rfl">rfl</a> | hcnemp := c.eq_empty_or_nonempty -- you might need to disjunct on c empty or not
  · exact ⟨edge_case_construction,
      proof_that_edge_case_construction_respects_whatever,
      proof_that_edge_case_construction_contains_all_stuff_in_c⟩
  · exact ⟨construction,
      proof_that_construction_respects_whatever,
      proof_that_construction_contains_all_stuff_in_c⟩
</code></pre><h2 class="markdown-heading" id="Notes">Notes <a class="hover-link" href="#Notes">#</a></h2><p>Originally ported from Isabelle/HOL. The
<a href="https://isabelle.in.tum.de/dist/library/HOL/HOL/Zorn.html">original file</a> was written by Jacques D.
Fleuriot, Tobias Nipkow, Christian Sternagel.</p></div><div class="decl" id="exists_maximal_of_chains_bounded"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Order/Zorn.lean#L69-L81">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Zorn.html#exists_maximal_of_chains_bounded"><span class="name">exists_maximal_of_chains_bounded</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">c</span> : <span class="fn"><a href="../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/Chain.html#IsChain">IsChain</a> <span class="fn">r</span> <span class="fn">c</span></span> → <span class="fn">∃ (<span class="fn">ub</span> : <span class="fn">α</span>), <span class="fn">∀ <span class="fn">a</span> ∈ <span class="fn">c</span>, <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">ub</span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(trans : <span class="fn">∀ {<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">m</span> : <span class="fn">α</span>), <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">m</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">m</span></span></span></span></span></div></div><p><strong>Zorn's lemma</strong></p><p>If every chain has an upper bound, then there exists a maximal element.</p></div></div><div class="decl" id="exists_maximal_of_nonempty_chains_bounded"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Order/Zorn.lean#L83-L93">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Zorn.html#exists_maximal_of_nonempty_chains_bounded"><span class="name">exists_maximal_of_nonempty_chains_bounded</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">c</span> : <span class="fn"><a href="../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/Chain.html#IsChain">IsChain</a> <span class="fn">r</span> <span class="fn">c</span></span> → <span class="fn"><span class="fn"><span class="fn">c</span>.Nonempty</span> → <span class="fn">∃ (<span class="fn">ub</span> : <span class="fn">α</span>), <span class="fn">∀ <span class="fn">a</span> ∈ <span class="fn">c</span>, <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">ub</span></span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(trans : <span class="fn">∀ {<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">m</span> : <span class="fn">α</span>), <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">m</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">m</span></span></span></span></span></div></div><p>A variant of Zorn's lemma. If every nonempty chain of a nonempty type has an upper bound, then
there is a maximal element.</p></div></div><div class="decl" id="zorn_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Order/Zorn.lean#L99-L100">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Zorn.html#zorn_le"><span class="name">zorn_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">c</span> : <span class="fn"><a href="../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/Chain.html#IsChain">IsChain</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x1</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x2</span></span>)</span> <span class="fn">c</span></span> → <span class="fn"><a href="../.././Mathlib/Order/Bounds/Defs.html#BddAbove">BddAbove</a> <span class="fn">c</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">m</span> : <span class="fn">α</span>), <span class="fn"><a href="../.././Mathlib/Order/Max.html#IsMax">IsMax</a> <span class="fn">m</span></span></span></div></div></div></div><div class="decl" id="zorn_le_nonempty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Order/Zorn.lean#L102-L104">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Zorn.html#zorn_le_nonempty"><span class="name">zorn_le_nonempty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">c</span> : <span class="fn"><a href="../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/Chain.html#IsChain">IsChain</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x1</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x2</span></span>)</span> <span class="fn">c</span></span> → <span class="fn"><span class="fn"><span class="fn">c</span>.Nonempty</span> → <span class="fn"><a href="../.././Mathlib/Order/Bounds/Defs.html#BddAbove">BddAbove</a> <span class="fn">c</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">m</span> : <span class="fn">α</span>), <span class="fn"><a href="../.././Mathlib/Order/Max.html#IsMax">IsMax</a> <span class="fn">m</span></span></span></div></div></div></div><div class="decl" id="zorn_le₀"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Order/Zorn.lean#L106-L116">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Zorn.html#zorn_le₀"><span class="name">zorn_le₀</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ih : <span class="fn">∀ <span class="fn">c</span> ⊆ <span class="fn">s</span>, <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/Chain.html#IsChain">IsChain</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x1</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x2</span></span>)</span> <span class="fn">c</span></span> → <span class="fn">∃ <span class="fn">ub</span> ∈ <span class="fn">s</span>, <span class="fn">∀ <span class="fn">z</span> ∈ <span class="fn">c</span>, <span class="fn"><span class="fn">z</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">ub</span></span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">m</span> : <span class="fn">α</span>), <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Maximal">Maximal</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span>)</span> <span class="fn">m</span></span></span></div></div></div></div><div class="decl" id="zorn_le_nonempty₀"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Order/Zorn.lean#L118-L131">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Zorn.html#zorn_le_nonempty₀"><span class="name">zorn_le_nonempty₀</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ih : <span class="fn">∀ <span class="fn">c</span> ⊆ <span class="fn">s</span>, <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/Chain.html#IsChain">IsChain</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x1</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x2</span></span>)</span> <span class="fn">c</span></span> → <span class="fn">∀ <span class="fn">y</span> ∈ <span class="fn">c</span>, <span class="fn">∃ <span class="fn">ub</span> ∈ <span class="fn">s</span>, <span class="fn">∀ <span class="fn">z</span> ∈ <span class="fn">c</span>, <span class="fn"><span class="fn">z</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">ub</span></span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(hxs : <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">m</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Maximal">Maximal</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span>)</span> <span class="fn">m</span></span></span></span></div></div></div></div><div class="decl" id="zorn_le_nonempty_Ici₀"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Order/Zorn.lean#L133-L139">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Zorn.html#zorn_le_nonempty_Ici₀"><span class="name">zorn_le_nonempty_Ici₀</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(ih : <span class="fn">∀ <span class="fn">c</span> ⊆ <span class="fn"><a href="../.././Mathlib/Order/Interval/Set/Defs.html#Set.Ici">Set.Ici</a> <span class="fn">a</span></span>, <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/Chain.html#IsChain">IsChain</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x1</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x2</span></span>)</span> <span class="fn">c</span></span> → <span class="fn">∀ <span class="fn">y</span> ∈ <span class="fn">c</span>, <span class="fn">∃ (<span class="fn">ub</span> : <span class="fn">α</span>), <span class="fn">∀ <span class="fn">z</span> ∈ <span class="fn">c</span>, <span class="fn"><span class="fn">z</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">ub</span></span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(hax : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">m</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Mathlib/Order/Max.html#IsMax">IsMax</a> <span class="fn">m</span></span></span></span></div></div></div></div><div class="decl" id="zorn_subset"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Order/Zorn.lean#L143-L145">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Zorn.html#zorn_subset"><span class="name">zorn_subset</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(S : <span class="fn"><a href="../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ <span class="fn">c</span> ⊆ <span class="fn">S</span>, <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/Chain.html#IsChain">IsChain</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn"><a href="../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>) =&gt; <span class="fn"><span class="fn">x1</span> <a href="../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">x2</span></span>)</span> <span class="fn">c</span></span> → <span class="fn">∃ <span class="fn">ub</span> ∈ <span class="fn">S</span>, <span class="fn">∀ <span class="fn">s</span> ∈ <span class="fn">c</span>, <span class="fn"><span class="fn">s</span> <a href="../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">ub</span></span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">m</span> : <span class="fn"><a href="../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Maximal">Maximal</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><a href="../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">S</span></span>)</span> <span class="fn">m</span></span></span></div></div></div></div><div class="decl" id="zorn_subset_nonempty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Order/Zorn.lean#L147-L150">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Zorn.html#zorn_subset_nonempty"><span class="name">zorn_subset_nonempty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(S : <span class="fn"><a href="../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(H : <span class="fn">∀ <span class="fn">c</span> ⊆ <span class="fn">S</span>, <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/Chain.html#IsChain">IsChain</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn"><a href="../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>) =&gt; <span class="fn"><span class="fn">x1</span> <a href="../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">x2</span></span>)</span> <span class="fn">c</span></span> → <span class="fn"><span class="fn"><span class="fn">c</span>.Nonempty</span> → <span class="fn">∃ <span class="fn">ub</span> ∈ <span class="fn">S</span>, <span class="fn">∀ <span class="fn">s</span> ∈ <span class="fn">c</span>, <span class="fn"><span class="fn">s</span> <a href="../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">ub</span></span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn"><a href="../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hx : <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">S</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">m</span> : <span class="fn"><a href="../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">m</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Maximal">Maximal</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><a href="../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">S</span></span>)</span> <span class="fn">m</span></span></span></span></div></div></div></div><div class="decl" id="zorn_superset"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Order/Zorn.lean#L152-L154">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Zorn.html#zorn_superset"><span class="name">zorn_superset</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(S : <span class="fn"><a href="../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ <span class="fn">c</span> ⊆ <span class="fn">S</span>, <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/Chain.html#IsChain">IsChain</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn"><a href="../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>) =&gt; <span class="fn"><span class="fn">x1</span> <a href="../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">x2</span></span>)</span> <span class="fn">c</span></span> → <span class="fn">∃ <span class="fn">lb</span> ∈ <span class="fn">S</span>, <span class="fn">∀ <span class="fn">s</span> ∈ <span class="fn">c</span>, <span class="fn"><span class="fn">lb</span> <a href="../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">s</span></span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">m</span> : <span class="fn"><a href="../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Minimal">Minimal</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><a href="../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">S</span></span>)</span> <span class="fn">m</span></span></span></div></div></div></div><div class="decl" id="zorn_superset_nonempty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Order/Zorn.lean#L156-L159">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Zorn.html#zorn_superset_nonempty"><span class="name">zorn_superset_nonempty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(S : <span class="fn"><a href="../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(H : <span class="fn">∀ <span class="fn">c</span> ⊆ <span class="fn">S</span>, <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/Chain.html#IsChain">IsChain</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn"><a href="../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>) =&gt; <span class="fn"><span class="fn">x1</span> <a href="../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">x2</span></span>)</span> <span class="fn">c</span></span> → <span class="fn"><span class="fn"><span class="fn">c</span>.Nonempty</span> → <span class="fn">∃ <span class="fn">lb</span> ∈ <span class="fn">S</span>, <span class="fn">∀ <span class="fn">s</span> ∈ <span class="fn">c</span>, <span class="fn"><span class="fn">lb</span> <a href="../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">s</span></span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn"><a href="../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hx : <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">S</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">m</span> ⊆ <span class="fn">x</span>, <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Minimal">Minimal</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><a href="../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">S</span></span>)</span> <span class="fn">m</span></span></span></div></div></div></div><div class="decl" id="IsChain.exists_maxChain"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Order/Zorn.lean#L161-L180">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Zorn.html#IsChain.exists_maxChain"><span class="name">IsChain</span>.<span class="name">exists_maxChain</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn"><a href="../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hc : <span class="fn"><a href="../.././Mathlib/Order/Chain.html#IsChain">IsChain</a> <span class="fn">r</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">M</span> : <span class="fn"><a href="../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/Chain.html#IsMaxChain">IsMaxChain</a> <span class="fn">r</span> <span class="fn">M</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">c</span> <a href="../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">M</span></span></span></span></div></div><p>Every chain is contained in a maximal chain. This generalizes Hausdorff's maximality principle.</p></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>