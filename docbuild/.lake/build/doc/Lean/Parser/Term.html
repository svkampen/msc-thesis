<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Lean.Parser.Term</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Lean.Parser.Term";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Lean/Parser/Attr.html">Lean.Parser.Attr</a></li><li><a href="../.././Lean/Parser/Level.html">Lean.Parser.Level</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Lean.Parser.Term" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Command.commentBody"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Command</span>.<span class="name">commentBody</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Command.commentBody.parenthesizer"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Command</span>.<span class="name">commentBody</span>.<span class="name">parenthesizer</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Command.commentBody.formatter"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Command</span>.<span class="name">commentBody</span>.<span class="name">formatter</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Command.docComment"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Command</span>.<span class="name">docComment</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.tacticParser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">tacticParser</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.convParser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">convParser</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.sepByIndentSemicolon"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">sepByIndentSemicolon</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.sepBy1IndentSemicolon"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">sepBy1IndentSemicolon</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticSeq1Indented"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeq1Indented</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticSeqBracketed"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeqBracketed</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticSeq"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticSeqIndentGt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeqIndentGt</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.seq1"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">seq1</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.darrow"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">darrow</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.semicolonOrLinebreak"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">semicolonOrLinebreak</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.byTactic"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">byTactic</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.byTactic'"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">byTactic'</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.optSemicolon"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optSemicolon</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.ident"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">ident</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.num"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">num</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.scientific"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">scientific</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.str"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">str</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.char"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">char</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.type"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">type</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.sort"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">sort</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.prop"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">prop</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.hole"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">hole</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.syntheticHole"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">syntheticHole</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.omission"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">omission</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binderIdent"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderIdent</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.sorry"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">sorry</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.cdot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">cdot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.typeAscription"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">typeAscription</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.tuple"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">tuple</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.paren"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">paren</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.anonymousCtor"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">anonymousCtor</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.optIdent"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optIdent</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.fromTerm"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">fromTerm</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.showRhs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">showRhs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.sufficesDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">sufficesDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.suffices"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">suffices</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.show"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">show</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.structInstArrayRef"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstArrayRef</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.structInstLVal"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstLVal</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.structInstField"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstField</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.structInstFieldAbbrev"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstFieldAbbrev</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.optEllipsis"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optEllipsis</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.structInst"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInst</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.typeSpec"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">typeSpec</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.optType"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optType</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.explicit"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">explicit</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.inaccessible"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">inaccessible</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binderType"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderType</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binderTactic"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderTactic</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binderDefault"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderDefault</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binderDefault.parenthesizer"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderDefault</span>.<span class="name">parenthesizer</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.explicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">explicitBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.implicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">implicitBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.strictImplicitLeftBracket"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">strictImplicitLeftBracket</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.strictImplicitRightBracket"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">strictImplicitRightBracket</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.strictImplicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">strictImplicitBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.instBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">instBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.bracketedBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">bracketedBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.depArrow"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">depArrow</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.forall"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">forall</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.matchAlt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchAlt</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.matchAltExpr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchAltExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.matchAlts"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchAlts</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.matchDiscr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchDiscr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.trueVal"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">trueVal</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.falseVal"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">falseVal</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.generalizingParam"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">generalizingParam</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.motive"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">motive</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.match"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">match</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.nomatch"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">nomatch</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.nofun"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">nofun</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.funImplicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">funImplicitBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.funStrictImplicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">funStrictImplicitBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.funBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">funBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.basicFun"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">basicFun</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.fun"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">fun</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.optExprPrecedence"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optExprPrecedence</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.withAnonymousAntiquot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">withAnonymousAntiquot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.leading_parser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">leading_parser</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.trailing_parser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">trailing_parser</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.borrowed"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">borrowed</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.quotedName"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">quotedName</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.doubleQuotedName"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">doubleQuotedName</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letIdBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letIdBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letIdLhs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letIdLhs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letIdDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letIdDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letPatDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letPatDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letEqnsDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letEqnsDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.let"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">let</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.let_fun"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">let_fun</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.let_delayed"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">let_delayed</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.let_tmp"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">let_tmp</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.haveId"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveId</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.haveIdLhs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveIdLhs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.haveIdDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveIdDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.haveEqnsDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveEqnsDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.haveDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.have"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">have</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.haveI"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveI</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letI"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letI</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.scoped"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">scoped</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.local"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">local</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.attrKind"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">attrKind</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.attrInstance"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">attrInstance</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.attributes"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">attributes</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Termination.terminationBy"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Termination</span>.<span class="name">terminationBy</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Termination.terminationBy?"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Termination</span>.<span class="name">terminationBy?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Termination.decreasingBy"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Termination</span>.<span class="name">decreasingBy</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Termination.suffix"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Termination</span>.<span class="name">suffix</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letRecDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letRecDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letRecDecls"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letRecDecls</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letrec"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letrec</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.whereDecls"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">whereDecls</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.matchAltsWhereDecls"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchAltsWhereDecls</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.noindex"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">noindex</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.unsafe"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">unsafe</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binrel"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binrel</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binrel_no_prop"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binrel_no_prop</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binop"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binop</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binop_lazy"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binop_lazy</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.leftact"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">leftact</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.rightact"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">rightact</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.unop"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">unop</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.forInMacro"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">forInMacro</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.forInMacro'"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">forInMacro'</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.declName"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">declName</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.withDeclName"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">withDeclName</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.typeOf"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">typeOf</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.ensureTypeOf"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">ensureTypeOf</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.ensureExpectedType"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">ensureExpectedType</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.noImplicitLambda"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">noImplicitLambda</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.clear"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">clear</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letMVar"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letMVar</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.waitIfTypeMVar"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">waitIfTypeMVar</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.waitIfTypeContainsMVar"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">waitIfTypeContainsMVar</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.waitIfContainsMVar"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">waitIfContainsMVar</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.defaultOrOfNonempty"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">defaultOrOfNonempty</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.noErrorIfUnused"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">noErrorIfUnused</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.namedArgument"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">namedArgument</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.ellipsis"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">ellipsis</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.argument"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">argument</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.app"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">app</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.proj"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">proj</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.completion"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">completion</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.arrow"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">arrow</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.identProjKind"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">identProjKind</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.isIdent"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">isIdent</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.explicitUniv"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">explicitUniv</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.namedPattern"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">namedPattern</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.pipeProj"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">pipeProj</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.pipeCompletion"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">pipeCompletion</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.subst"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">subst</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.bracketedBinderF"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">bracketedBinderF</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean_1"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean_1</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.panic"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">panic</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.unreachable"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">unreachable</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.dbgTrace"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">dbgTrace</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.assert"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">assert</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.macroArg"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">macroArg</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.macroDollarArg"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">macroDollarArg</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.macroLastArg"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">macroLastArg</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.stateRefT"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">stateRefT</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.dynamicQuot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">dynamicQuot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.dotIdent"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">dotIdent</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.showTermElabImpl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">showTermElabImpl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.matchExprPat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchExprPat</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.matchExprAlt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchExprAlt</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.matchExprElseAlt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchExprElseAlt</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.matchExprAlts"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchExprAlts</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.matchExpr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letExpr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.quot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">quot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.quotSeq"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">quotSeq</span></a></div></nav><main>
<div class="decl" id="Lean.Parser.Command.commentBody"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L14-L15">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Command.commentBody"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Command</span>.<span class="name">commentBody</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Command.commentBody" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Command.commentBody.parenthesizer"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L17-L18">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Command.commentBody.parenthesizer"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Command</span>.<span class="name">commentBody</span>.<span class="name">parenthesizer</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/PrettyPrinter/Parenthesizer.html#Lean.PrettyPrinter.Parenthesizer">Lean.PrettyPrinter.Parenthesizer</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Command.commentBody.parenthesizer">Lean.Parser.Command.commentBody.parenthesizer</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Lean/PrettyPrinter/Parenthesizer.html#Lean.PrettyPrinter.Parenthesizer.visitToken">Lean.PrettyPrinter.Parenthesizer.visitToken</a></span></li></ul></details><details id="instances-for-list-Lean.Parser.Command.commentBody.parenthesizer" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Command.commentBody.formatter"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L19-L20">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Command.commentBody.formatter"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Command</span>.<span class="name">commentBody</span>.<span class="name">formatter</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter">Lean.PrettyPrinter.Formatter</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Command.commentBody.formatter">Lean.Parser.Command.commentBody.formatter</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter.visitAtom">Lean.PrettyPrinter.Formatter.visitAtom</a> <a href="../.././Init/Prelude.html#Lean.Name.anonymous">Lean.Name.anonymous</a></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Command.commentBody.formatter" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Command.docComment"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L22-L29">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Command.docComment"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Command</span>.<span class="name">docComment</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Command.docComment">docComment</a></code> parses a &quot;documentation comment&quot; like <code>/-- foo -/</code>. This is not treated like
a regular comment (that is, as whitespace); it is parsed and forms part of the syntax tree structure.</p><p>A <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Command.docComment">docComment</a></code> node contains a <code>/--</code> atom and then the remainder of the comment, <code>foo -/</code> in this
example. Use <code>TSyntax.getDocString</code> to extract the body text from a doc string syntax node.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Command.docComment" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.tacticParser"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L36-L37">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.tacticParser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">tacticParser</span></a></span><span class="decl_args">
<span class="fn">(rbp : <a href="../.././Init/Prelude.html#Nat">Nat</a> := <span class="fn">0</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.tacticParser">Lean.Parser.tacticParser</a> <span class="fn">rbp</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.categoryParser">Lean.Parser.categoryParser</a> <span class="fn">`tactic</span> <span class="fn">rbp</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.tacticParser" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.convParser"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L39-L40">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.convParser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">convParser</span></a></span><span class="decl_args">
<span class="fn">(rbp : <a href="../.././Init/Prelude.html#Nat">Nat</a> := <span class="fn">0</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.convParser">Lean.Parser.convParser</a> <span class="fn">rbp</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.categoryParser">Lean.Parser.categoryParser</a> <span class="fn">`conv</span> <span class="fn">rbp</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.convParser" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.sepByIndentSemicolon"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L44-L55">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.sepByIndentSemicolon"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">sepByIndentSemicolon</span></a></span><span class="decl_args">
<span class="fn">(p : <a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>sepByIndentSemicolon(p)</code> parses a sequence of <code>p</code> optionally followed by <code>;</code>,
similar to <code>manyIndent(p &quot;;&quot;?)</code>, except that if two occurrences of <code>p</code> occur on the same line,
the <code>;</code> is mandatory. This is used by tactic parsing, so that</p><pre><code>example := by
  skip
  skip
</code></pre><p>is legal, but <code>by skip skip</code> is not - it must be written as <code>by skip; skip</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.sepByIndentSemicolon">Lean.Parser.Tactic.sepByIndentSemicolon</a> <span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lean/Parser/Extra.html#Lean.Parser.sepByIndent">Lean.Parser.sepByIndent</a> <span class="fn">p</span> <span class="fn">&quot;; &quot;</span> <span class="fn">(<a href="../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot;; &quot;</span>)</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.sepByIndentSemicolon" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.sepBy1IndentSemicolon"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L57-L68">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.sepBy1IndentSemicolon"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">sepBy1IndentSemicolon</span></a></span><span class="decl_args">
<span class="fn">(p : <a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>sepBy1IndentSemicolon(p)</code> parses a (nonempty) sequence of <code>p</code> optionally followed by <code>;</code>,
similar to <code>many1Indent(p &quot;;&quot;?)</code>, except that if two occurrences of <code>p</code> occur on the same line,
the <code>;</code> is mandatory. This is used by tactic parsing, so that</p><pre><code>example := by
  skip
  skip
</code></pre><p>is legal, but <code>by skip skip</code> is not - it must be written as <code>by skip; skip</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.sepBy1IndentSemicolon">Lean.Parser.Tactic.sepBy1IndentSemicolon</a> <span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lean/Parser/Extra.html#Lean.Parser.sepBy1Indent">Lean.Parser.sepBy1Indent</a> <span class="fn">p</span> <span class="fn">&quot;; &quot;</span> <span class="fn">(<a href="../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot;; &quot;</span>)</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.sepBy1IndentSemicolon" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticSeq1Indented"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L74-L75">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeq1Indented"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeq1Indented</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticSeq1Indented" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticSeqBracketed"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L76-L79">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeqBracketed"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeqBracketed</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>The syntax <code>{ tacs }</code> is an alternative syntax for <code>· tacs</code>.
It runs the tactics in sequence, and fails if the goal is not solved.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticSeqBracketed" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticSeq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L81-L84">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeq"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A sequence of tactics in brackets, or a delimiter-free indented sequence of tactics.
Delimiter-free indentation is determined by the <em>first</em> tactic of the sequence.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticSeq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticSeqIndentGt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L86-L90">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeqIndentGt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeqIndentGt</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Same as [<code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeq">tacticSeq</a></code>] but requires delimiter-free tactic sequence to have strict indentation.
The strict indentation requirement only apply to <em>nested</em> <code>by</code>s, as top-level <code>by</code>s do not have a
position set.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticSeqIndentGt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.seq1"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L93-L94">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.seq1"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">seq1</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.seq1">Lean.Parser.Tactic.seq1</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.node">Lean.Parser.node</a> <span class="fn">`Lean.Parser.Tactic.seq1</span>
    <span class="fn">(<a href="../.././Lean/Parser/Basic.html#Lean.Parser.sepBy1">Lean.Parser.sepBy1</a> <span class="fn">Lean.Parser.tacticParser</span> <span class="fn">&quot;;\n&quot;</span> <span class="fn">(<a href="../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot;;\n&quot;</span>)</span> <a href="../.././Init/Prelude.html#Bool.true">true</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.seq1" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.darrow"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L98-L98">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.darrow"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">darrow</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.darrow">Lean.Parser.darrow</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot; =&gt; &quot;</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.darrow" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.semicolonOrLinebreak"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L99-L99">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.semicolonOrLinebreak"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">semicolonOrLinebreak</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.semicolonOrLinebreak">Lean.Parser.semicolonOrLinebreak</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot;;&quot;</span></span> &lt;|&gt; <span class="fn"><span class="fn">Lean.Parser.checkLinebreakBefore</span> &gt;&gt; <a href="../.././Lean/Parser/Basic.html#Lean.Parser.pushNone">Lean.Parser.pushNone</a></span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.semicolonOrLinebreak" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Built-in-parsers">Built-in parsers <a class="hover-link" href="#Built-in-parsers">#</a></h1></div><div class="decl" id="Lean.Parser.Term.byTactic"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L106-L108">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.byTactic"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">byTactic</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>by tac</code> constructs a term of the expected type by running the tactic(s) <code>tac</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.byTactic" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.byTactic'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L116-L117">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.byTactic'"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">byTactic'</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.byTactic'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.optSemicolon"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L120-L121">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.optSemicolon"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optSemicolon</span></a></span><span class="decl_args">
<span class="fn">(p : <a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.optSemicolon">Lean.Parser.Term.optSemicolon</a> <span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lean/Parser/Extra.html#Lean.Parser.ppDedent">Lean.Parser.ppDedent</a> <span class="fn">(<a href="../.././Lean/Parser/Term.html#Lean.Parser.semicolonOrLinebreak">Lean.Parser.semicolonOrLinebreak</a> &gt;&gt; <span class="fn"><a href="../.././Lean/Parser/Extra.html#Lean.Parser.ppLine">Lean.Parser.ppLine</a> &gt;&gt; <span class="fn">p</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.optSemicolon" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.ident"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L124-L125">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.ident"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">ident</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.ident">Lean.Parser.Term.ident</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.checkPrec">Lean.Parser.checkPrec</a> <a href="../.././Lean/Parser/Types.html#Lean.Parser.maxPrec">Lean.Parser.maxPrec</a></span> &gt;&gt; <a href="../.././Lean/Parser/Extra.html#Lean.Parser.ident">Lean.Parser.ident</a></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.ident" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.num"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L126-L127">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.num"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">num</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.num">Lean.Parser.Term.num</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.checkPrec">Lean.Parser.checkPrec</a> <a href="../.././Lean/Parser/Types.html#Lean.Parser.maxPrec">Lean.Parser.maxPrec</a></span> &gt;&gt; <a href="../.././Lean/Parser/Extra.html#Lean.Parser.numLit">Lean.Parser.numLit</a></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.num" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.scientific"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L128-L129">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.scientific"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">scientific</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.scientific">Lean.Parser.Term.scientific</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.checkPrec">Lean.Parser.checkPrec</a> <a href="../.././Lean/Parser/Types.html#Lean.Parser.maxPrec">Lean.Parser.maxPrec</a></span> &gt;&gt; <a href="../.././Lean/Parser/Extra.html#Lean.Parser.scientificLit">Lean.Parser.scientificLit</a></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.scientific" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.str"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L130-L131">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.str"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">str</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.str">Lean.Parser.Term.str</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.checkPrec">Lean.Parser.checkPrec</a> <a href="../.././Lean/Parser/Types.html#Lean.Parser.maxPrec">Lean.Parser.maxPrec</a></span> &gt;&gt; <a href="../.././Lean/Parser/Extra.html#Lean.Parser.strLit">Lean.Parser.strLit</a></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.str" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.char"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L132-L133">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.char"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">char</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.char">Lean.Parser.Term.char</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.checkPrec">Lean.Parser.checkPrec</a> <a href="../.././Lean/Parser/Types.html#Lean.Parser.maxPrec">Lean.Parser.maxPrec</a></span> &gt;&gt; <a href="../.././Lean/Parser/Extra.html#Lean.Parser.charLit">Lean.Parser.charLit</a></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.char" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.type"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L134-L136">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.type"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">type</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A type universe. <code>Type ≡ Type 0</code>, <code>Type u ≡ Sort (u + 1)</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.type" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.sort"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L137-L139">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.sort"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">sort</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A specific universe in Lean's infinite hierarchy of universes.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.sort" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.prop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L140-L142">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.prop"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">prop</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>The universe of propositions. <code>Prop ≡ Sort 0</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.prop" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.hole"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L143-L160">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.hole"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">hole</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A <em>hole</em> (or <em>placeholder term</em>), which stands for an unknown term that is expected to be inferred based on context.
For example, in <code>@id _ <a href="../.././Init/Prelude.html#Nat.zero">Nat.zero</a></code>, the <code>_</code> must be the type of <code><a href="../.././Init/Prelude.html#Nat.zero">Nat.zero</a></code>, which is <code><a href="../.././Init/Prelude.html#Nat">Nat</a></code>.</p><p>The way this works is that holes create fresh metavariables.
The elaborator is allowed to assign terms to metavariables while it is checking definitional equalities.
This is often known as <em>unification</em>.</p><p>Normally, all holes must be solved for. However, there are a few contexts where this is not necessary:</p><ul>
<li>In <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.match">match</a></code> patterns, holes are catch-all patterns.</li>
<li>In some tactics, such as <code>refine'</code> and <code>apply</code>, unsolved-for placeholders become new goals.</li>
</ul><p>Related concept: implicit parameters are automatically filled in with holes during the elaboration process.</p><p>See also <code>?m</code> syntax (synthetic holes).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.hole" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.syntheticHole"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L161-L206">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.syntheticHole"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">syntheticHole</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A <em>synthetic hole</em> (or <em>synthetic placeholder</em>), which stands for an unknown term that should be synthesized using tactics.</p><ul>
<li><code>?_</code> creates a fresh metavariable with an auto-generated name.</li>
<li><code>?m</code> either refers to a pre-existing metavariable named <code>m</code> or creates a fresh metavariable with that name.</li>
</ul><p>In particular, the synthetic hole syntax creates &quot;synthetic opaque metavariables&quot;,
the same kind of metavariable used to represent goals in the tactic state.</p><p>Synthetic holes are similar to holes in that <code>_</code> also creates metavariables,
but synthetic opaque metavariables have some different properties:</p><ul>
<li>In tactics such as <code>refine</code>, only synthetic holes yield new goals.</li>
<li>During elaboration, unification will not solve for synthetic opaque metavariables, they are &quot;opaque&quot;.
This is to prevent counterintuitive behavior such as disappearing goals.</li>
<li>When synthetic holes appear under binders, they capture local variables using a more complicated mechanism known as delayed assignment.</li>
</ul><h2 class="markdown-heading" id="Delayed-assigned-metavariables">Delayed assigned metavariables <a class="hover-link" href="#Delayed-assigned-metavariables">#</a></h2><p>This section gives an overview of some technical details of synthetic holes, which you should feel free to skip.
Understanding delayed assignments is mainly useful for those who are working on tactics and other metaprogramming.
It is included here until there is a suitable place for it in the reference manual.</p><p>When a synthetic hole appears under a binding construct, such as for example <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fun">fun</a> (x : α) (y : β) =&gt; ?s</code>,
the system creates a <em>delayed assignment</em>. This consists of</p><ol>
<li>A metavariable <code>?m</code> of type <code>(x : α) → (y : β) → γ x y</code> whose local context is the local context outside the <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fun">fun</a></code>,
where <code>γ x y</code> is the type of <code>?s</code>. Recall that <code>x</code> and <code>y</code> appear in the local context of <code>?s</code>.</li>
<li>A delayed assigment record associating <code>?m</code> to <code>?s</code> and the variables <code>#[x, y]</code> in the local context of <code>?s</code></li>
</ol><p>Then, this function elaborates as <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fun">fun</a> (x : α) (y : β) =&gt; ?m x y</code>, where one should understand <code>x</code> and <code>y</code> here
as being De Bruijn indexes, since Lean uses the locally nameless encoding of lambda calculus.</p><p>Once <code>?s</code> is fully solved for, in the sense that after metavariable instantiation it is a metavariable-free term <code>e</code>,
then we can make the assignment <code>?m := <a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fun">fun</a> (x' : α) (y' : β) =&gt; e[x := x', y := y']</code>.
(Implementation note: Lean only instantiates full applications <code>?m x' y'</code> of delayed assigned metavariables, to skip forming this function.)
This delayed assignment mechanism is essential to the operation of basic tactics like <code>intro</code>,
and a good mental model is that it is a way to &quot;apply&quot; the metavariable <code>?s</code> by substituting values in for some of its local variables.
While it would be easier to immediately assign <code>?s := ?m x y</code>,
delayed assigment preserves <code>?s</code> as an unsolved-for metavariable with a local context that still contains <code>x</code> and <code>y</code>,
which is exactly what tactics like <code>intro</code> need.</p><p>By default, delayed assigned metavariables pretty print with what they are delayed assigned to.
The delayed assigned metavariables themselves can be pretty printed using <code>set_option pp.mvars.delayed true</code>.</p><p>For more information, see the &quot;Gruesome details&quot; module docstrings in <code><a href="../.././Lean/MetavarContext.html#Lean.MetavarContext">Lean.MetavarContext</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.syntheticHole" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.omission"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L207-L216">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.omission"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">omission</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>The <code>⋯</code> term denotes a term that was omitted by the pretty printer.
The presence of <code>⋯</code> in pretty printer output is controlled by the <code>pp.deepTerms</code> and <code>pp.proofs</code> options,
and these options can be further adjusted using <code>pp.deepTerms.threshold</code> and <code>pp.proofs.threshold</code>.</p><p>It is only meant to be used for pretty printing.
However, in case it is copied and pasted from the Infoview, <code>⋯</code> logs a warning and elaborates like <code>_</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.omission" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binderIdent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L217-L217">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binderIdent"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderIdent</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binderIdent">Lean.Parser.Term.binderIdent</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.ident">Lean.Parser.Term.ident</a> &lt;|&gt; <a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.hole">Lean.Parser.Term.hole</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.binderIdent" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.sorry"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L218-L220">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.sorry"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">sorry</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A temporary placeholder for a missing proof or value.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.sorry" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.cdot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L221-L226">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.cdot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">cdot</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A placeholder for an implicit lambda abstraction's variable. The lambda abstraction is scoped to the surrounding parentheses.
For example, <code>(· + ·)</code> is equivalent to <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fun">fun</a> x y =&gt; x + y</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.cdot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.typeAscription"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L227-L234">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.typeAscription"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">typeAscription</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Type ascription notation: <code>(0 : Int)</code> instructs Lean to process <code>0</code> as a value of type <code><a href="../.././Init/Data/Int/Basic.html#Int">Int</a></code>.
An empty type ascription <code>(e :)</code> elaborates <code>e</code> without the expected type.
This is occasionally useful when Lean's heuristics for filling arguments from the expected type
do not yield the right result.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.typeAscription" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.tuple"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L236-L238">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.tuple"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">tuple</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Tuple notation; <code>()</code> is short for <code><a href="../.././Init/Prelude.html#Unit.unit">Unit.unit</a></code>, <code>(a, b, c)</code> for <code><a href="../.././Init/Prelude.html#Prod.mk">Prod.mk</a> a (Prod.mk b c)</code>, etc.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.tuple" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.paren"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L240-L250">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.paren"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">paren</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Parentheses, used for grouping expressions (e.g., <code>a * (b + c)</code>).
Can also be used for creating simple functions when combined with <code>·</code>. Here are some examples:</p><ul>
<li><code>(· + 1)</code> is shorthand for <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fun">fun</a> x =&gt; x + 1</code></li>
<li><code>(· + ·)</code> is shorthand for <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fun">fun</a> x y =&gt; x + y</code></li>
<li><code>(f · a b)</code> is shorthand for <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fun">fun</a> x =&gt; f x a b</code></li>
<li><code>(h (· + 1) ·)</code> is shorthand for <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fun">fun</a> x =&gt; h (fun y =&gt; y + 1) x</code></li>
<li>also applies to other parentheses-like notations such as <code>(·, 1)</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.paren" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.anonymousCtor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L251-L259">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.anonymousCtor"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">anonymousCtor</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>The <em>anonymous constructor</em> <code>⟨e, ...⟩</code> is equivalent to <code>c e ...</code> if the
expected type is an inductive type with a single constructor <code>c</code>.
If more terms are given than <code>c</code> has parameters, the remaining arguments
are turned into a new anonymous constructor application. For example,
<code>⟨a, b, c⟩ : α × (β × γ)</code> is equivalent to <code>⟨a, ⟨b, c⟩⟩</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.anonymousCtor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.optIdent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L260-L261">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.optIdent"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optIdent</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.optIdent">Lean.Parser.Term.optIdent</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Lean/Parser/Extra.html#Lean.Parser.optional">Lean.Parser.optional</a> <span class="fn">(<a href="../.././Lean/Parser/Basic.html#Lean.Parser.atomic">Lean.Parser.atomic</a> <span class="fn">(<a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.ident">Lean.Parser.Term.ident</a> &gt;&gt; <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot; : &quot;</span></span>)</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.optIdent" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.fromTerm"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L262-L263">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fromTerm"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">fromTerm</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.fromTerm" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.showRhs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L264-L264">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.showRhs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">showRhs</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.showRhs">Lean.Parser.Term.showRhs</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fromTerm">Lean.Parser.Term.fromTerm</a> &lt;|&gt; <a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.byTactic'">Lean.Parser.Term.byTactic'</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.showRhs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.sufficesDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L265-L268">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.sufficesDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">sufficesDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.sufficesDecl">sufficesDecl</a></code> represents everything that comes after the <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.suffices">suffices</a></code> keyword:
an optional <code>x :</code>, then a term <code>ty</code>, then <code>from val</code> or <code>by tac</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.sufficesDecl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.suffices"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L269-L270">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.suffices"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">suffices</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.suffices" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.show"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L271-L271">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.show"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">show</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.show" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.structInstArrayRef"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L272-L273">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.structInstArrayRef"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstArrayRef</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.structInstArrayRef" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.structInstLVal"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L274-L276">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.structInstLVal"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstLVal</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.structInstLVal" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.structInstField"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L277-L278">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.structInstField"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstField</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.structInstField" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.structInstFieldAbbrev"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L279-L281">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.structInstFieldAbbrev"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstFieldAbbrev</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.structInstFieldAbbrev" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.optEllipsis"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L282-L283">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.optEllipsis"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optEllipsis</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.optEllipsis" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.structInst"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L284-L297">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.structInst"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInst</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Structure instance. <code>{ x := e, ... }</code> assigns <code>e</code> to field <code>x</code>, which may be
inherited. If <code>e</code> is itself a variable called <code>x</code>, it can be elided:
<code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fun">fun</a> y =&gt; { x := 1, y }</code>.
A <em>structure update</em> of an existing value can be given via <code>with</code>:
<code>{ point with x := 1 }</code>.
The structure type can be specified if not inferable:
<code>{ x := 1, y := 2 : Point }</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.structInst" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.typeSpec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L298-L298">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.typeSpec"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">typeSpec</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.typeSpec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.optType"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L299-L299">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.optType"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optType</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.optType">Lean.Parser.Term.optType</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lean/Parser/Extra.html#Lean.Parser.optional">Lean.Parser.optional</a> <a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.typeSpec">Lean.Parser.Term.typeSpec</a></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.optType" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.explicit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L300-L305">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.explicit"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">explicit</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>@x</code> disables automatic insertion of implicit parameters of the constant <code>x</code>.
<code>@e</code> for any term <code>e</code> also disables the insertion of implicit lambdas at this position.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.explicit" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.inaccessible"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L306-L311">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.inaccessible"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">inaccessible</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>.(e)</code> marks an &quot;inaccessible pattern&quot;, which does not influence evaluation of the pattern match, but may be necessary for type-checking.
In contrast to regular patterns, <code>e</code> may be an arbitrary term of the appropriate type.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.inaccessible" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binderType"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L312-L313">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binderType"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderType</span></a></span><span class="decl_args">
<span class="fn">(requireType : <a href="../.././Init/Prelude.html#Bool">Bool</a> := <a href="../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.binderType" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binderTactic"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L314-L315">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binderTactic"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderTactic</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.binderTactic" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binderDefault"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L316-L317">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binderDefault"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderDefault</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.binderDefault" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binderDefault.parenthesizer"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L320-L327">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binderDefault.parenthesizer"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderDefault</span>.<span class="name">parenthesizer</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/PrettyPrinter/Parenthesizer.html#Lean.PrettyPrinter.Parenthesizer">Lean.PrettyPrinter.Parenthesizer</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.binderDefault.parenthesizer" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.explicitBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L329-L334">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.explicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">explicitBinder</span></a></span><span class="decl_args">
<span class="fn">(requireType : <a href="../.././Init/Prelude.html#Bool">Bool</a> := <a href="../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Explicit binder, like <code>(x y : A)</code> or <code>(x y)</code>.
Default values can be specified using <code>(x : A := v)</code> syntax, and tactics using <code>(x : A := by tac)</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.explicitBinder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.implicitBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L335-L345">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.implicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">implicitBinder</span></a></span><span class="decl_args">
<span class="fn">(requireType : <a href="../.././Init/Prelude.html#Bool">Bool</a> := <a href="../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Implicit binder, like <code>{x y : A}</code> or <code>{x y}</code>.
In regular applications, whenever all parameters before it have been specified,
then a <code>_</code> placeholder is automatically inserted for this parameter.
Implicit parameters should be able to be determined from the other arguments and the return type
by unification.</p><p>In <code>@</code> explicit mode, implicit binders behave like explicit binders.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.implicitBinder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.strictImplicitLeftBracket"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L346-L346">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitLeftBracket"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">strictImplicitLeftBracket</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitLeftBracket">Lean.Parser.Term.strictImplicitLeftBracket</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">(<span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.atomic">Lean.Parser.atomic</a> <span class="fn">(<a href="../.././Lean/Parser/Extra.html#Lean.Parser.group">Lean.Parser.group</a> <span class="fn">(<span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot;{&quot;</span></span> &gt;&gt; <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot;{&quot;</span></span>)</span>)</span></span> &lt;|&gt; <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot;⦃&quot;</span></span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.strictImplicitLeftBracket" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.strictImplicitRightBracket"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L347-L347">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitRightBracket"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">strictImplicitRightBracket</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitRightBracket">Lean.Parser.Term.strictImplicitRightBracket</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">(<span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.atomic">Lean.Parser.atomic</a> <span class="fn">(<a href="../.././Lean/Parser/Extra.html#Lean.Parser.group">Lean.Parser.group</a> <span class="fn">(<span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot;}&quot;</span></span> &gt;&gt; <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot;}&quot;</span></span>)</span>)</span></span> &lt;|&gt; <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot;⦄&quot;</span></span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.strictImplicitRightBracket" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.strictImplicitBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L348-L363">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">strictImplicitBinder</span></a></span><span class="decl_args">
<span class="fn">(requireType : <a href="../.././Init/Prelude.html#Bool">Bool</a> := <a href="../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Strict-implicit binder, like <code>⦃x y : A⦄</code> or <code>⦃x y⦄</code>.
In contrast to <code>{ ... }</code> implicit binders, strict-implicit binders do not automatically insert
a <code>_</code> placeholder until at least one subsequent explicit parameter is specified.
Do <em>not</em> use strict-implicit binders unless there is a subsequent explicit parameter.
Assuming this rule is followed, for fully applied expressions implicit and strict-implicit binders have the same behavior.</p><p>Example: If <code>h : ∀ ⦃x : A⦄, x ∈ s → p x</code> and <code>hs : y ∈ s</code>,
then <code>h</code> by itself elaborates to itself without inserting <code>_</code> for the <code>x : A</code> parameter,
and <code>h hs</code> has type <code>p y</code>.
In contrast, if <code>h' : ∀ {x : A}, x ∈ s → p x</code>, then <code>h</code> by itself elaborates to have type <code>?m ∈ s → p ?m</code>
with <code>?m</code> a fresh metavariable.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.strictImplicitBinder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.instBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L364-L372">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.instBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">instBinder</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Instance-implicit binder, like <code>[C]</code> or <code>[inst : C]</code>.
In regular applications without <code>@</code> explicit mode, it is automatically inserted
and solved for by typeclass inference for the specified class <code>C</code>.
In <code>@</code> explicit mode, if <code>_</code> is used for an instance-implicit parameter, then it is still solved for by typeclass inference;
use <code>(_)</code> to inhibit this and have it be solved for by unification instead, like an implicit argument.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.instBinder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.bracketedBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L373-L382">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">bracketedBinder</span></a></span><span class="decl_args">
<span class="fn">(requireType : <a href="../.././Init/Prelude.html#Bool">Bool</a> := <a href="../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinder">bracketedBinder</a></code> matches any kind of binder group that uses some kind of brackets:</p><ul>
<li>An explicit binder like <code>(x y : A)</code></li>
<li>An implicit binder like <code>{x y : A}</code></li>
<li>A strict implicit binder, <code>⦃y z : A⦄</code> or its ASCII alternative <code>{{y z : A}}</code></li>
<li>An instance binder <code>[A]</code> or <code>[x : A]</code> (multiple variables are not allowed here)</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.bracketedBinder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.depArrow"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L399-L400">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.depArrow"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">depArrow</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.depArrow" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.forall"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L402-L406">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.forall"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">forall</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.forall" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.matchAlt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L408-L413">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchAlt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchAlt</span></a></span><span class="decl_args">
<span class="fn">(rhsParser : <a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a> := <span class="fn">Lean.Parser.termParser</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.matchAlt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.matchAltExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L414-L417">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchAltExpr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchAltExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Useful for syntax quotations. Note that generic patterns such as <code>`(matchAltExpr| | ... =&gt; $rhs)</code> should also
work with other <code>rhsParser</code>s (of arity 1).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchAltExpr">Lean.Parser.Term.matchAltExpr</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">Lean.Parser.Term.matchAlt</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.matchAltExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L419-L420">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Coe.html#Coe">Coe</a> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">`Lean.Parser.Term.matchAltExpr</span>)</span> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">`Lean.Parser.Term.matchAlt</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean">Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">coe</span> := <span class="fn">fun (<span class="fn">stx</span> : <span class="fn"><a href="../.././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">`Lean.Parser.Term.matchAltExpr</span></span>) =&gt; <span class="fn">{ <span class="fn">raw</span> := <span class="fn"><span class="fn">stx</span>.raw</span> }</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Term.matchAlts"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L422-L423">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchAlts"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchAlts</span></a></span><span class="decl_args">
<span class="fn">(rhsParser : <a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a> := <span class="fn">Lean.Parser.termParser</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.matchAlts" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.matchDiscr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L425-L428">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchDiscr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchDiscr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchDiscr">matchDiscr</a></code> matches a &quot;match discriminant&quot;, either <code>h : tm</code> or <code>tm</code>, used in <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.match">match</a></code> as
<code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.match">match</a> h1 : e1, e2, h3 : e3 with ...</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.matchDiscr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.trueVal"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L430-L430">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.trueVal"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">trueVal</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.trueVal" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.falseVal"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L431-L431">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.falseVal"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">falseVal</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.falseVal" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.generalizingParam"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L432-L434">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.generalizingParam"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">generalizingParam</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.generalizingParam" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.motive"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L436-L438">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.motive"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">motive</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.motive" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.match"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L440-L475">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.match"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">match</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Pattern matching. <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.match">match</a> e, ... with | p, ... =&gt; f | ...</code> matches each given
term <code>e</code> against each pattern <code>p</code> of a match alternative. When all patterns
of an alternative match, the <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.match">match</a></code> term evaluates to the value of the
corresponding right-hand side <code>f</code> with the pattern variables bound to the
respective matched values.
If used as <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.match">match</a> h : e, ... with | p, ... =&gt; f | ...</code>, <code>h : e = p</code> is available
within <code>f</code>.</p><p>When not constructing a proof, <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.match">match</a></code> does not automatically substitute variables
matched on in dependent variables' types. Use <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.match">match</a> (generalizing := true) ...</code> to
enforce this.</p><p>Syntax quotations can also be used in a pattern match.
This matches a <code>Syntax</code> value against quotations, pattern variables, or <code>_</code>.</p><p>Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.</p><p><code>Syntax.atom</code>s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in</p><pre><code class="language-lean">syntax &quot;c&quot; (&quot;foo&quot; &lt;|&gt; &quot;bar&quot;) ...
</code></pre><p><code>foo</code> and <code>bar</code> are indistinguishable during matching, but in</p><pre><code class="language-lean">syntax foo := &quot;foo&quot;
syntax &quot;c&quot; (foo &lt;|&gt; &quot;bar&quot;) ...
</code></pre><p>they are not.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.match" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.nomatch"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L476-L481">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.nomatch"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">nomatch</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Empty match/ex falso. <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.nomatch">nomatch</a> e</code> is of arbitrary type <code>α : Sort u</code> if
Lean can show that an empty set of patterns is exhaustive given <code>e</code>'s type,
e.g. because it has no constructors.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.nomatch" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.nofun"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L483-L483">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.nofun"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">nofun</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.nofun" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.funImplicitBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L485-L486">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.funImplicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">funImplicitBinder</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.funImplicitBinder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.funStrictImplicitBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L487-L491">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.funStrictImplicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">funStrictImplicitBinder</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.funStrictImplicitBinder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.funBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L492-L494">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.funBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">funBinder</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.funBinder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.basicFun"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L497-L498">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.basicFun"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">basicFun</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.basicFun" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.fun"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L499-L500">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fun"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">fun</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.fun" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.optExprPrecedence"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L502-L502">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.optExprPrecedence"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optExprPrecedence</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.optExprPrecedence">Lean.Parser.Term.optExprPrecedence</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Lean/Parser/Extra.html#Lean.Parser.optional">Lean.Parser.optional</a> <span class="fn">(<span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.atomic">Lean.Parser.atomic</a> <span class="fn">(<a href="../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot;:&quot;</span>)</span></span> &gt;&gt; <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.termParser">Lean.Parser.termParser</a> <a href="../.././Lean/Parser/Types.html#Lean.Parser.maxPrec">Lean.Parser.maxPrec</a></span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.optExprPrecedence" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.withAnonymousAntiquot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L503-L505">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.withAnonymousAntiquot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">withAnonymousAntiquot</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.withAnonymousAntiquot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.leading_parser"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L506-L507">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.leading_parser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">leading_parser</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.leading_parser" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.trailing_parser"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L508-L509">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.trailing_parser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">trailing_parser</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.trailing_parser" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.borrowed"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L511-L521">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.borrowed"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">borrowed</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Indicates that an argument to a function marked <code>@[extern]</code> is borrowed.</p><p>Being borrowed only affects the ABI and runtime behavior of the function when compiled or interpreted. From the perspective of Lean's type system, this annotation has no effect. It similarly has no effect on functions not marked <code>@[extern]</code>.</p><p>When a function argument is borrowed, the function does not consume the value. This means that the function will not decrement the value's reference count or deallocate it, and the caller is responsible for doing so.</p><p>Please see <a href="https://lean-lang.org/lean4/doc/dev/ffi.html#borrowing">https://lean-lang.org/lean4/doc/dev/ffi.html#borrowing</a> for a complete description.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.borrowed" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.quotedName"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L522-L523">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.quotedName"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">quotedName</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A literal of type <code>Name</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.quotedName" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.doubleQuotedName"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L524-L531">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.doubleQuotedName"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">doubleQuotedName</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A resolved name literal. Evaluates to the full name of the given constant if
existent in the current context, or else fails.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.doubleQuotedName" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letIdBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L533-L535">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letIdBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letIdBinder</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.letIdBinder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letIdLhs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L537-L540">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letIdLhs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letIdLhs</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.letIdLhs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letIdDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L541-L542">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letIdDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letIdDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.letIdDecl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letPatDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L543-L544">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letPatDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letPatDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.letPatDecl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letEqnsDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L561-L562">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letEqnsDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letEqnsDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.letEqnsDecl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L563-L571">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letDecl">letDecl</a></code> matches the body of a let declaration <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> f x1 x2 := e</code>,
<code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> pat := e</code> (where <code>pat</code> is an arbitrary term) or <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> f | pat1 =&gt; e1 | pat2 =&gt; e2 ...</code>
(a pattern matching declaration), except for the <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a></code> keyword itself.
<code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> rec</code> declarations are not handled here.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.letDecl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.let"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L572-L594">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">let</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a></code> is used to declare a local definition. Example:</p><pre><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> x := 1
<a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> y := x + 1
x + y
</code></pre><p>Since functions are first class citizens in Lean, you can use <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a></code> to declare
local functions too.</p><pre><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> double := <a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fun">fun</a> x =&gt; 2*x
double (double 3)
</code></pre><p>For recursive definitions, you should use <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> rec</code>.
You can also perform pattern matching using <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a></code>. For example,
assume <code>p</code> has type <code><a href="../.././Init/Prelude.html#Nat">Nat</a> × <a href="../.././Init/Prelude.html#Nat">Nat</a></code>, then you can write</p><pre><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> (x, y) := p
x + y
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.let" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.let_fun"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L595-L601">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let_fun"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">let_fun</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let_fun">let_fun</a> x := v; b</code> is syntax sugar for <code>(fun x =&gt; b) v</code>.
It is very similar to <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> x := v; b</code>, but they are not equivalent.
In <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let_fun">let_fun</a></code>, the value <code>v</code> has been abstracted away and cannot be accessed in <code>b</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.let_fun" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.let_delayed"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L602-L606">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let_delayed"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">let_delayed</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let_delayed">let_delayed</a> x := v; b</code> is similar to <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> x := v; b</code>, but <code>b</code> is elaborated before <code>v</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.let_delayed" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.let_tmp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L607-L612">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let_tmp"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">let_tmp</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a></code>-declaration that is only included in the elaborated term if variable is still there.
It is often used when building macros.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.let_tmp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.haveId"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L614-L615">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.haveId"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveId</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.haveId" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.haveIdLhs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L617-L618">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.haveIdLhs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveIdLhs</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.haveIdLhs">Lean.Parser.Term.haveIdLhs</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.haveId">Lean.Parser.Term.haveId</a> &gt;&gt;
    <span class="fn"><span class="fn"><a href="../.././Lean/Parser/Extra.html#Lean.Parser.many">Lean.Parser.many</a> <span class="fn">(<a href="../.././Lean/Parser/Extra.html#Lean.Parser.ppSpace">Lean.Parser.ppSpace</a> &gt;&gt; <a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letIdBinder">Lean.Parser.Term.letIdBinder</a>)</span></span> &gt;&gt; <a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.optType">Lean.Parser.Term.optType</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.haveIdLhs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.haveIdDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L619-L620">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.haveIdDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveIdDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.haveIdDecl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.haveEqnsDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L621-L622">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.haveEqnsDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveEqnsDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.haveEqnsDecl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.haveDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L623-L627">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.haveDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.haveDecl">haveDecl</a></code> matches the body of a have declaration: <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.have">have</a> := e</code>, <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.have">have</a> f x1 x2 := e</code>,
<code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.have">have</a> pat := e</code> (where <code>pat</code> is an arbitrary term) or <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.have">have</a> f | pat1 =&gt; e1 | pat2 =&gt; e2 ...</code>
(a pattern matching declaration), except for the <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.have">have</a></code> keyword itself.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.haveDecl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.have"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L628-L629">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.have"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">have</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.have" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.haveI"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L630-L632">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.haveI"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveI</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.haveI">haveI</a></code> behaves like <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.have">have</a></code>, but inlines the value instead of producing a <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let_fun">let_fun</a></code> term.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.haveI" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letI"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L633-L635">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letI"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letI</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letI">letI</a></code> behaves like <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a></code>, but inlines the value instead of producing a <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let_fun">let_fun</a></code> term.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.letI" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.scoped"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L637-L637">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.scoped"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">scoped</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.scoped" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.local"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L638-L638">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.local"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">local</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.local" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.attrKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L639-L640">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.attrKind"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">attrKind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.attrKind">attrKind</a></code> matches <code>(&quot;scoped&quot; &lt;|&gt; &quot;local&quot;)?</code>, used before an attribute like <code>@[local simp]</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.attrKind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.attrInstance"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L641-L641">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.attrInstance"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">attrInstance</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.attrInstance" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.attributes"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L643-L644">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.attributes"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">attributes</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.attributes" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Termination.terminationBy"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L654-L681">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Termination.terminationBy"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Termination</span>.<span class="name">terminationBy</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Specify a termination argument for recursive functions.</p><pre><code>termination_by a - b
</code></pre><p>indicates that termination of the currently defined recursive function follows
because the difference between the arguments <code>a</code> and <code>b</code> decreases.</p><p>If the function takes further argument after the colon, you can name them as follows:</p><pre><code>def example (a : Nat) : <a href="../.././Init/Prelude.html#Nat">Nat</a> → <a href="../.././Init/Prelude.html#Nat">Nat</a> → <a href="../.././Init/Prelude.html#Nat">Nat</a> :=
termination_by b c =&gt; a - b
</code></pre><p>By default, a <code>termination_by</code> clause will cause the function to be constructed using well-founded
recursion. The syntax <code>termination_by structural a</code> (or <code>termination_by structural _ c =&gt; c</code>)
indicates the function is expected to be structural recursive on the argument. In this case
the body of the <code>termination_by</code> clause must be one of the function's parameters.</p><p>If omitted, a termination argument will be inferred. If written as <code>termination_by?</code>,
the inferrred termination argument will be suggested.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Termination.terminationBy" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Termination.terminationBy?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L683-L685">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Termination.terminationBy?"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Termination</span>.<span class="name">terminationBy?</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Specify a termination argument for recursive functions.</p><pre><code>termination_by a - b
</code></pre><p>indicates that termination of the currently defined recursive function follows
because the difference between the arguments <code>a</code> and <code>b</code> decreases.</p><p>If the function takes further argument after the colon, you can name them as follows:</p><pre><code>def example (a : Nat) : <a href="../.././Init/Prelude.html#Nat">Nat</a> → <a href="../.././Init/Prelude.html#Nat">Nat</a> → <a href="../.././Init/Prelude.html#Nat">Nat</a> :=
termination_by b c =&gt; a - b
</code></pre><p>By default, a <code>termination_by</code> clause will cause the function to be constructed using well-founded
recursion. The syntax <code>termination_by structural a</code> (or <code>termination_by structural _ c =&gt; c</code>)
indicates the function is expected to be structural recursive on the argument. In this case
the body of the <code>termination_by</code> clause must be one of the function's parameters.</p><p>If omitted, a termination argument will be inferred. If written as <code>termination_by?</code>,
the inferrred termination argument will be suggested.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Termination.terminationBy?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Termination.decreasingBy"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L687-L697">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Termination.decreasingBy"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Termination</span>.<span class="name">decreasingBy</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Manually prove that the termination argument (as specified with <code>termination_by</code> or inferred)
decreases at each recursive call.</p><p>By default, the tactic <code>decreasing_tactic</code> is used.</p><p>Forces the use of well-founded recursion and is hence incompatible with
<code>termination_by structural</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Termination.decreasingBy" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Termination.suffix"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L699-L703">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Termination.suffix"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Termination</span>.<span class="name">suffix</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Termination hints are <code>termination_by</code> and <code>decreasing_by</code>, in that order.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Termination.suffix" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letRecDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L708-L711">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letRecDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letRecDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letRecDecl">letRecDecl</a></code> matches the body of a let-rec declaration: a doc comment, attributes, and then
a let declaration without the <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a></code> keyword, such as <code>/-- foo -/ @[simp] bar := 1</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.letRecDecl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letRecDecls"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L712-L715">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letRecDecls"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letRecDecls</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letRecDecls">letRecDecls</a></code> matches <code>letRecDecl,+</code>, a comma-separated list of let-rec declarations (see <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letRecDecl">letRecDecl</a></code>).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.letRecDecls" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letrec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L716-L719">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letrec"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letrec</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.letrec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.whereDecls"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L721-L723">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.whereDecls"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">whereDecls</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.whereDecls" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.matchAltsWhereDecls"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L725-L727">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchAltsWhereDecls"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchAltsWhereDecls</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.matchAltsWhereDecls" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.noindex"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L729-L730">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.noindex"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">noindex</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.noindex" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.unsafe"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L732-L743">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.unsafe"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">unsafe</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.unsafe">unsafe</a> t : α</code> is an expression constructor which allows using unsafe declarations inside the
body of <code>t : α</code>, by creating an auxiliary definition containing <code>t</code> and using <code>implementedBy</code> to
wrap it in a safe interface. It is required that <code>α</code> is nonempty for this to be sound,
but even beyond that, an <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.unsafe">unsafe</a></code> block should be carefully inspected for memory safety because
the compiler is unable to guarantee the safety of the operation.</p><p>For example, the <code>evalExpr</code> function is unsafe, because the compiler cannot guarantee that when
you call <code>evalExpr Foo ``Foo e</code> that the type <code>Foo</code> corresponds to the name <code>Foo</code>, but in a
particular use case, we can ensure this, so <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.unsafe">unsafe</a> (evalExpr Foo ``Foo e)</code> is a correct usage.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.unsafe" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binrel"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L745-L747">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binrel"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binrel</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>binrel% r a b</code> elaborates <code>r a b</code> as a binary relation using the type propagation protocol in <code><a href="../.././Lean/Elab/Extra.html">Lean.Elab.Extra</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.binrel" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binrel_no_prop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L748-L750">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binrel_no_prop"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binrel_no_prop</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>binrel_no_prop% r a b</code> is similar to <code>binrel% r a b</code>, but it coerces <code>Prop</code> arguments into <code><a href="../.././Init/Prelude.html#Bool">Bool</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.binrel_no_prop" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L751-L753">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binop"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binop</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>binop% f a b</code> elaborates <code>f a b</code> as a binary operation using the type propagation protocol in <code><a href="../.././Lean/Elab/Extra.html">Lean.Elab.Extra</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.binop" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binop_lazy"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L754-L756">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binop_lazy"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binop_lazy</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>binop_lazy%</code> is similar to <code>binop% f a b</code>, but it wraps <code>b</code> as a function from <code><a href="../.././Init/Prelude.html#Unit">Unit</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.binop_lazy" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.leftact"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L757-L760">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.leftact"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">leftact</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>leftact% f a b</code> elaborates <code>f a b</code> as a left action using the type propagation protocol in <code><a href="../.././Lean/Elab/Extra.html">Lean.Elab.Extra</a></code>.
In particular, it is like a unary operation with a fixed parameter <code>a</code>, where only the right argument <code>b</code> participates in the operator coercion elaborator.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.leftact" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.rightact"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L761-L764">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.rightact"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">rightact</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>rightact% f a b</code> elaborates <code>f a b</code> as a right action using the type propagation protocol in <code><a href="../.././Lean/Elab/Extra.html">Lean.Elab.Extra</a></code>.
In particular, it is like a unary operation with a fixed parameter <code>b</code>, where only the left argument <code>a</code> participates in the operator coercion elaborator.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.rightact" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.unop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L765-L767">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.unop"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">unop</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>unop% f a</code> elaborates <code>f a</code> as a unary operation using the type propagation protocol in <code><a href="../.././Lean/Elab/Extra.html">Lean.Elab.Extra</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.unop" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.forInMacro"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L769-L770">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.forInMacro"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">forInMacro</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.forInMacro" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.forInMacro'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L771-L772">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.forInMacro'"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">forInMacro'</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.forInMacro'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.declName"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L774-L775">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.declName"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">declName</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A macro which evaluates to the name of the currently elaborating declaration.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.declName" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.withDeclName"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L777-L784">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.withDeclName"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">withDeclName</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><ul>
<li><code>with_decl_name% <a href="../.././Init/Prelude.html#id">id</a> e</code> elaborates <code>e</code> in a context while changing the effective
declaration name to <code><a href="../.././Init/Prelude.html#id">id</a></code>.</li>
<li><code>with_decl_name% ?id e</code> does the same, but resolves <code><a href="../.././Init/Prelude.html#id">id</a></code> as a new definition name
(appending the current namespaces).</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.withDeclName" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.typeOf"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L785-L786">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.typeOf"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">typeOf</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.typeOf" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.ensureTypeOf"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L787-L788">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.ensureTypeOf"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">ensureTypeOf</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.ensureTypeOf" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.ensureExpectedType"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L789-L790">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.ensureExpectedType"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">ensureExpectedType</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.ensureExpectedType" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.noImplicitLambda"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L791-L792">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.noImplicitLambda"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">noImplicitLambda</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.noImplicitLambda" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.clear"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L794-L799">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.clear"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">clear</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>clear% x; e</code> elaborates <code>x</code> after clearing the free variable <code>x</code> from the local context.
If <code>x</code> cannot be cleared (due to dependencies), it will keep <code>x</code> without failing.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.clear" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letMVar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L801-L802">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letMVar"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letMVar</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.letMVar" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.waitIfTypeMVar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L803-L804">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.waitIfTypeMVar"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">waitIfTypeMVar</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.waitIfTypeMVar" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.waitIfTypeContainsMVar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L805-L806">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.waitIfTypeContainsMVar"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">waitIfTypeContainsMVar</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.waitIfTypeContainsMVar" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.waitIfContainsMVar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L807-L808">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.waitIfContainsMVar"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">waitIfContainsMVar</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.waitIfContainsMVar" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.defaultOrOfNonempty"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L810-L811">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.defaultOrOfNonempty"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">defaultOrOfNonempty</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.defaultOrOfNonempty" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.noErrorIfUnused"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L813-L818">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.noErrorIfUnused"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">noErrorIfUnused</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Helper parser for marking <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.match">match</a></code>-alternatives that should not trigger errors if unused.
We use them to implement <code>macro_rules</code> and <code>elab_rules</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.noErrorIfUnused" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.namedArgument"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L820-L821">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.namedArgument"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">namedArgument</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.namedArgument" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.ellipsis"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L822-L824">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.ellipsis"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">ellipsis</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>In a function application, <code>..</code> notation inserts zero or more <code>_</code> placeholders.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.ellipsis" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.argument"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L825-L828">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.argument"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">argument</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.argument" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.app"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L832-L832">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.app"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">app</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.TrailingParser">Lean.Parser.TrailingParser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.app">Lean.Parser.Term.app</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.trailingNode">Lean.Parser.trailingNode</a> <span class="fn">`Lean.Parser.Term.app</span> <a href="../.././Lean/Parser/Types.html#Lean.Parser.leadPrec">Lean.Parser.leadPrec</a> <a href="../.././Lean/Parser/Types.html#Lean.Parser.maxPrec">Lean.Parser.maxPrec</a>
    <span class="fn">(<a href="../.././Lean/Parser/Extra.html#Lean.Parser.many1">Lean.Parser.many1</a> <a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.argument">Lean.Parser.Term.argument</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.app" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.proj"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L834-L847">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.proj"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">proj</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.TrailingParser">Lean.Parser.TrailingParser</a></div></div><p>The <em>extended field notation</em> <code>e.f</code> is roughly short for <code>T.f e</code> where <code>T</code> is the type of <code>e</code>.
More precisely,</p><ul>
<li>if <code>e</code> is of a function type, <code>e.f</code> is translated to <code>Function.f (p := e)</code>
where <code>p</code> is the first explicit parameter of function type</li>
<li>if <code>e</code> is of a named type <code>T ...</code> and there is a declaration <code>T.f</code> (possibly from <code>export</code>),
<code>e.f</code> is translated to <code>T.f (p := e)</code> where <code>p</code> is the first explicit parameter of type <code>T ...</code></li>
<li>otherwise, if <code>e</code> is of a structure type,
the above is repeated for every base type of the structure.</li>
</ul><p>The field index notation <code>e.i</code>, where <code>i</code> is a positive number,
is short for accessing the <code>i</code>-th field (1-indexed) of <code>e</code> if it is of a structure type.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.proj" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.completion"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L848-L849">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.completion"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">completion</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.TrailingParser">Lean.Parser.TrailingParser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.completion">Lean.Parser.Term.completion</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.trailingNode">Lean.Parser.trailingNode</a> <span class="fn">`Lean.Parser.Term.completion</span> <span class="fn">1024</span> <span class="fn">0</span> <span class="fn">(<span class="fn">Lean.Parser.checkNoWsBefore</span> &gt;&gt; <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot;.&quot;</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.completion" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.arrow"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L850-L851">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.arrow"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">arrow</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.TrailingParser">Lean.Parser.TrailingParser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.arrow">Lean.Parser.Term.arrow</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.trailingNode">Lean.Parser.trailingNode</a> <span class="fn">`Lean.Parser.Term.arrow</span> <span class="fn">1024</span> <span class="fn">0</span>
    <span class="fn">(<span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.checkPrec">Lean.Parser.checkPrec</a> <span class="fn">25</span></span> &gt;&gt; <span class="fn"><span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.unicodeSymbol">Lean.Parser.unicodeSymbol</a> <span class="fn">&quot; → &quot;</span> <span class="fn">&quot; -&gt; &quot;</span></span> &gt;&gt; <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.termParser">Lean.Parser.termParser</a> <span class="fn">25</span></span></span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.arrow" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.identProjKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L853-L862">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.identProjKind"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">identProjKind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.Name">Lean.Name</a></div></div><p>Syntax kind for syntax nodes representing the field of a projection in the <code>InfoTree</code>.
Specifically, the <code>InfoTree</code> node for a projection <code>s.f</code> contains a child <code>InfoTree</code> node
with syntax <code>(Syntax.node .none <a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.identProjKind">identProjKind</a> #[`f])</code>.</p><p>This is necessary because projection syntax cannot always be detected purely syntactically
(<code>s.f</code> may refer to either the identifier <code>s.f</code> or a projection <code>s.f</code> depending on
the available context).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.identProjKind">Lean.Parser.Term.identProjKind</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">`Lean.Parser.Term.identProj</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.identProjKind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.isIdent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L864-L866">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.isIdent"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">isIdent</span></a></span><span class="decl_args">
<span class="fn">(stx : <a href="../.././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Bool">Bool</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.isIdent">Lean.Parser.Term.isIdent</a> <span class="fn">stx</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn">stx</span>.isAntiquot</span> <a href="../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><span class="fn">stx</span>.isIdent</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.isIdent" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.explicitUniv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L868-L872">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.explicitUniv"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">explicitUniv</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.TrailingParser">Lean.Parser.TrailingParser</a></div></div><p><code>x.{u, ...}</code> explicitly specifies the universes <code>u, ...</code> of the constant <code>x</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.explicitUniv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.namedPattern"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L873-L878">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.namedPattern"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">namedPattern</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.TrailingParser">Lean.Parser.TrailingParser</a></div></div><p><code>x@e</code> or <code>x@h:e</code> matches the pattern <code>e</code> and binds its value to the identifier <code>x</code>.
If present, the identifier <code>h</code> is bound to a proof of <code>x = e</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.namedPattern" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.pipeProj"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L880-L885">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.pipeProj"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">pipeProj</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.TrailingParser">Lean.Parser.TrailingParser</a></div></div><p><code>e |&gt;.x</code> is a shorthand for <code>(e).x</code>.
It is especially useful for avoiding parentheses with repeated applications.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.pipeProj" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.pipeCompletion"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L886-L887">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.pipeCompletion"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">pipeCompletion</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.TrailingParser">Lean.Parser.TrailingParser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.pipeCompletion">Lean.Parser.Term.pipeCompletion</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.trailingNode">Lean.Parser.trailingNode</a> <span class="fn">`Lean.Parser.Term.pipeCompletion</span> <a href="../.././Lean/Parser/Types.html#Lean.Parser.minPrec">Lean.Parser.minPrec</a> <span class="fn">0</span> <span class="fn">(<a href="../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot; |&gt;.&quot;</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.pipeCompletion" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.subst"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L889-L902">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.subst"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">subst</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.TrailingParser">Lean.Parser.TrailingParser</a></div></div><p><code>h ▸ e</code> is a macro built on top of <code><a href="../.././Init/Prelude.html#Eq.rec">Eq.rec</a></code> and <code><a href="../.././Init/Prelude.html#Eq.symm">Eq.symm</a></code> definitions.
Given <code>h : a = b</code> and <code>e : p a</code>, the term <code>h ▸ e</code> has type <code>p b</code>.
You can also view <code>h ▸ e</code> as a &quot;type casting&quot; operation
where you change the type of <code>e</code> by using <code>h</code>.</p><p>The macro tries both orientations of <code>h</code>. If the context provides an
expected type, it rewrites the expected type, else it rewrites the type of e`.</p><p>See the Chapter &quot;Quantifiers and Equality&quot; in the manual
&quot;Theorem Proving in Lean&quot; for additional information.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.subst">Lean.Parser.Term.subst</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.trailingNode">Lean.Parser.trailingNode</a> <span class="fn">`Lean.Parser.Term.subst</span> <span class="fn">75</span> <span class="fn">0</span>
    <span class="fn">(<span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot; ▸ &quot;</span></span> &gt;&gt; <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.sepBy1">Lean.Parser.sepBy1</a> <span class="fn">(<a href="../.././Lean/Parser/Basic.html#Lean.Parser.termParser">Lean.Parser.termParser</a> <span class="fn">75</span>)</span> <span class="fn">&quot; ▸ &quot;</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.subst" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.bracketedBinderF"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L904-L904">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinderF"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">bracketedBinderF</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinderF">Lean.Parser.Term.bracketedBinderF</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">Lean.Parser.Term.bracketedBinder</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.bracketedBinderF" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean_1"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L905-L905">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean_1"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean_1</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Coe.html#Coe">Coe</a> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">`Lean.Parser.Term.bracketedBinderF</span>)</span> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">`Lean.Parser.Term.bracketedBinder</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean_1">Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean_1</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">coe</span> := <span class="fn">fun (<span class="fn">s</span> : <span class="fn"><a href="../.././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">`Lean.Parser.Term.bracketedBinderF</span></span>) =&gt; <span class="fn">{ <span class="fn">raw</span> := <span class="fn"><span class="fn">s</span>.raw</span> }</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Term.panic"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L907-L916">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.panic"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">panic</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>panic! msg</code> formally evaluates to <code>@Inhabited.default α</code> if the expected type
<code>α</code> implements <code><a href="../.././Init/Prelude.html#Inhabited">Inhabited</a></code>.
At runtime, <code>msg</code> and the file position are printed to stderr unless the C
function <code>lean_set_panic_messages(false)</code> has been executed before. If the C
function <code>lean_set_exit_on_panic(true)</code> has been executed before, the process is
then aborted.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.panic" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.unreachable"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L917-L919">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.unreachable"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">unreachable</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A shorthand for <code>panic! &quot;unreachable code has been reached&quot;</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.unreachable" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.dbgTrace"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L920-L926">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.dbgTrace"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">dbgTrace</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>dbg_trace e; body</code> evaluates to <code>body</code> and prints <code>e</code> (which can be an
interpolated string literal) to stderr. It should only be used for debugging.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.dbgTrace" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.assert"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L927-L929">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.assert"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">assert</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>assert! <a href="../.././Init/Prelude.html#cond">cond</a></code> panics if <code><a href="../.././Init/Prelude.html#cond">cond</a></code> evaluates to <code>false</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.assert" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.macroArg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L931-L931">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.macroArg"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">macroArg</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.macroArg">Lean.Parser.Term.macroArg</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.termParser">Lean.Parser.termParser</a> <a href="../.././Lean/Parser/Types.html#Lean.Parser.maxPrec">Lean.Parser.maxPrec</a></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.macroArg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.macroDollarArg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L932-L932">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.macroDollarArg"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">macroDollarArg</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.macroDollarArg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.macroLastArg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L933-L933">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.macroLastArg"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">macroLastArg</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.macroLastArg">Lean.Parser.Term.macroLastArg</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.macroDollarArg">Lean.Parser.Term.macroDollarArg</a> &lt;|&gt; <a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.macroArg">Lean.Parser.Term.macroArg</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.macroLastArg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.stateRefT"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L936-L937">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.stateRefT"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">stateRefT</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.stateRefT" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.dynamicQuot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L939-L940">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.dynamicQuot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">dynamicQuot</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.dynamicQuot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.dotIdent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L942-L943">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.dotIdent"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">dotIdent</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.dotIdent" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.showTermElabImpl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L945-L949">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.showTermElabImpl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">showTermElabImpl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Implementation of the <code>show_term</code> term elaborator.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.showTermElabImpl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><p><code>match_expr</code> support.</p></div><div class="decl" id="Lean.Parser.Term.matchExprPat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L955-L955">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchExprPat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchExprPat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.matchExprPat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.matchExprAlt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L956-L956">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchExprAlt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchExprAlt</span></a></span><span class="decl_args">
<span class="fn">(rhsParser : <a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.matchExprAlt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.matchExprElseAlt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L957-L957">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchExprElseAlt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchExprElseAlt</span></a></span><span class="decl_args">
<span class="fn">(rhsParser : <a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.matchExprElseAlt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.matchExprAlts"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L958-L961">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchExprAlts"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchExprAlts</span></a></span><span class="decl_args">
<span class="fn">(rhsParser : <a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.matchExprAlts" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.matchExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L962-L963">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchExpr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.matchExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L965-L966">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letExpr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.letExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.quot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L970-L971">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.quot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">quot</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.quot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.quotSeq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L972-L973">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.quotSeq"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">quotSeq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.quotSeq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>