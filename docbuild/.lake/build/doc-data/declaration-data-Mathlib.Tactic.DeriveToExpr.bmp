{"name":"Mathlib.Tactic.DeriveToExpr","instances":[],"imports":["Init","Lean.Elab.Deriving.Ord","Mathlib.Tactic.ToLevel"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/DeriveToExpr.lean#L217-L224","name":"Mathlib.Deriving.ToExpr.mkToExprInstanceHandler","line":217,"kind":"def","docLink":"./Mathlib/Tactic/DeriveToExpr.html#Mathlib.Deriving.ToExpr.mkToExprInstanceHandler","doc":"The main entry point to the `ToExpr` derive handler. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DeriveToExpr.html#Mathlib.Deriving.ToExpr.mkToExprInstanceHandler\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Deriving</span>.<span class=\"name\">ToExpr</span>.<span class=\"name\">mkToExprInstanceHandler</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(declNames : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Command.html#Lean.Elab.Command.CommandElabM\">Lean.Elab.Command.CommandElabM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/DeriveToExpr.lean#L210-L215","name":"Mathlib.Deriving.ToExpr.mkToExprInstanceCmds","line":210,"kind":"def","docLink":"./Mathlib/Tactic/DeriveToExpr.html#Mathlib.Deriving.ToExpr.mkToExprInstanceCmds","doc":"Returns all the commands generated by `mkMutualBlock` and `mkInstanceCmds`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DeriveToExpr.html#Mathlib.Deriving.ToExpr.mkToExprInstanceCmds\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Deriving</span>.<span class=\"name\">ToExpr</span>.<span class=\"name\">mkToExprInstanceCmds</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(declNames : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/DeriveToExpr.lean#L188-L208","name":"Mathlib.Deriving.ToExpr.mkInstanceCmds","line":188,"kind":"def","docLink":"./Mathlib/Tactic/DeriveToExpr.html#Mathlib.Deriving.ToExpr.mkInstanceCmds","doc":"Assuming all of the auxiliary definitions exist, create all the `instance` commands\nfor the `ToExpr` instances for the (mutual) inductive type(s). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DeriveToExpr.html#Mathlib.Deriving.ToExpr.mkInstanceCmds\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Deriving</span>.<span class=\"name\">ToExpr</span>.<span class=\"name\">mkInstanceCmds</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ctx : <a href=\"./Lean/Elab/Deriving/Util.html#Lean.Elab.Deriving.Context\">Lean.Elab.Deriving.Context</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(typeNames : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Meta.html#Lean.Syntax.Command\">Lean.Command</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/DeriveToExpr.lean#L179-L185","name":"Mathlib.Deriving.ToExpr.mkMutualBlock","line":179,"kind":"def","docLink":"./Mathlib/Tactic/DeriveToExpr.html#Mathlib.Deriving.ToExpr.mkMutualBlock","doc":"Create all the auxiliary functions using `mkAuxFunction` for the (mutual) inductive type(s).\nWraps the resulting definition commands in `mutual ... end`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DeriveToExpr.html#Mathlib.Deriving.ToExpr.mkMutualBlock\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Deriving</span>.<span class=\"name\">ToExpr</span>.<span class=\"name\">mkMutualBlock</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ctx : <a href=\"./Lean/Elab/Deriving/Util.html#Lean.Elab.Deriving.Context\">Lean.Elab.Deriving.Context</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/DeriveToExpr.lean#L147-L177","name":"Mathlib.Deriving.ToExpr.mkAuxFunction","line":147,"kind":"def","docLink":"./Mathlib/Tactic/DeriveToExpr.html#Mathlib.Deriving.ToExpr.mkAuxFunction","doc":"Make a `toExpr` function for the given inductive type.\nThe implementations of each `toExpr` function for a (mutual) inductive type\nare given as top-level private definitions.\nThese end up being assembled into `ToExpr` instances in `mkInstanceCmds`.\nFor mutual inductive types,\nthen each of the other types' `ToExpr` instances are provided as local instances,\nto wire together the recursion (this necessitates these auxiliary definitions being `partial`). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DeriveToExpr.html#Mathlib.Deriving.ToExpr.mkAuxFunction\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Deriving</span>.<span class=\"name\">ToExpr</span>.<span class=\"name\">mkAuxFunction</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ctx : <a href=\"./Lean/Elab/Deriving/Util.html#Lean.Elab.Deriving.Context\">Lean.Elab.Deriving.Context</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(i : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Init/Meta.html#Lean.Syntax.Command\">Lean.Command</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/DeriveToExpr.lean#L142-L144","name":"Mathlib.Deriving.ToExpr.mkToLevelBinders","line":142,"kind":"def","docLink":"./Mathlib/Tactic/DeriveToExpr.html#Mathlib.Deriving.ToExpr.mkToLevelBinders","doc":"Make `ToLevel` instance binders for all the level variables. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DeriveToExpr.html#Mathlib.Deriving.ToExpr.mkToLevelBinders\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Deriving</span>.<span class=\"name\">ToExpr</span>.<span class=\"name\">mkToLevelBinders</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(indVal : <a href=\"./Lean/Declaration.html#Lean.InductiveVal\">Lean.InductiveVal</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Lean.TSyntaxArray\">Lean.TSyntaxArray</a> <span class=\"fn\">`Lean.Elab.Deriving.instBinderF</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/DeriveToExpr.lean#L134-L140","name":"Mathlib.Deriving.ToExpr.fixIndType","line":134,"kind":"def","docLink":"./Mathlib/Tactic/DeriveToExpr.html#Mathlib.Deriving.ToExpr.fixIndType","doc":"Fix the output of `mkInductiveApp` to explicitly reference universe levels. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DeriveToExpr.html#Mathlib.Deriving.ToExpr.fixIndType\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Deriving</span>.<span class=\"name\">ToExpr</span>.<span class=\"name\">fixIndType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(indVal : <a href=\"./Lean/Declaration.html#Lean.InductiveVal\">Lean.InductiveVal</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/DeriveToExpr.lean#L104-L132","name":"Mathlib.Deriving.ToExpr.mkLocalInstanceLetDecls","line":104,"kind":"def","docLink":"./Mathlib/Tactic/DeriveToExpr.html#Mathlib.Deriving.ToExpr.mkLocalInstanceLetDecls","doc":"For mutually recursive inductive types, the strategy is to have local `ToExpr` instances in scope\nfor each of the inductives when defining each instance.\nThis way, each instance can freely use `toExpr` and `toTypeExpr` for each of the other types.\n\nNote that each instance gets its own definition of each of the others' `toTypeExpr` fields.\n(This is working around the fact that the `Deriving.Context` API assumes\nthat each instance in mutual recursion only has a single auxiliary definition.\nThere are other ways to work around it, but `toTypeExpr` implementations\nare very simple, so duplicating them seemed to be OK.) "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DeriveToExpr.html#Mathlib.Deriving.ToExpr.mkLocalInstanceLetDecls\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Deriving</span>.<span class=\"name\">ToExpr</span>.<span class=\"name\">mkLocalInstanceLetDecls</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ctx : <a href=\"./Lean/Elab/Deriving/Util.html#Lean.Elab.Deriving.Context\">Lean.Elab.Deriving.Context</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(argNames : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Term.letDecl</span>)</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/DeriveToExpr.lean#L89-L102","name":"Mathlib.Deriving.ToExpr.mkToTypeExpr","line":89,"kind":"def","docLink":"./Mathlib/Tactic/DeriveToExpr.html#Mathlib.Deriving.ToExpr.mkToTypeExpr","doc":"Create the body of the `toTypeExpr` function for the `ToExpr` instance.\nCalls `toExpr` and `toTypeExpr` to the arguments to the type constructor. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DeriveToExpr.html#Mathlib.Deriving.ToExpr.mkToTypeExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Deriving</span>.<span class=\"name\">ToExpr</span>.<span class=\"name\">mkToTypeExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(argNames : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(indVal : <a href=\"./Lean/Declaration.html#Lean.InductiveVal\">Lean.InductiveVal</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/DeriveToExpr.lean#L54-L87","name":"Mathlib.Deriving.ToExpr.mkToExprBody.mkAlts","line":54,"kind":"def","docLink":"./Mathlib/Tactic/DeriveToExpr.html#Mathlib.Deriving.ToExpr.mkToExprBody.mkAlts","doc":"Create the `match` cases, one per constructor. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DeriveToExpr.html#Mathlib.Deriving.ToExpr.mkToExprBody.mkAlts\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Deriving</span>.<span class=\"name\">ToExpr</span>.<span class=\"name\">mkToExprBody</span>.<span class=\"name\">mkAlts</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(header : <a href=\"./Lean/Elab/Deriving/Util.html#Lean.Elab.Deriving.Header\">Lean.Elab.Deriving.Header</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(indVal : <a href=\"./Lean/Declaration.html#Lean.InductiveVal\">Lean.InductiveVal</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(auxFunName : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Term.matchAlt</span>)</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/DeriveToExpr.lean#L41-L87","name":"Mathlib.Deriving.ToExpr.mkToExprBody","line":41,"kind":"def","docLink":"./Mathlib/Tactic/DeriveToExpr.html#Mathlib.Deriving.ToExpr.mkToExprBody","doc":"Create the body of the `toExpr` function\nfor the `ToExpr` instance, which is a `match` expression\nthat calls `toExpr` and `toTypeExpr` to assemble an expression for a given term.\nFor recursive inductive types, `auxFunName` refers to the `ToExpr` instance\nfor the current type.\nFor mutually recursive types, we rely on the local instances set up by `mkLocalInstanceLetDecls`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DeriveToExpr.html#Mathlib.Deriving.ToExpr.mkToExprBody\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Deriving</span>.<span class=\"name\">ToExpr</span>.<span class=\"name\">mkToExprBody</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(header : <a href=\"./Lean/Elab/Deriving/Util.html#Lean.Elab.Deriving.Header\">Lean.Elab.Deriving.Header</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(indVal : <a href=\"./Lean/Declaration.html#Lean.InductiveVal\">Lean.InductiveVal</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(auxFunName : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/DeriveToExpr.lean#L36-L39","name":"Mathlib.Deriving.ToExpr.mkAppNTerm","line":36,"kind":"def","docLink":"./Mathlib/Tactic/DeriveToExpr.html#Mathlib.Deriving.ToExpr.mkAppNTerm","doc":"Give a term that is equivalent to `(term| mkAppN $f #[$args,*])`.\nAs an optimization, `mkAppN` is pre-expanded out to use `Expr.app` directly. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DeriveToExpr.html#Mathlib.Deriving.ToExpr.mkAppNTerm\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Deriving</span>.<span class=\"name\">ToExpr</span>.<span class=\"name\">mkAppNTerm</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(f : <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(args : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/DeriveToExpr.lean#L30-L34","name":"Mathlib.Deriving.ToExpr.mkToExprHeader","line":30,"kind":"def","docLink":"./Mathlib/Tactic/DeriveToExpr.html#Mathlib.Deriving.ToExpr.mkToExprHeader","doc":"Specialization of `Lean.Elab.Deriving.mkHeader` for `ToExpr`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DeriveToExpr.html#Mathlib.Deriving.ToExpr.mkToExprHeader\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Deriving</span>.<span class=\"name\">ToExpr</span>.<span class=\"name\">mkToExprHeader</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(indVal : <a href=\"./Lean/Declaration.html#Lean.InductiveVal\">Lean.InductiveVal</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Lean/Elab/Deriving/Util.html#Lean.Elab.Deriving.Header\">Lean.Elab.Deriving.Header</a></span></div></div>"}]}