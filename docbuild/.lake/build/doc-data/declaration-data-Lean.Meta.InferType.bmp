{"name":"Lean.Meta.InferType","instances":[],"imports":["Lean.Data.LBool","Lean.Meta.Basic"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Meta/InferType.lean#L451-L455","name":"Lean.Meta.inferArgumentTypesN","line":451,"kind":"def","docLink":"./Lean/Meta/InferType.html#Lean.Meta.inferArgumentTypesN","doc":"Infers the types of the next `n` parameters that `e` expects. See `arrowDomainsN`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.inferArgumentTypesN\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">inferArgumentTypesN</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Meta/InferType.lean#L434-L449","name":"Lean.Meta.arrowDomainsN","line":434,"kind":"def","docLink":"./Lean/Meta/InferType.html#Lean.Meta.arrowDomainsN","doc":"Given `n` and a non-dependent function type `α₁ → α₂ → ... → αₙ → Sort u`, returns the\ntypes `α₁, α₂, ..., αₙ`. Throws an error if there are not at least `n` argument types or if a\nlater argument type depends on a prior one (i.e., it's a dependent function type).\n\nThis can be used to infer the expected type of the alternatives when constructing a `MatcherApp`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.arrowDomainsN\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">arrowDomainsN</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(type : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Meta/InferType.lean#L426-L431","name":"Lean.Meta.isTypeFormer","line":426,"kind":"def","docLink":"./Lean/Meta/InferType.html#Lean.Meta.isTypeFormer","doc":"Return true iff `e : Sort _` or `e : (forall As, Sort _)`.\nRemark: it subsumes `isType`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.isTypeFormer\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">isTypeFormer</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Meta/InferType.lean#L420-L424","name":"Lean.Meta.isPropFormerType","line":420,"kind":"def","docLink":"./Lean/Meta/InferType.html#Lean.Meta.isPropFormerType","doc":"Return true iff `type` is `Prop` or `As → Prop`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.isPropFormerType\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">isPropFormerType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(type : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Meta/InferType.lean#L414-L418","name":"Lean.Meta.isTypeFormerType","line":414,"kind":"def","docLink":"./Lean/Meta/InferType.html#Lean.Meta.isTypeFormerType","doc":"Return true iff `type` is `Sort _` or `As → Sort _`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.isTypeFormerType\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">isTypeFormerType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(type : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Meta/InferType.lean#L403-L412","name":"Lean.Meta.typeFormerTypeLevel.go","line":403,"kind":"opaque","docLink":"./Lean/Meta/InferType.html#Lean.Meta.typeFormerTypeLevel.go","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.typeFormerTypeLevel.go\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">typeFormerTypeLevel</span>.<span class=\"name\">go</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(type : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(xs : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Meta/InferType.lean#L395-L412","name":"Lean.Meta.typeFormerTypeLevel","line":395,"kind":"def","docLink":"./Lean/Meta/InferType.html#Lean.Meta.typeFormerTypeLevel","doc":"Return `u` iff `type` is `Sort u` or `As → Sort u`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.typeFormerTypeLevel\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">typeFormerTypeLevel</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(type : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Meta/InferType.lean#L390-L393","name":"Lean.Meta.typeFormerTypeLevelQuick","line":390,"kind":"def","docLink":"./Lean/Meta/InferType.html#Lean.Meta.typeFormerTypeLevelQuick","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.typeFormerTypeLevelQuick\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">typeFormerTypeLevelQuick</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Meta/InferType.lean#L371-L383","name":"Lean.Meta.isType","line":371,"kind":"def","docLink":"./Lean/Meta/InferType.html#Lean.Meta.isType","doc":"Return `true` iff the type of `e` is a `Sort _`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.isType\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">isType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Meta/InferType.lean#L354-L369","name":"Lean.Meta.isTypeQuick","line":354,"kind":"opaque","docLink":"./Lean/Meta/InferType.html#Lean.Meta.isTypeQuick","doc":"`isTypeQuick e` is an \"approximate\" predicate which returns `LBool.true`\nif `e` is a type. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.isTypeQuick\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">isTypeQuick</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Data/LBool.html#Lean.LBool\">Lean.LBool</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Meta/InferType.lean#L322-L326","name":"Lean.Meta.isProof","line":322,"kind":"def","docLink":"./Lean/Meta/InferType.html#Lean.Meta.isProof","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.isProof\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">isProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Meta/InferType.lean#L303-L318","name":"Lean.Meta.isProofQuick","line":303,"kind":"opaque","docLink":"./Lean/Meta/InferType.html#Lean.Meta.isProofQuick","doc":"`isProofQuick e` is an \"approximate\" predicate which returns `LBool.true`\nif `e` is a proof. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.isProofQuick\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">isProofQuick</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Data/LBool.html#Lean.LBool\">Lean.LBool</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Meta/InferType.lean#L260-L275","name":"Lean.Meta.isProp","line":260,"kind":"def","docLink":"./Lean/Meta/InferType.html#Lean.Meta.isProp","doc":"`isProp e` returns `true` if `e` is a proposition.\n\nIf `e` contains metavariables, it may not be possible\nto decide whether is a proposition or not. We return `false` in this\ncase. We considered using `LBool` and retuning `LBool.undef`, but\nwe have no applications for it. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.isProp\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">isProp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Meta/InferType.lean#L243-L258","name":"Lean.Meta.isPropQuick","line":243,"kind":"opaque","docLink":"./Lean/Meta/InferType.html#Lean.Meta.isPropQuick","doc":"`isPropQuick e` is an \"approximate\" predicate which returns `LBool.true`\nif `e` is a proposition. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.isPropQuick\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">isPropQuick</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Data/LBool.html#Lean.LBool\">Lean.LBool</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Meta/InferType.lean#L189-L203","name":"Lean.Meta.inferTypeImp.infer","line":189,"kind":"def","docLink":"./Lean/Meta/InferType.html#Lean.Meta.inferTypeImp.infer","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.inferTypeImp.infer\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">inferTypeImp</span>.<span class=\"name\">infer</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Meta/InferType.lean#L187-L204","name":"Lean.Meta.inferTypeImp","line":187,"kind":"def","docLink":"./Lean/Meta/InferType.html#Lean.Meta.inferTypeImp","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.inferTypeImp\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">inferTypeImp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Meta/InferType.lean#L154-L155","name":"Lean.Meta.throwUnknownMVar","line":154,"kind":"def","docLink":"./Lean/Meta/InferType.html#Lean.Meta.throwUnknownMVar","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.throwUnknownMVar\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">throwUnknownMVar</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(mvarId : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Meta/InferType.lean#L125-L137","name":"Lean.Meta.getLevel","line":125,"kind":"def","docLink":"./Lean/Meta/InferType.html#Lean.Meta.getLevel","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.getLevel\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">getLevel</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(type : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Meta/InferType.lean#L122-L123","name":"Lean.Meta.throwTypeExcepted","line":122,"kind":"def","docLink":"./Lean/Meta/InferType.html#Lean.Meta.throwTypeExcepted","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.throwTypeExcepted\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">throwTypeExcepted</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(type : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Meta/InferType.lean#L87-L88","name":"Lean.Meta.throwIncorrectNumberOfLevels","line":87,"kind":"def","docLink":"./Lean/Meta/InferType.html#Lean.Meta.throwIncorrectNumberOfLevels","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.throwIncorrectNumberOfLevels\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">throwIncorrectNumberOfLevels</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(constName : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(us : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Meta/InferType.lean#L70-L71","name":"Lean.Meta.throwFunctionExpected","line":70,"kind":"def","docLink":"./Lean/Meta/InferType.html#Lean.Meta.throwFunctionExpected","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.throwFunctionExpected\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">throwFunctionExpected</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Meta/InferType.lean#L33-L66","name":"Lean.Expr.instantiateBetaRevRange.visit","line":33,"kind":"opaque","docLink":"./Lean/Meta/InferType.html#Lean.Expr.instantiateBetaRevRange.visit","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Expr.instantiateBetaRevRange.visit\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">instantiateBetaRevRange</span>.<span class=\"name\">visit</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(start stop : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(args : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(offset : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Util/MonadCache.html#Lean.MonadStateCacheT\">Lean.MonadStateCacheT</a> <span class=\"fn\">(<a href=\"./Lean/Expr.html#Lean.ExprStructEq\">Lean.ExprStructEq</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Control/Id.html#Id\">Id</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Meta/InferType.lean#L12-L66","name":"Lean.Expr.instantiateBetaRevRange","line":12,"kind":"def","docLink":"./Lean/Meta/InferType.html#Lean.Expr.instantiateBetaRevRange","doc":"Auxiliary function for instantiating the loose bound variables in `e` with `args[start:stop]`.\nThis function is similar to `instantiateRevRange`, but it applies beta-reduction when\nwe instantiate a bound variable with a lambda expression.\nExample: Given the term `#0 a`, and `start := 0, stop := 1, args := #[fun x => x]` the result is\n`a` instead of `(fun x => x) a`.\nThis reduction is useful when we are inferring the type of eliminator-like applications.\nFor example, given `(n m : Nat) (f : Nat → Nat) (h : m = n)`,\nthe type of `Eq.subst (motive := fun x => f m = f x) h rfl`\nis `motive n` which is `(fun (x : Nat) => f m = f x) n`\nThis function reduces the new application to `f m = f n`\n\nWe use it to implement `inferAppType`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Expr.instantiateBetaRevRange\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">instantiateBetaRevRange</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(start stop : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(args : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"}]}