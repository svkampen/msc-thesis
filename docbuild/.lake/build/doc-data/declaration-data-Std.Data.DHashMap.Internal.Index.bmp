{"name":"Std.Data.DHashMap.Internal.Index","instances":[],"imports":["Init.Data.UInt.Lemmas","Init.Data.UInt.Bitwise"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Internal/Index.lean#L42-L62","name":"Std.DHashMap.Internal.mkIdx","line":42,"kind":"def","docLink":"./Std/Data/DHashMap/Internal/Index.html#Std.DHashMap.Internal.mkIdx","doc":"`sz` is an explicit parameter because having it inferred from `h` can lead to suboptimal IR,\ncf. https://github.com/leanprover/lean4/issues/4157\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/DHashMap/Internal/Index.html#Std.DHashMap.Internal.mkIdx\"><span class=\"name\">Std</span>.<span class=\"name\">DHashMap</span>.<span class=\"name\">Internal</span>.<span class=\"name\">mkIdx</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(sz : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">sz</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hash : <a href=\"./Init/Prelude.html#UInt64\">UInt64</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">{ <span class=\"fn\">u</span> : <a href=\"./Init/Prelude.html#USize\">USize</a> // <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">u</span>.toNat</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">sz</span></span> }</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Data/DHashMap/Internal/Index.lean#L22-L38","name":"Std.DHashMap.Internal.scrambleHash","line":22,"kind":"def","docLink":"./Std/Data/DHashMap/Internal/Index.html#Std.DHashMap.Internal.scrambleHash","doc":"Scramble the hash code in order to protect against bad hash functions.\n\nExample: if `Hashable Float` was implemented using the \"identity\" reinterpreting the bit pattern as\na `UInt64`, then the hash codes of all small positive or negative integers would end in around 50\nzeroes, meaning that they all land in bucket 0 in reasonably-sized hash maps.\n\nTo counteract this, we xor the hash code with some shifted-down versions of itself, to make sure\nthat all of the entropy of the hash code appears in the lower 16 bits at least.\n\nThe scrambling operation is very fast. It does not have a measurable impact on performance in the\ninsert benchmark.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/DHashMap/Internal/Index.html#Std.DHashMap.Internal.scrambleHash\"><span class=\"name\">Std</span>.<span class=\"name\">DHashMap</span>.<span class=\"name\">Internal</span>.<span class=\"name\">scrambleHash</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(hash : <a href=\"./Init/Prelude.html#UInt64\">UInt64</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#UInt64\">UInt64</a></div></div>"}]}