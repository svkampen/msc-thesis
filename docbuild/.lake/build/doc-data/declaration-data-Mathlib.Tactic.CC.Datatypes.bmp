{"name":"Mathlib.Tactic.CC.Datatypes","instances":[{"typeNames":["Mathlib.Tactic.CC.CCCongrTheoremKey"],"name":"Mathlib.Tactic.CC.instBEqCCCongrTheoremKey","className":"BEq"},{"typeNames":["Mathlib.Tactic.CC.CCCongrTheoremKey"],"name":"Mathlib.Tactic.CC.instHashableCCCongrTheoremKey","className":"Hashable"},{"typeNames":["Mathlib.Tactic.CC.CCConfig"],"name":"Mathlib.Tactic.CC.instInhabitedCCConfig","className":"Inhabited"},{"typeNames":["Mathlib.Tactic.CC.ACApps"],"name":"Mathlib.Tactic.CC.instInhabitedACApps","className":"Inhabited"},{"typeNames":["Mathlib.Tactic.CC.ACApps"],"name":"Mathlib.Tactic.CC.instBEqACApps","className":"BEq"},{"typeNames":["Lean.Expr","Mathlib.Tactic.CC.ACApps"],"name":"Mathlib.Tactic.CC.instCoeExprACApps","className":"Coe"},{"typeNames":["Mathlib.Tactic.CC.DelayedExpr"],"name":"Mathlib.Tactic.CC.instInhabitedDelayedExpr","className":"Inhabited"},{"typeNames":["Lean.Expr","Mathlib.Tactic.CC.DelayedExpr"],"name":"Mathlib.Tactic.CC.instCoeExprDelayedExpr","className":"Coe"},{"typeNames":["Mathlib.Tactic.CC.EntryExpr"],"name":"Mathlib.Tactic.CC.instInhabitedEntryExpr","className":"Inhabited"},{"typeNames":["Mathlib.Tactic.CC.EntryExpr"],"name":"Mathlib.Tactic.CC.instToMessageDataEntryExpr","className":"Lean.ToMessageData"},{"typeNames":["Lean.Expr","Mathlib.Tactic.CC.EntryExpr"],"name":"Mathlib.Tactic.CC.instCoeExprEntryExpr","className":"Coe"},{"typeNames":["Mathlib.Tactic.CC.Entry"],"name":"Mathlib.Tactic.CC.instInhabitedEntry","className":"Inhabited"},{"typeNames":["Mathlib.Tactic.CC.ACEntry"],"name":"Mathlib.Tactic.CC.instInhabitedACEntry","className":"Inhabited"},{"typeNames":["Mathlib.Tactic.CC.CongruencesKey"],"name":"Mathlib.Tactic.CC.instBEqCongruencesKey","className":"BEq"},{"typeNames":["Mathlib.Tactic.CC.CongruencesKey"],"name":"Mathlib.Tactic.CC.instHashableCongruencesKey","className":"Hashable"},{"typeNames":["Mathlib.Tactic.CC.SymmCongruencesKey"],"name":"Mathlib.Tactic.CC.instBEqSymmCongruencesKey","className":"BEq"},{"typeNames":["Mathlib.Tactic.CC.SymmCongruencesKey"],"name":"Mathlib.Tactic.CC.instHashableSymmCongruencesKey","className":"Hashable"},{"typeNames":["Mathlib.Tactic.CC.CCState"],"name":"Mathlib.Tactic.CC.instInhabitedCCState","className":"Inhabited"},{"typeNames":["Mathlib.Tactic.CC.CCStructure"],"name":"Mathlib.Tactic.CC.instInhabitedCCStructure","className":"Inhabited"}],"imports":["Init","Lean.Meta.CongrTheorems","Lean.Meta.Tactic.Rfl","Batteries.Data.RBMap.Basic","Mathlib.Lean.Meta.Basic","Std.Data.HashMap.Basic"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L693-L693","name":"Mathlib.Tactic.CC.instInhabitedCCStructure","line":693,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedCCStructure","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedCCStructure\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instInhabitedCCStructure</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure\">Mathlib.Tactic.CC.CCStructure</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L692-L692","name":"Mathlib.Tactic.CC.CCStructure.cache","line":692,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.cache","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.cache\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCStructure</span>.<span class=\"name\">cache</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure\">Mathlib.Tactic.CC.CCStructure</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremCache\">Mathlib.Tactic.CC.CCCongrTheoremCache</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L691-L691","name":"Mathlib.Tactic.CC.CCStructure.phandler","line":691,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.phandler","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.phandler\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCStructure</span>.<span class=\"name\">phandler</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure\">Mathlib.Tactic.CC.CCStructure</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler\">Mathlib.Tactic.CC.CCPropagationHandler</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L690-L690","name":"Mathlib.Tactic.CC.CCStructure.normalizer","line":690,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.normalizer","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.normalizer\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCStructure</span>.<span class=\"name\">normalizer</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure\">Mathlib.Tactic.CC.CCStructure</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCNormalizer\">Mathlib.Tactic.CC.CCNormalizer</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L689-L689","name":"Mathlib.Tactic.CC.CCStructure.acTodo","line":689,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.acTodo","doc":"AC-equalities that have been discovered but not processed. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.acTodo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCStructure</span>.<span class=\"name\">acTodo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure\">Mathlib.Tactic.CC.CCStructure</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACTodoEntry\">Mathlib.Tactic.CC.ACTodoEntry</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L687-L687","name":"Mathlib.Tactic.CC.CCStructure.todo","line":687,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.todo","doc":"Equalities that have been discovered but not processed. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.todo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCStructure</span>.<span class=\"name\">todo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure\">Mathlib.Tactic.CC.CCStructure</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.TodoEntry\">Mathlib.Tactic.CC.TodoEntry</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L685-L685","name":"Mathlib.Tactic.CC.CCStructure.mk","line":685,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCStructure</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(toCCState : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(todo : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.TodoEntry\">Mathlib.Tactic.CC.TodoEntry</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(acTodo : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACTodoEntry\">Mathlib.Tactic.CC.ACTodoEntry</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(normalizer : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCNormalizer\">Mathlib.Tactic.CC.CCNormalizer</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(phandler : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler\">Mathlib.Tactic.CC.CCPropagationHandler</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(cache : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremCache\">Mathlib.Tactic.CC.CCCongrTheoremCache</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure\">Mathlib.Tactic.CC.CCStructure</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L682-L693","name":"Mathlib.Tactic.CC.CCStructure","line":682,"kind":"structure","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure","doc":"`CCStructure` extends `CCState` (which records a set of facts derived by congruence closure)\nby recording which steps still need to be taken to solve the goal.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCStructure</span></a></span><span class=\"decl_extends\">extends</span> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L680-L680","name":"Mathlib.Tactic.CC.CCPropagationHandler.newAuxCCTerm","line":680,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler.newAuxCCTerm","doc":"Congruence closure module invokes the following method when\na new auxiliary term is created during propagation. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler.newAuxCCTerm\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCPropagationHandler</span>.<span class=\"name\">newAuxCCTerm</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler\">Mathlib.Tactic.CC.CCPropagationHandler</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L677-L677","name":"Mathlib.Tactic.CC.CCPropagationHandler.propagated","line":677,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler.propagated","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler.propagated\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCPropagationHandler</span>.<span class=\"name\">propagated</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler\">Mathlib.Tactic.CC.CCPropagationHandler</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L676-L676","name":"Mathlib.Tactic.CC.CCPropagationHandler.mk","line":676,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCPropagationHandler</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(propagated : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(newAuxCCTerm : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler\">Mathlib.Tactic.CC.CCPropagationHandler</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L676-L680","name":"Mathlib.Tactic.CC.CCPropagationHandler","line":676,"kind":"structure","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCPropagationHandler\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCPropagationHandler</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L672-L672","name":"Mathlib.Tactic.CC.CCNormalizer.normalize","line":672,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCNormalizer.normalize","doc":"The congruence closure module (optionally) uses a normalizer.\nThe idea is to use it (if available) to normalize auxiliary expressions\nproduced by internal propagation rules (e.g., subsingleton propagator). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCNormalizer.normalize\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCNormalizer</span>.<span class=\"name\">normalize</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCNormalizer\">Mathlib.Tactic.CC.CCNormalizer</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L671-L671","name":"Mathlib.Tactic.CC.CCNormalizer.mk","line":671,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCNormalizer.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCNormalizer.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCNormalizer</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(normalize : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCNormalizer\">Mathlib.Tactic.CC.CCNormalizer</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L668-L672","name":"Mathlib.Tactic.CC.CCNormalizer","line":668,"kind":"structure","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCNormalizer","doc":"The congruence closure module (optionally) uses a normalizer.\nThe idea is to use it (if available) to normalize auxiliary expressions\nproduced by internal propagation rules (e.g., subsingleton propagator). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCNormalizer\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCNormalizer</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L663-L664","name":"Mathlib.Tactic.CC.CCState.ppAC","line":663,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppAC","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppAC\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">ppAC</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ccs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L658-L661","name":"Mathlib.Tactic.CC.CCState.ppACR","line":658,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppACR","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppACR\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">ppACR</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ccs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L652-L656","name":"Mathlib.Tactic.CC.CCState.ppACApps","line":652,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppACApps","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppACApps\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">ppACApps</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ccs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a> → <a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L646-L650","name":"Mathlib.Tactic.CC.CCState.ppACExpr","line":646,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppACExpr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppACExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">ppACExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ccs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L642-L644","name":"Mathlib.Tactic.CC.CCState.ppACDecls","line":642,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppACDecls","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppACDecls\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">ppACDecls</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ccs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L637-L640","name":"Mathlib.Tactic.CC.CCState.ppACDecl","line":637,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppACDecl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppACDecl\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">ppACDecl</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ccs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L633-L635","name":"Mathlib.Tactic.CC.CCState.ppParentOccs","line":633,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppParentOccs","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppParentOccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">ppParentOccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ccs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L625-L631","name":"Mathlib.Tactic.CC.CCState.ppParentOccsAux","line":625,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppParentOccsAux","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppParentOccsAux\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">ppParentOccsAux</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ccs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L616-L623","name":"Mathlib.Tactic.CC.CCState.ppEqcs","line":616,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppEqcs","doc":"Pretty print the entire cc graph.\nIf the `nonSingleton` argument is set to `true` then singleton equivalence classes will be\nomitted. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppEqcs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">ppEqcs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ccs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(nonSingleton : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L602-L614","name":"Mathlib.Tactic.CC.CCState.ppEqc","line":602,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppEqc","doc":"Pretty print the entry associated with the given expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.ppEqc\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">ppEqc</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ccs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L597-L598","name":"Mathlib.Tactic.CC.CCState.getVarWithLeastRHSOccs","line":597,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.getVarWithLeastRHSOccs","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.getVarWithLeastRHSOccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">getVarWithLeastRHSOccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ccs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L594-L595","name":"Mathlib.Tactic.CC.CCState.getVarWithLeastLHSOccs","line":594,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.getVarWithLeastLHSOccs","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.getVarWithLeastLHSOccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">getVarWithLeastLHSOccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ccs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L579-L592","name":"Mathlib.Tactic.CC.CCState.getVarWithLeastOccs","line":579,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.getVarWithLeastOccs","doc":"Search for the AC-variable (`Entry.acVar`) with the least occurrences in the state. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.getVarWithLeastOccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">getVarWithLeastOccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ccs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(inLHS : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L574-L577","name":"Mathlib.Tactic.CC.CCState.getNumROccs","line":574,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.getNumROccs","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.getNumROccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">getNumROccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ccs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(inLHS : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L570-L572","name":"Mathlib.Tactic.CC.CCState.checkInvariant","line":570,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.checkInvariant","doc":"Check for integrity of the `CCState`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.checkInvariant\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">checkInvariant</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ccs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L548-L568","name":"Mathlib.Tactic.CC.CCState.checkEqc","line":548,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.checkEqc","doc":"Check for integrity of the `CCState`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.checkEqc\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">checkEqc</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ccs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L537-L546","name":"Mathlib.Tactic.CC.CCState.getRoots","line":537,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.getRoots","doc":"Append to `roots` all the roots of equivalence classes in `ccs`.\n\nIf `nonsingletonOnly` is true, we skip all the singleton equivalence classes. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.getRoots\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">getRoots</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ccs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(roots : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(nonsingletonOnly : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L531-L535","name":"Mathlib.Tactic.CC.CCState.inSingletonEqc","line":531,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.inSingletonEqc","doc":"Is the expression in an equivalence class with only one element (namely, itself)? "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.inSingletonEqc\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">inSingletonEqc</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ccs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L520-L529","name":"Mathlib.Tactic.CC.CCState.mt","line":520,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.mt","doc":"\"Modification Time\". The field `mt` is used to implement the mod-time optimization introduced by the\nSimplify theorem prover. The basic idea is to introduce a counter `gmt` that records the number of\nheuristic instantiation that have occurred in the current branch. It is incremented after each round\nof heuristic instantiation. The field `mt` records the last time any proper descendant of this\nentry was involved in a merge. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.mt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">mt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ccs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L514-L518","name":"Mathlib.Tactic.CC.CCState.isCgRoot","line":514,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.isCgRoot","doc":"Check if `e` is the root of the congruence class. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.isCgRoot\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">isCgRoot</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ccs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L507-L512","name":"Mathlib.Tactic.CC.CCState.next","line":507,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.next","doc":"Get the next element in the equivalence class.\nNote that if the given `Expr` `e` is not in the graph then it will just return `e`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.next\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">next</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ccs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L501-L505","name":"Mathlib.Tactic.CC.CCState.root","line":501,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.root","doc":"Get the root representative of the given expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.root\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">root</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ccs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L481-L497","name":"Mathlib.Tactic.CC.CCState.mkEntryCore","line":481,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.mkEntryCore","doc":"Update the `CCState` by constructing and inserting a new `Entry`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.mkEntryCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">mkEntryCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ccs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(interpreted constructor : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L477-L477","name":"Mathlib.Tactic.CC.instInhabitedCCState","line":477,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedCCState","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedCCState\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instInhabitedCCState</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L476-L476","name":"Mathlib.Tactic.CC.CCState.gmt","line":476,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.gmt","doc":"\"Global Modification Time\". gmt is a number stored on the `CCState`,\nit is compared with the modification time of a cc_entry in e-matching. See `CCState.mt`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.gmt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">gmt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L473-L473","name":"Mathlib.Tactic.CC.CCState.inconsistent","line":473,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.inconsistent","doc":"Returns true if the `CCState` is inconsistent. For example if it had both `a = b` and `a ≠ b`\nin it."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.inconsistent\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">inconsistent</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L470-L470","name":"Mathlib.Tactic.CC.CCState.acR","line":470,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.acR","doc":"Records equality between `ACApps`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.acR\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">acR</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBACAppsMap\">Mathlib.Tactic.CC.RBACAppsMap</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L468-L468","name":"Mathlib.Tactic.CC.CCState.acEntries","line":468,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.acEntries","doc":"Extra `Entry` information used by the AC part of the tactic. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.acEntries\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">acEntries</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBExprMap\">Mathlib.Tactic.CC.RBExprMap</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry\">Mathlib.Tactic.CC.ACEntry</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L466-L466","name":"Mathlib.Tactic.CC.CCState.opInfo","line":466,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.opInfo","doc":"Whether the canonical operator is supported by AC. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.opInfo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">opInfo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBExprMap\">Mathlib.Tactic.CC.RBExprMap</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L464-L464","name":"Mathlib.Tactic.CC.CCState.canOps","line":464,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.canOps","doc":"Mapping from operators occurring in terms and their canonical\nrepresentation in this module "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.canOps\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">canOps</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBExprMap\">Mathlib.Tactic.CC.RBExprMap</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L461-L461","name":"Mathlib.Tactic.CC.CCState.frozePartitions","line":461,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.frozePartitions","doc":"The congruence closure module has a mode where the root of each equivalence class is marked as\nan interpreted/abstract value. Moreover, in this mode proof production is disabled.\nThis capability is useful for heuristic instantiation. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.frozePartitions\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">frozePartitions</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L457-L457","name":"Mathlib.Tactic.CC.CCState.instImplicitReprs","line":457,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.instImplicitReprs","doc":"Records which instances of the same class are defeq. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.instImplicitReprs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">instImplicitReprs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.InstImplicitReprs\">Mathlib.Tactic.CC.InstImplicitReprs</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L455-L455","name":"Mathlib.Tactic.CC.CCState.subsingletonReprs","line":455,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.subsingletonReprs","doc":"Stores the root representatives of subsingletons. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.subsingletonReprs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">subsingletonReprs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SubsingletonReprs\">Mathlib.Tactic.CC.SubsingletonReprs</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L454-L454","name":"Mathlib.Tactic.CC.CCState.symmCongruences","line":454,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.symmCongruences","doc":"Maps each expression to a set of expressions it might be congruent to,\nvia the symmetrical relation. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.symmCongruences\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">symmCongruences</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruences\">Mathlib.Tactic.CC.SymmCongruences</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L451-L451","name":"Mathlib.Tactic.CC.CCState.congruences","line":451,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.congruences","doc":"Maps each expression to a set of expressions it might be congruent to. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.congruences\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">congruences</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Congruences\">Mathlib.Tactic.CC.Congruences</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L449-L449","name":"Mathlib.Tactic.CC.CCState.parents","line":449,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.parents","doc":"Maps an expression `e` to the expressions `e` occurs in. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.parents\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">parents</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Parents\">Mathlib.Tactic.CC.Parents</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L447-L447","name":"Mathlib.Tactic.CC.CCState.entries","line":447,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.entries","doc":"Maps known expressions to their equivalence class data. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.entries\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">entries</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entries\">Mathlib.Tactic.CC.Entries</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L445-L445","name":"Mathlib.Tactic.CC.CCState.mk","line":445,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(toCCConfig : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig\">Mathlib.Tactic.CC.CCConfig</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(entries : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entries\">Mathlib.Tactic.CC.Entries</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(parents : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Parents\">Mathlib.Tactic.CC.Parents</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(congruences : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Congruences\">Mathlib.Tactic.CC.Congruences</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(symmCongruences : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruences\">Mathlib.Tactic.CC.SymmCongruences</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(subsingletonReprs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SubsingletonReprs\">Mathlib.Tactic.CC.SubsingletonReprs</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(instImplicitReprs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.InstImplicitReprs\">Mathlib.Tactic.CC.InstImplicitReprs</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(frozePartitions : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(canOps : <span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBExprMap\">Mathlib.Tactic.CC.RBExprMap</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(opInfo : <span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBExprMap\">Mathlib.Tactic.CC.RBExprMap</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(acEntries : <span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBExprMap\">Mathlib.Tactic.CC.RBExprMap</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry\">Mathlib.Tactic.CC.ACEntry</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(acR : <span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBACAppsMap\">Mathlib.Tactic.CC.RBACAppsMap</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(inconsistent : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(gmt : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\">Mathlib.Tactic.CC.CCState</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L441-L477","name":"Mathlib.Tactic.CC.CCState","line":441,"kind":"structure","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState","doc":"Congruence closure state.\nThis may be considered to be a set of expressions and an equivalence class over this set.\nThe equivalence class is generated by the equational rules that are added to the `CCState` and\ncongruence, that is, if `a = b` then `f(a) = f(b)` and so on. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCState</span></a></span><span class=\"decl_extends\">extends</span> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig\">Mathlib.Tactic.CC.CCConfig</a><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L439-L439","name":"Mathlib.Tactic.CC.ACTodoEntry","line":439,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACTodoEntry","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACTodoEntry\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACTodoEntry</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L437-L437","name":"Mathlib.Tactic.CC.TodoEntry","line":437,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.TodoEntry","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.TodoEntry\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">TodoEntry</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L434-L435","name":"Mathlib.Tactic.CC.InstImplicitReprs","line":434,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.InstImplicitReprs","doc":"Stores the root representatives of `.instImplicit` arguments. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.InstImplicitReprs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">InstImplicitReprs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L431-L432","name":"Mathlib.Tactic.CC.SubsingletonReprs","line":431,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SubsingletonReprs","doc":"Stores the root representatives of subsingletons. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SubsingletonReprs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">SubsingletonReprs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L424-L429","name":"Mathlib.Tactic.CC.SymmCongruences","line":424,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruences","doc":"The symmetric variant of `Congruences`.\n\nThe `Name` identifies which relation the congruence is considered for.\nNote that this only works for two-argument relations: `ModEq n` and `ModEq m` are considered the\nsame. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruences\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">SymmCongruences</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L422-L422","name":"Mathlib.Tactic.CC.instHashableSymmCongruencesKey","line":422,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instHashableSymmCongruencesKey","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instHashableSymmCongruencesKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instHashableSymmCongruencesKey</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Hashable\">Hashable</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey\">Mathlib.Tactic.CC.SymmCongruencesKey</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L422-L422","name":"Mathlib.Tactic.CC.instBEqSymmCongruencesKey","line":422,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instBEqSymmCongruencesKey","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instBEqSymmCongruencesKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instBEqSymmCongruencesKey</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey\">Mathlib.Tactic.CC.SymmCongruencesKey</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L421-L421","name":"Mathlib.Tactic.CC.SymmCongruencesKey.h₂","line":421,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey.h₂","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey.h₂\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">SymmCongruencesKey</span>.<span class=\"name\">h₂</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey\">Mathlib.Tactic.CC.SymmCongruencesKey</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L421-L421","name":"Mathlib.Tactic.CC.SymmCongruencesKey.h₁","line":421,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey.h₁","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey.h₁\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">SymmCongruencesKey</span>.<span class=\"name\">h₁</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey\">Mathlib.Tactic.CC.SymmCongruencesKey</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L420-L420","name":"Mathlib.Tactic.CC.SymmCongruencesKey.mk","line":420,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">SymmCongruencesKey</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(h₁ h₂ : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey\">Mathlib.Tactic.CC.SymmCongruencesKey</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L420-L422","name":"Mathlib.Tactic.CC.SymmCongruencesKey","line":420,"kind":"structure","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">SymmCongruencesKey</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L417-L418","name":"Mathlib.Tactic.CC.Congruences","line":417,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Congruences","doc":"Maps each expression (via `mkCongruenceKey`) to expressions it might be congruent to. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Congruences\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Congruences</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L415-L415","name":"Mathlib.Tactic.CC.instHashableCongruencesKey","line":415,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instHashableCongruencesKey","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instHashableCongruencesKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instHashableCongruencesKey</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Hashable\">Hashable</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CongruencesKey\">Mathlib.Tactic.CC.CongruencesKey</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L415-L415","name":"Mathlib.Tactic.CC.instBEqCongruencesKey","line":415,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instBEqCongruencesKey","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instBEqCongruencesKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instBEqCongruencesKey</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CongruencesKey\">Mathlib.Tactic.CC.CongruencesKey</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L413-L414","name":"Mathlib.Tactic.CC.CongruencesKey.ho","line":413,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CongruencesKey.ho","doc":"`fn` is Higher-Order. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CongruencesKey.ho\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CongruencesKey</span>.<span class=\"name\">ho</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(fn arg : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CongruencesKey\">Mathlib.Tactic.CC.CongruencesKey</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L411-L412","name":"Mathlib.Tactic.CC.CongruencesKey.fo","line":411,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CongruencesKey.fo","doc":"`fn` is First-Order: we do not consider all partial applications. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CongruencesKey.fo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CongruencesKey</span>.<span class=\"name\">fo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(fn : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(args : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CongruencesKey\">Mathlib.Tactic.CC.CongruencesKey</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L410-L415","name":"Mathlib.Tactic.CC.CongruencesKey","line":410,"kind":"inductive","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CongruencesKey","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CongruencesKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CongruencesKey</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L405-L408","name":"Mathlib.Tactic.CC.Parents","line":405,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Parents","doc":"Used to map an expression `e` to another expression that contains `e`.\n\nWhen `e` is normalized, its parents should also change. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Parents\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Parents</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L402-L403","name":"Mathlib.Tactic.CC.ParentOccSet","line":402,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOccSet","doc":"Red-black sets of `ParentOcc`s. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOccSet\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ParentOccSet</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L400-L400","name":"Mathlib.Tactic.CC.ParentOcc.symmTable","line":400,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOcc.symmTable","doc":"If `symmTable` is true, then we should use the `symmCongruences`, otherwise `congruences`.\nRemark: this information is redundant, it can be inferred from `expr`. We use store it for\nperformance reasons. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOcc.symmTable\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ParentOcc</span>.<span class=\"name\">symmTable</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOcc\">Mathlib.Tactic.CC.ParentOcc</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L396-L396","name":"Mathlib.Tactic.CC.ParentOcc.expr","line":396,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOcc.expr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOcc.expr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ParentOcc</span>.<span class=\"name\">expr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOcc\">Mathlib.Tactic.CC.ParentOcc</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L395-L395","name":"Mathlib.Tactic.CC.ParentOcc.mk","line":395,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOcc.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOcc.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ParentOcc</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(expr : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(symmTable : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOcc\">Mathlib.Tactic.CC.ParentOcc</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L394-L400","name":"Mathlib.Tactic.CC.ParentOcc","line":394,"kind":"structure","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOcc","doc":"Used to record when an expression processed by `cc` occurs in another expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ParentOcc\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ParentOcc</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L389-L392","name":"Mathlib.Tactic.CC.ACEntry.ROccs","line":389,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry.ROccs","doc":"Returns the occurrences of this entry in either the LHS or RHS. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry.ROccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACEntry</span>.<span class=\"name\">ROccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ent : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry\">Mathlib.Tactic.CC.ACEntry</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(inLHS : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBACAppsSet\">Mathlib.Tactic.CC.RBACAppsSet</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L387-L387","name":"Mathlib.Tactic.CC.instInhabitedACEntry","line":387,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedACEntry","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedACEntry\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instInhabitedACEntry</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry\">Mathlib.Tactic.CC.ACEntry</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L386-L386","name":"Mathlib.Tactic.CC.ACEntry.RRHSOccs","line":386,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry.RRHSOccs","doc":"AC variables that occur on the **left** hand side of an equality which `e` occurs as the right\nhand side of in `CCState.acR`. Don't confuse. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry.RRHSOccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACEntry</span>.<span class=\"name\">RRHSOccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry\">Mathlib.Tactic.CC.ACEntry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBACAppsSet\">Mathlib.Tactic.CC.RBACAppsSet</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L383-L383","name":"Mathlib.Tactic.CC.ACEntry.RLHSOccs","line":383,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry.RLHSOccs","doc":"AC variables that occur on the left hand side of an equality which `e` occurs as the left hand\nside of in `CCState.acR`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry.RLHSOccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACEntry</span>.<span class=\"name\">RLHSOccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry\">Mathlib.Tactic.CC.ACEntry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBACAppsSet\">Mathlib.Tactic.CC.RBACAppsSet</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L380-L380","name":"Mathlib.Tactic.CC.ACEntry.idx","line":380,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry.idx","doc":"Natural number associated to an expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry.idx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACEntry</span>.<span class=\"name\">idx</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry\">Mathlib.Tactic.CC.ACEntry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L378-L378","name":"Mathlib.Tactic.CC.ACEntry.mk","line":378,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACEntry</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(idx : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(RLHSOccs RRHSOccs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBACAppsSet\">Mathlib.Tactic.CC.RBACAppsSet</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry\">Mathlib.Tactic.CC.ACEntry</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L376-L387","name":"Mathlib.Tactic.CC.ACEntry","line":376,"kind":"structure","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry","doc":"Equivalence class data associated with an expression `e` used by AC congruence closure\nmodules. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACEntry\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACEntry</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L373-L374","name":"Mathlib.Tactic.CC.Entries","line":373,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entries","doc":"Stores equivalence class data associated with an expression `e`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entries\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entries</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L371-L371","name":"Mathlib.Tactic.CC.instInhabitedEntry","line":371,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedEntry","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedEntry\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instInhabitedEntry</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Mathlib.Tactic.CC.Entry</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L370-L370","name":"Mathlib.Tactic.CC.Entry.mt","line":370,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.mt","doc":"The field `mt` is used to implement the mod-time optimization introduce by the Simplify\ntheorem prover. The basic idea is to introduce a counter gmt that records the number of\nheuristic instantiation that have occurred in the current branch. It is incremented after each\nround of heuristic instantiation. The field `mt` records the last time any proper descendant\nof this entry was involved in a merge. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.mt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">mt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Mathlib.Tactic.CC.Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L364-L364","name":"Mathlib.Tactic.CC.Entry.size","line":364,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.size","doc":"number of elements in the equivalence class, it is meaningless if `e != root` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.size\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">size</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Mathlib.Tactic.CC.Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L362-L362","name":"Mathlib.Tactic.CC.Entry.fo","line":362,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.fo","doc":"If `fo == true`, then the expression associated with this entry is an application, and we are\nusing first-order approximation to encode it. That is, we ignore its partial applications. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.fo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">fo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Mathlib.Tactic.CC.Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L359-L359","name":"Mathlib.Tactic.CC.Entry.heqProofs","line":359,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.heqProofs","doc":"`heqProofs == true` iff some proofs in the equivalence class are based on heterogeneous\nequality. We represent equality and heterogeneous equality in a single equivalence class. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.heqProofs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">heqProofs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Mathlib.Tactic.CC.Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L356-L356","name":"Mathlib.Tactic.CC.Entry.hasLambdas","line":356,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.hasLambdas","doc":"`true` if equivalence class contains lambda expressions "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.hasLambdas\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">hasLambdas</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Mathlib.Tactic.CC.Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L354-L354","name":"Mathlib.Tactic.CC.Entry.constructor","line":354,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.constructor","doc":"`true` if head symbol is a constructor "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.constructor\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">constructor</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Mathlib.Tactic.CC.Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L352-L352","name":"Mathlib.Tactic.CC.Entry.interpreted","line":352,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.interpreted","doc":"`true` if the node should be viewed as an abstract value "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.interpreted\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">interpreted</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Mathlib.Tactic.CC.Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L350-L350","name":"Mathlib.Tactic.CC.Entry.flipped","line":350,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.flipped","doc":"proof has been flipped "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.flipped\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">flipped</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Mathlib.Tactic.CC.Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L348-L348","name":"Mathlib.Tactic.CC.Entry.acVar","line":348,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.acVar","doc":"Variable in the AC theory. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.acVar\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">acVar</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Mathlib.Tactic.CC.Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L346-L346","name":"Mathlib.Tactic.CC.Entry.proof","line":346,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.proof","doc":"When `e` was added to this equivalence class because of an equality `(H : e = tgt)`, then\nwe store `tgt` at `target`, and `H` at `proof`. Both fields are none if `e == root` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.proof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">proof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Mathlib.Tactic.CC.Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">Mathlib.Tactic.CC.EntryExpr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L343-L343","name":"Mathlib.Tactic.CC.Entry.target","line":343,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.target","doc":"When `e` was added to this equivalence class because of an equality `(H : e = tgt)`, then\nwe store `tgt` at `target`, and `H` at `proof`. Both fields are none if `e == root` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.target\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">target</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Mathlib.Tactic.CC.Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L340-L340","name":"Mathlib.Tactic.CC.Entry.cgRoot","line":340,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.cgRoot","doc":"root of the congruence class, it is meaningless if `e` is not an application. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.cgRoot\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">cgRoot</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Mathlib.Tactic.CC.Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L338-L338","name":"Mathlib.Tactic.CC.Entry.root","line":338,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.root","doc":"root (aka canonical) representative of the equivalence class. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.root\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">root</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Mathlib.Tactic.CC.Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L336-L336","name":"Mathlib.Tactic.CC.Entry.next","line":336,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.next","doc":"next element in the equivalence class. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.next\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">next</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Mathlib.Tactic.CC.Entry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L334-L334","name":"Mathlib.Tactic.CC.Entry.mk","line":334,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(next root cgRoot : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(target : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(proof : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">Mathlib.Tactic.CC.EntryExpr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(acVar : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(flipped interpreted constructor hasLambdas heqProofs fo : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(size mt : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Mathlib.Tactic.CC.Entry</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L333-L371","name":"Mathlib.Tactic.CC.Entry","line":333,"kind":"structure","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry","doc":"Equivalence class data associated with an expression `e`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">Entry</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L330-L330","name":"Mathlib.Tactic.CC.instCoeExprEntryExpr","line":330,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instCoeExprEntryExpr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instCoeExprEntryExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instCoeExprEntryExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#Coe\">Coe</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">Mathlib.Tactic.CC.EntryExpr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L322-L328","name":"Mathlib.Tactic.CC.instToMessageDataEntryExpr","line":322,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instToMessageDataEntryExpr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instToMessageDataEntryExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instToMessageDataEntryExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Message.html#Lean.ToMessageData\">Lean.ToMessageData</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">Mathlib.Tactic.CC.EntryExpr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L320-L320","name":"Mathlib.Tactic.CC.instInhabitedEntryExpr","line":320,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedEntryExpr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedEntryExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instInhabitedEntryExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">Mathlib.Tactic.CC.EntryExpr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L318-L319","name":"Mathlib.Tactic.CC.EntryExpr.ofDExpr","line":318,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr.ofDExpr","doc":"An `EntryExpr` of a `DelayedExpr`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr.ofDExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">EntryExpr</span>.<span class=\"name\">ofDExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">Mathlib.Tactic.CC.EntryExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L316-L317","name":"Mathlib.Tactic.CC.EntryExpr.refl","line":316,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr.refl","doc":"dummy refl proof, it is just a placeholder. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr.refl\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">EntryExpr</span>.<span class=\"name\">refl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">Mathlib.Tactic.CC.EntryExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L314-L315","name":"Mathlib.Tactic.CC.EntryExpr.eqTrue","line":314,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr.eqTrue","doc":"dummy eq_true proof, it is just a placeholder "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr.eqTrue\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">EntryExpr</span>.<span class=\"name\">eqTrue</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">Mathlib.Tactic.CC.EntryExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L312-L313","name":"Mathlib.Tactic.CC.EntryExpr.congr","line":312,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr.congr","doc":"dummy congruence proof, it is just a placeholder. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr.congr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">EntryExpr</span>.<span class=\"name\">congr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">Mathlib.Tactic.CC.EntryExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L310-L311","name":"Mathlib.Tactic.CC.EntryExpr.ofExpr","line":310,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr.ofExpr","doc":"An `EntryExpr` of just an `Expr`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr.ofExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">EntryExpr</span>.<span class=\"name\">ofExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">Mathlib.Tactic.CC.EntryExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L308-L320","name":"Mathlib.Tactic.CC.EntryExpr","line":308,"kind":"inductive","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr","doc":"This is used as a proof term in `Entry`s instead of `Expr`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">EntryExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L305-L305","name":"Mathlib.Tactic.CC.instCoeExprDelayedExpr","line":305,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instCoeExprDelayedExpr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instCoeExprDelayedExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instCoeExprDelayedExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#Coe\">Coe</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L303-L303","name":"Mathlib.Tactic.CC.instInhabitedDelayedExpr","line":303,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedDelayedExpr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedDelayedExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instInhabitedDelayedExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L301-L302","name":"Mathlib.Tactic.CC.DelayedExpr.heqSymm","line":301,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.heqSymm","doc":"Will be applied to `HEq.symm`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.heqSymm\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">DelayedExpr</span>.<span class=\"name\">heqSymm</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(h : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L299-L300","name":"Mathlib.Tactic.CC.DelayedExpr.heqOfEq","line":299,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.heqOfEq","doc":"Will be applied to `heq_of_eq`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.heqOfEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">DelayedExpr</span>.<span class=\"name\">heqOfEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(h : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L297-L298","name":"Mathlib.Tactic.CC.DelayedExpr.eqTransOpt","line":297,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.eqTransOpt","doc":"Will be applied to `Eq.trans`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.eqTransOpt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">DelayedExpr</span>.<span class=\"name\">eqTransOpt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(a₁ a₂ a₃ : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h₁ h₂ : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L295-L296","name":"Mathlib.Tactic.CC.DelayedExpr.eqTrans","line":295,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.eqTrans","doc":"Will be applied to `Eq.trans`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.eqTrans\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">DelayedExpr</span>.<span class=\"name\">eqTrans</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(h₁ h₂ : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L293-L294","name":"Mathlib.Tactic.CC.DelayedExpr.eqSymmOpt","line":293,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.eqSymmOpt","doc":"Will be applied to `Eq.symm`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.eqSymmOpt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">DelayedExpr</span>.<span class=\"name\">eqSymmOpt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(a₁ a₂ : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L291-L292","name":"Mathlib.Tactic.CC.DelayedExpr.eqSymm","line":291,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.eqSymm","doc":"Will be applied to `Eq.symm`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.eqSymm\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">DelayedExpr</span>.<span class=\"name\">eqSymm</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(h : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L289-L290","name":"Mathlib.Tactic.CC.DelayedExpr.congrFun","line":289,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.congrFun","doc":"Will be applied to `congr_fun`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.congrFun\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">DelayedExpr</span>.<span class=\"name\">congrFun</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(h : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L287-L288","name":"Mathlib.Tactic.CC.DelayedExpr.congrArg","line":287,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.congrArg","doc":"Will be applied to `congr_arg`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.congrArg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">DelayedExpr</span>.<span class=\"name\">congrArg</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(f : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L284-L286","name":"Mathlib.Tactic.CC.DelayedExpr.eqProof","line":284,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.eqProof","doc":"A placeholder as an equality proof between given two terms which will be generated by non-AC\ncongruence closure modules later. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.eqProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">DelayedExpr</span>.<span class=\"name\">eqProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(lhs rhs : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L282-L283","name":"Mathlib.Tactic.CC.DelayedExpr.ofExpr","line":282,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.ofExpr","doc":"A `DelayedExpr` of just an `Expr`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr.ofExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">DelayedExpr</span>.<span class=\"name\">ofExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L278-L303","name":"Mathlib.Tactic.CC.DelayedExpr","line":278,"kind":"inductive","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr","doc":"For proof terms generated by AC congruence closure modules, we want a placeholder as an equality\nproof between given two terms which will be generated by non-AC congruence closure modules later.\n`DelayedExpr` represents it using `eqProof`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">DelayedExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L270-L276","name":"Mathlib.Tactic.CC.RBACAppsSet","line":270,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBACAppsSet","doc":"Red-black sets of `ACApps`es.\n\nTODO: the choice between `RBSet` and `HashSet` is not obvious:\nthe current version follows the Lean 3 C++ implementation.\nOnce the `cc` tactic is used a lot in Mathlib, we should profile and see\nif `HashSet` could be more optimal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBACAppsSet\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">RBACAppsSet</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L262-L268","name":"Mathlib.Tactic.CC.RBACAppsMap","line":262,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBACAppsMap","doc":"Red-black maps whose keys are `ACApps`es.\n\nTODO: the choice between `RBMap` and `HashMap` is not obvious:\nthe current version follows the Lean 3 C++ implementation.\nOnce the `cc` tactic is used a lot in Mathlib, we should profile and see\nif `HashMap` could be more optimal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBACAppsMap\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">RBACAppsMap</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(α : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u</div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L256-L260","name":"Mathlib.Tactic.CC.ACApps.toExpr","line":256,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.toExpr","doc":"Converts an `ACApps` to an `Expr`. This returns `none` when the empty applications are given. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.toExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACApps</span>.<span class=\"name\">toExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L248-L254","name":"Mathlib.Tactic.CC.ACApps.mkFlatApps","line":248,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.mkFlatApps","doc":"Flattens given two `ACApps`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.mkFlatApps\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACApps</span>.<span class=\"name\">mkFlatApps</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(op : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e₁ e₂ : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L244-L246","name":"Mathlib.Tactic.CC.ACApps.mkApps","line":244,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.mkApps","doc":"Sorts `args` and applies them to `ACApps.apps`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.mkApps\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACApps</span>.<span class=\"name\">mkApps</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(op : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(args : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L225-L242","name":"Mathlib.Tactic.CC.ACApps.intersection","line":225,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.intersection","doc":"Appends elements in the intersection of `e₁` and `e₂` to `r`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.intersection\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACApps</span>.<span class=\"name\">intersection</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e₁ e₂ : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(r : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <span class=\"fn\">#[]</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L217-L223","name":"Mathlib.Tactic.CC.ACApps.append","line":217,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.append","doc":"Appends arguments of `e` to `r`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.append\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACApps</span>.<span class=\"name\">append</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(op : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(r : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <span class=\"fn\">#[]</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L187-L215","name":"Mathlib.Tactic.CC.ACApps.diff","line":187,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.diff","doc":"Appends elements of the set difference `e₁ \\ e₂` to `r`.\nExample: given `e₁ := a*a*a*a*b*b*c*d*d*d` and `e₂ := a*a*a*b*b*d`,\nthe result is `#[a, c, d, d]`\n\nPrecondition: `e₂.isSubset e₁` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.diff\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACApps</span>.<span class=\"name\">diff</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e₁ e₂ : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(r : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <span class=\"fn\">#[]</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L163-L185","name":"Mathlib.Tactic.CC.ACApps.isSubset","line":163,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.isSubset","doc":"Return true iff `e₁` is a \"subset\" of `e₂`.\n\nExample: The result is `true` for `e₁ := a*a*a*b*d` and `e₂ := a*a*a*a*b*b*c*d*d`.\nThe result is also `true` for `e₁ := a` and `e₂ := a*a*a*b*c`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.isSubset\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACApps</span>.<span class=\"name\">isSubset</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e₁ e₂ : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L149-L161","name":"Mathlib.Tactic.CC.instOrdACApps","line":149,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instOrdACApps","doc":"Ordering on `ACApps` sorts `.ofExpr` before `.apps`, and sorts `.apps` by function symbol,\nthen by shortlex order. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instOrdACApps\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instOrdACApps</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Ord.html#Ord\">Ord</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L146-L146","name":"Mathlib.Tactic.CC.instCoeExprACApps","line":146,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instCoeExprACApps","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instCoeExprACApps\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instCoeExprACApps</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#Coe\">Coe</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L144-L144","name":"Mathlib.Tactic.CC.instBEqACApps","line":144,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instBEqACApps","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instBEqACApps\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instBEqACApps</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L144-L144","name":"Mathlib.Tactic.CC.instInhabitedACApps","line":144,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedACApps","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedACApps\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instInhabitedACApps</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L140-L143","name":"Mathlib.Tactic.CC.ACApps.apps","line":140,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.apps","doc":"An `ACApps` of applications of a binary operator. `args` are assumed to be sorted.\n\nSee also `ACApps.mkApps` if `args` are not yet sorted. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.apps\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACApps</span>.<span class=\"name\">apps</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(op : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(args : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L138-L139","name":"Mathlib.Tactic.CC.ACApps.ofExpr","line":138,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.ofExpr","doc":"An `ACApps` of just an `Expr`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps.ofExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACApps</span>.<span class=\"name\">ofExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L135-L144","name":"Mathlib.Tactic.CC.ACApps","line":135,"kind":"inductive","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps","doc":"An `ACApps` represents either just an `Expr` or applications of an associative and commutative\nbinary operator. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">ACApps</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L133-L133","name":"Mathlib.Tactic.CC.instInhabitedCCConfig","line":133,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedCCConfig","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instInhabitedCCConfig\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instInhabitedCCConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig\">Mathlib.Tactic.CC.CCConfig</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L132-L132","name":"Mathlib.Tactic.CC.CCConfig.values","line":132,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig.values","doc":"If `true`, we treat values as atomic symbols "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig.values\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCConfig</span>.<span class=\"name\">values</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig\">Mathlib.Tactic.CC.CCConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L130-L130","name":"Mathlib.Tactic.CC.CCConfig.em","line":130,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig.em","doc":"If `true`, then use excluded middle "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig.em\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCConfig</span>.<span class=\"name\">em</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig\">Mathlib.Tactic.CC.CCConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L128-L128","name":"Mathlib.Tactic.CC.CCConfig.hoFns","line":128,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig.hoFns","doc":"If `hoFns` is `some fns`, then full (and more expensive) support for higher-order functions is\n*only* considered for the functions in fns and local functions. The performance overhead is\ndescribed in the paper \"Congruence Closure in Intensional Type Theory\". If `hoFns` is `none`,\nthen full support is provided for *all* constants. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig.hoFns\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCConfig</span>.<span class=\"name\">hoFns</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig\">Mathlib.Tactic.CC.CCConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L123-L123","name":"Mathlib.Tactic.CC.CCConfig.ac","line":123,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig.ac","doc":"If `true`, congruence closure modulo Associativity and Commutativity. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig.ac\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCConfig</span>.<span class=\"name\">ac</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig\">Mathlib.Tactic.CC.CCConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L121-L121","name":"Mathlib.Tactic.CC.CCConfig.ignoreInstances","line":121,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig.ignoreInstances","doc":"If `true`, congruence closure will treat implicit instance arguments as constants.\n\nThis means that setting `ignoreInstances := false` will fail to unify two definitionally equal\ninstances of the same class. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig.ignoreInstances\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCConfig</span>.<span class=\"name\">ignoreInstances</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig\">Mathlib.Tactic.CC.CCConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L116-L116","name":"Mathlib.Tactic.CC.CCConfig.mk","line":116,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCConfig</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ignoreInstances ac : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hoFns : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(em values : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig\">Mathlib.Tactic.CC.CCConfig</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L115-L133","name":"Mathlib.Tactic.CC.CCConfig","line":115,"kind":"structure","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig","doc":"Configs used in congruence closure modules. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L112-L113","name":"Mathlib.Tactic.CC.CCCongrTheoremCache","line":112,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremCache","doc":"Caches used to find corresponding `CCCongrTheorem`s. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremCache\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCCongrTheoremCache</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L110-L110","name":"Mathlib.Tactic.CC.instHashableCCCongrTheoremKey","line":110,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instHashableCCCongrTheoremKey","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instHashableCCCongrTheoremKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instHashableCCCongrTheoremKey</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Hashable\">Hashable</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey\">Mathlib.Tactic.CC.CCCongrTheoremKey</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L110-L110","name":"Mathlib.Tactic.CC.instBEqCCCongrTheoremKey","line":110,"kind":"instance","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instBEqCCCongrTheoremKey","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instBEqCCCongrTheoremKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instBEqCCCongrTheoremKey</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey\">Mathlib.Tactic.CC.CCCongrTheoremKey</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L109-L109","name":"Mathlib.Tactic.CC.CCCongrTheoremKey.nargs","line":109,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey.nargs","doc":"The number of arguments of `fn`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey.nargs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCCongrTheoremKey</span>.<span class=\"name\">nargs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey\">Mathlib.Tactic.CC.CCCongrTheoremKey</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L107-L107","name":"Mathlib.Tactic.CC.CCCongrTheoremKey.fn","line":107,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey.fn","doc":"The function of the given `CCCongrTheorem`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey.fn\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCCongrTheoremKey</span>.<span class=\"name\">fn</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey\">Mathlib.Tactic.CC.CCCongrTheoremKey</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L105-L105","name":"Mathlib.Tactic.CC.CCCongrTheoremKey.mk","line":105,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCCongrTheoremKey</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(fn : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(nargs : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey\">Mathlib.Tactic.CC.CCCongrTheoremKey</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L104-L110","name":"Mathlib.Tactic.CC.CCCongrTheoremKey","line":104,"kind":"structure","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey","doc":"Keys used to find corresponding `CCCongrTheorem`s. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCCongrTheoremKey</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L95-L102","name":"Mathlib.Tactic.CC.mkCCHCongrWithArity","line":95,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.mkCCHCongrWithArity","doc":"Automatically generated congruence lemma based on heterogeneous equality.\n\nThis returns an annotated version of the result from `Lean.Meta.mkHCongrWithArity`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.mkCCHCongrWithArity\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">mkCCHCongrWithArity</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(fn : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(nargs : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem\">Mathlib.Tactic.CC.CCCongrTheorem</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L93-L93","name":"Mathlib.Tactic.CC.CCCongrTheorem.hcongrTheorem","line":93,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem.hcongrTheorem","doc":"If `hcongrTheorem` is true, then lemma was created using `mkHCongrWithArity`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem.hcongrTheorem\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCCongrTheorem</span>.<span class=\"name\">hcongrTheorem</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem\">Mathlib.Tactic.CC.CCCongrTheorem</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L91-L91","name":"Mathlib.Tactic.CC.CCCongrTheorem.heqResult","line":91,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem.heqResult","doc":"If `heqResult` is true, then lemma is based on heterogeneous equality\nand the conclusion is a heterogeneous equality. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem.heqResult\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCCongrTheorem</span>.<span class=\"name\">heqResult</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem\">Mathlib.Tactic.CC.CCCongrTheorem</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L88-L88","name":"Mathlib.Tactic.CC.CCCongrTheorem.mk","line":88,"kind":"ctor","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCCongrTheorem</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(toCongrTheorem : <a href=\"./Lean/Meta/CongrTheorems.html#Lean.Meta.CongrTheorem\">Lean.Meta.CongrTheorem</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(heqResult hcongrTheorem : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem\">Mathlib.Tactic.CC.CCCongrTheorem</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L87-L93","name":"Mathlib.Tactic.CC.CCCongrTheorem","line":87,"kind":"structure","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem","doc":"`CongrTheorem`s equipped with additional infos used by congruence closure modules. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCCongrTheorem</span></a></span><span class=\"decl_extends\">extends</span> <a href=\"./Lean/Meta/CongrTheorems.html#Lean.Meta.CongrTheorem\">Lean.Meta.CongrTheorem</a><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L79-L85","name":"Mathlib.Tactic.CC.RBExprSet","line":79,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBExprSet","doc":"Red-black sets of `Expr`s.\n\nTODO: the choice between `RBSet` and `HashSet` is not obvious:\nthe current version follows the Lean 3 C++ implementation.\nOnce the `cc` tactic is used a lot in Mathlib, we should profile and see\nif `HashSet` could be more optimal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBExprSet\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">RBExprSet</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L71-L77","name":"Mathlib.Tactic.CC.RBExprMap","line":71,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBExprMap","doc":"Red-black maps whose keys are `Expr`s.\n\nTODO: the choice between `RBMap` and `HashMap` is not obvious:\nthe current version follows the Lean 3 C++ implementation.\nOnce the `cc` tactic is used a lot in Mathlib, we should profile and see\nif `HashMap` could be more optimal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.RBExprMap\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">RBExprMap</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(α : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u</div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L67-L69","name":"Mathlib.Tactic.CC.instOrdExpr_mathlib","line":67,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instOrdExpr_mathlib","doc":"Ordering on `Expr`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.instOrdExpr_mathlib\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">instOrdExpr_mathlib</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Ord.html#Ord\">Ord</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L46-L65","name":"Mathlib.Tactic.CC.liftFromEq","line":46,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.liftFromEq","doc":"Given a reflexive relation `R`, and a proof `H : a = b`, build a proof for `R a b` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.liftFromEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">liftFromEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(R : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(H : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L33-L44","name":"Mathlib.Tactic.CC.isInterpretedValue","line":33,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.isInterpretedValue","doc":"Return true if `e` represents a value (nat/int numeral, character, or string).\n\nIn addition to the conditions in `Mathlib.Tactic.CC.isValue`, this also checks that\nkernel computation can compare the values for equality. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.isInterpretedValue\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">isInterpretedValue</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Datatypes.lean#L29-L31","name":"Mathlib.Tactic.CC.isValue","line":29,"kind":"def","docLink":"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.isValue","doc":"Return true if `e` represents a constant value (numeral, character, or string). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.isValue\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">isValue</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"}]}