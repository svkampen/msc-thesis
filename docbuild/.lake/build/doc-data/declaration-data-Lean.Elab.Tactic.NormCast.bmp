{"name":"Lean.Elab.Tactic.NormCast","instances":[],"imports":["Lean.Meta.Tactic.NormCast","Lean.Elab.Tactic.Conv.Simp","Lean.Elab.ElabRules"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Elab/Tactic/NormCast.lean#L271-L276","name":"Lean.Elab.Tactic.NormCast.elabAddElim","line":271,"kind":"def","docLink":"./Lean/Elab/Tactic/NormCast.html#Lean.Elab.Tactic.NormCast.elabAddElim","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/NormCast.html#Lean.Elab.Tactic.NormCast.elabAddElim\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">elabAddElim</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Command.html#Lean.Elab.Command.CommandElab\">Lean.Elab.Command.CommandElab</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Elab/Tactic/NormCast.lean#L262-L268","name":"Lean.Elab.Tactic.NormCast.evalPushCast","line":262,"kind":"def","docLink":"./Lean/Elab/Tactic/NormCast.html#Lean.Elab.Tactic.NormCast.evalPushCast","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/NormCast.html#Lean.Elab.Tactic.NormCast.evalPushCast\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">evalPushCast</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.Tactic\">Lean.Elab.Tactic.Tactic</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Elab/Tactic/NormCast.lean#L257-L260","name":"Lean.Elab.Tactic.NormCast.evalConvNormCast","line":257,"kind":"def","docLink":"./Lean/Elab/Tactic/NormCast.html#Lean.Elab.Tactic.NormCast.evalConvNormCast","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/NormCast.html#Lean.Elab.Tactic.NormCast.evalConvNormCast\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">evalConvNormCast</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.Tactic\">Lean.Elab.Tactic.Tactic</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Elab/Tactic/NormCast.lean#L242-L255","name":"Lean.Elab.Tactic.NormCast.evalNormCast0","line":242,"kind":"def","docLink":"./Lean/Elab/Tactic/NormCast.html#Lean.Elab.Tactic.NormCast.evalNormCast0","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/NormCast.html#Lean.Elab.Tactic.NormCast.evalNormCast0\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">evalNormCast0</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.Tactic\">Lean.Elab.Tactic.Tactic</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Elab/Tactic/NormCast.lean#L235-L240","name":"Lean.Elab.Tactic.NormCast.normCastHyp","line":235,"kind":"def","docLink":"./Lean/Elab/Tactic/NormCast.html#Lean.Elab.Tactic.NormCast.normCastHyp","doc":"Implementation of the `norm_cast` tactic when operating on a hypothesis. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/NormCast.html#Lean.Elab.Tactic.NormCast.normCastHyp\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">normCastHyp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(fvarId : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Elab/Tactic/NormCast.lean#L228-L233","name":"Lean.Elab.Tactic.NormCast.normCastTarget","line":228,"kind":"def","docLink":"./Lean/Elab/Tactic/NormCast.html#Lean.Elab.Tactic.NormCast.normCastTarget","doc":"Implementation of the `norm_cast` tactic when operating on the main goal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/NormCast.html#Lean.Elab.Tactic.NormCast.normCastTarget\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">normCastTarget</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Elab/Tactic/NormCast.lean#L211-L226","name":"Lean.Elab.Tactic.NormCast.elabModCast","line":211,"kind":"def","docLink":"./Lean/Elab/Tactic/NormCast.html#Lean.Elab.Tactic.NormCast.elabModCast","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/NormCast.html#Lean.Elab.Tactic.NormCast.elabModCast\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">elabModCast</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElab\">Lean.Elab.Term.TermElab</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Elab/Tactic/NormCast.lean#L169-L208","name":"Lean.Elab.Tactic.NormCast.derive","line":169,"kind":"def","docLink":"./Lean/Elab/Tactic/NormCast.html#Lean.Elab.Tactic.NormCast.derive","doc":"The core simplification routine of `normCast`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/NormCast.html#Lean.Elab.Tactic.NormCast.derive\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">derive</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Elab/Tactic/NormCast.lean#L158-L167","name":"Lean.Elab.Tactic.NormCast.numeralToCoe","line":158,"kind":"def","docLink":"./Lean/Elab/Tactic/NormCast.html#Lean.Elab.Tactic.NormCast.numeralToCoe","doc":"If possible, rewrites `(n : α)` to `(Nat.cast n : α)` where `n` is a numeral and `α ≠ ℕ`.\nReturns a pair of the new expression and proof that they are equal.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/NormCast.html#Lean.Elab.Tactic.NormCast.numeralToCoe\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">numeralToCoe</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Elab/Tactic/NormCast.lean#L141-L156","name":"Lean.Elab.Tactic.NormCast.upwardAndElim","line":141,"kind":"def","docLink":"./Lean/Elab/Tactic/NormCast.html#Lean.Elab.Tactic.NormCast.upwardAndElim","doc":"Core rewriting function used in the \"squash\" step, which moves casts upwards\nand eliminates them.\n\nIt tries to rewrite an expression using the elim and move lemmas.\nOn failure, it calls the splitting procedure heuristic.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/NormCast.html#Lean.Elab.Tactic.NormCast.upwardAndElim\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">upwardAndElim</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(up : <a href=\"./Lean/Meta/Tactic/Simp/SimpTheorems.html#Lean.Meta.SimpTheorems\">Lean.Meta.SimpTheorems</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.SimpM\">Lean.Meta.SimpM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Step\">Lean.Meta.Simp.Step</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Elab/Tactic/NormCast.lean#L132-L139","name":"Lean.Elab.Tactic.NormCast.prove","line":132,"kind":"def","docLink":"./Lean/Elab/Tactic/NormCast.html#Lean.Elab.Tactic.NormCast.prove","doc":"Discharging function used during simplification in the \"squash\" step.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/NormCast.html#Lean.Elab.Tactic.NormCast.prove\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">prove</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.SimpM\">Lean.Meta.SimpM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Elab/Tactic/NormCast.lean#L69-L130","name":"Lean.Elab.Tactic.NormCast.splittingProcedure","line":69,"kind":"def","docLink":"./Lean/Elab/Tactic/NormCast.html#Lean.Elab.Tactic.NormCast.splittingProcedure","doc":"This is the main heuristic used alongside the elim and move lemmas.\nThe goal is to help casts move past operators by adding intermediate casts.\nAn expression of the shape:\n```\nop (↑(x : α) : γ) (↑(y : β) : γ)\n```\nis rewritten to:\n```\nop (↑(↑(x : α) : β) : γ) (↑(y : β) : γ)\n```\nwhen\n```\n(↑(↑(x : α) : β) : γ) = (↑(x : α) : γ)\n```\ncan be proven with a squash lemma\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/NormCast.html#Lean.Elab.Tactic.NormCast.splittingProcedure\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">splittingProcedure</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(expr : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Elab/Tactic/NormCast.lean#L55-L67","name":"Lean.Elab.Tactic.NormCast.isNumeral?","line":55,"kind":"def","docLink":"./Lean/Elab/Tactic/NormCast.html#Lean.Elab.Tactic.NormCast.isNumeral?","doc":"Checks whether an expression is a numeral in some type,\nand if so returns that type and the natural number.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/NormCast.html#Lean.Elab.Tactic.NormCast.isNumeral?\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">isNumeral?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Elab/Tactic/NormCast.lean#L44-L53","name":"Lean.Elab.Tactic.NormCast.isCoeOf?","line":44,"kind":"def","docLink":"./Lean/Elab/Tactic/NormCast.html#Lean.Elab.Tactic.NormCast.isCoeOf?","doc":"Checks whether an expression is the coercion of some other expression,\nand if so returns that expression.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/NormCast.html#Lean.Elab.Tactic.NormCast.isCoeOf?\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">isCoeOf?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Elab/Tactic/NormCast.lean#L39-L42","name":"Lean.Elab.Tactic.NormCast.mkCoe","line":39,"kind":"def","docLink":"./Lean/Elab/Tactic/NormCast.html#Lean.Elab.Tactic.NormCast.mkCoe","doc":"Constructs the expression `(e : ty)`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/NormCast.html#Lean.Elab.Tactic.NormCast.mkCoe\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">mkCoe</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e ty : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Elab/Tactic/NormCast.lean#L34-L37","name":"Lean.Elab.Tactic.NormCast.proveEqUsingDown","line":34,"kind":"def","docLink":"./Lean/Elab/Tactic/NormCast.html#Lean.Elab.Tactic.NormCast.proveEqUsingDown","doc":"Proves `a = b` by simplifying using move and squash lemmas. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/NormCast.html#Lean.Elab.Tactic.NormCast.proveEqUsingDown\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">proveEqUsingDown</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(a b : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Elab/Tactic/NormCast.lean#L23-L32","name":"Lean.Elab.Tactic.NormCast.proveEqUsing","line":23,"kind":"def","docLink":"./Lean/Elab/Tactic/NormCast.html#Lean.Elab.Tactic.NormCast.proveEqUsing","doc":"Proves `a = b` using the given simp set. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/NormCast.html#Lean.Elab.Tactic.NormCast.proveEqUsing\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">proveEqUsing</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(s : <a href=\"./Lean/Meta/Tactic/Simp/SimpTheorems.html#Lean.Meta.SimpTheorems\">Lean.Meta.SimpTheorems</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a b : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a>)</span></span></div></div>"}]}