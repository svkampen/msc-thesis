{"name":"Mathlib.Tactic.Simps.Basic","instances":[{"typeNames":["Simps.ProjectionData"],"name":"Simps.instInhabitedProjectionData","className":"Inhabited"},{"typeNames":["Simps.ProjectionData"],"name":"Simps.instToMessageDataProjectionData","className":"Lean.ToMessageData"},{"typeNames":["Simps.ParsedProjectionData"],"name":"Simps.instToMessageDataParsedProjectionData","className":"Lean.ToMessageData"},{"typeNames":["Simps.ProjectionRule"],"name":"Simps.instToMessageDataProjectionRule","className":"Lean.ToMessageData"},{"typeNames":["Simps.Config"],"name":"Simps.instInhabitedConfig","className":"Inhabited"}],"imports":["Init","Lean.Elab.Tactic.Simp","Lean.Elab.App","Mathlib.Tactic.Simps.NotationClass","Mathlib.Lean.Expr.Basic"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L1193-L1198","name":"simpsAttr","line":1193,"kind":"opaque","docLink":"./Mathlib/Tactic/Simps/Basic.html#simpsAttr","doc":"The `simps` attribute. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#simpsAttr\"><span class=\"name\">simpsAttr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Attributes.html#Lean.ParametricAttribute\">Lean.ParametricAttribute</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L1183-L1191","name":"simpsTacFromSyntax","line":1183,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#simpsTacFromSyntax","doc":"elaborate the syntax and run `simpsTac`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#simpsTacFromSyntax\"><span class=\"name\">simpsTacFromSyntax</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(nm : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(stx : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Attributes.html#Lean.AttrM\">Lean.AttrM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L1168-L1181","name":"simpsTac","line":1168,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#simpsTac","doc":"`simpsTac` derives `simp` lemmas for all (nested) non-Prop projections of the declaration.\nIf `todo` is non-empty, it will generate exactly the names in `todo`.\nIf `shortNm` is true, the generated names will only use the last projection name.\nIf `trc` is true, trace as if `trace.simps.verbose` is true. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#simpsTac\"><span class=\"name\">simpsTac</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ref : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(nm : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.Config\">Simps.Config</a> :=\n  <span class=\"fn\">{ <span class=\"fn\">isSimp</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>, <span class=\"fn\">attrs</span> := <span class=\"fn\">[]</span>, <span class=\"fn\">simpRhs</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>, <span class=\"fn\">typeMd</span> := <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode.instances\">Lean.Meta.TransparencyMode.instances</a>,\n    <span class=\"fn\">rhsMd</span> := <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode.reducible\">Lean.Meta.TransparencyMode.reducible</a>, <span class=\"fn\">fullyApplied</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>,\n    <span class=\"fn\">notRecursive</span> := <span class=\"fn\">[<span class=\"fn\">`Prod</span>, <span class=\"fn\">`PProd</span>, <span class=\"fn\">`Opposite</span>, <span class=\"fn\">`PreOpposite</span>]</span>, <span class=\"fn\">debug</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a> }</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(todo : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#String\">String</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span> := <span class=\"fn\">[]</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(trc : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Attributes.html#Lean.AttrM\">Lean.AttrM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L1018-L1163","name":"Simps.addProjections","line":1018,"kind":"opaque","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.addProjections","doc":"Derive lemmas specifying the projections of the declaration.\n`nm`: name of the lemma\nIf `todo` is non-empty, it will generate exactly the names in `todo`.\n`toApply` is non-empty after a custom projection that is a composition of multiple projections\nwas just used. In that case we need to apply these projections before we continue changing `lhs`.\n`simpLemmas`: names of the simp lemmas added so far.(simpLemmas : Array Name)\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.addProjections\"><span class=\"name\">Simps</span>.<span class=\"name\">addProjections</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ref : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(univs : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(nm : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(type lhs rhs : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(args : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(mustBeStr : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.Config\">Simps.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(todo : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#String\">String</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(toApply : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L987-L1016","name":"Simps.headStructureEtaReduce","line":987,"kind":"opaque","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.headStructureEtaReduce","doc":"Perform head-structure-eta-reduction on expression `e`. That is, if `e` is of the form\n`⟨f.1, f.2, ..., f.n⟩` with `f` definitionally equal to `e`, then\n`headStructureEtaReduce e = headStructureEtaReduce f` and `headStructureEtaReduce e = e` otherwise.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.headStructureEtaReduce\"><span class=\"name\">Simps</span>.<span class=\"name\">headStructureEtaReduce</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L940-L985","name":"Simps.addProjection","line":940,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.addProjection","doc":"Add a lemma with `nm` stating that `lhs = rhs`. `type` is the type of both `lhs` and `rhs`,\n`args` is the list of local constants occurring, and `univs` is the list of universe variables. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.addProjection\"><span class=\"name\">Simps</span>.<span class=\"name\">addProjection</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ref : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(univs : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(declName : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(type lhs rhs : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(args : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.Config\">Simps.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L896-L936","name":"Simps.getProjectionExprs","line":896,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.getProjectionExprs","doc":"Get the projections of a structure used by `@[simps]` applied to the appropriate arguments.\nReturns a list of tuples\n```\n(corresponding right-hand-side, given projection name, projection Expression,\n  future projection numbers, used by default, is prefix)\n```\n(where all fields except the first are packed in a `ProjectionData` structure)\none for each projection. The given projection name is the name for the projection used by the user\nused to generate (and parse) projection names. For example, in the structure\n\nExample 1: ``getProjectionExprs env `(α × β) `(⟨x, y⟩)`` will give the output\n```\n  [(`(x), `fst, `(@Prod.fst.{u v} α β), [], true, false),\n   (`(y), `snd, `(@Prod.snd.{u v} α β), [], true, false)]\n```\n\nExample 2: ``getProjectionExprs env `(α ≃ α) `(⟨id, id, fun _ ↦ rfl, fun _ ↦ rfl⟩)``\nwill give the output\n```\n  [(`(id), `apply, (Equiv.toFun), [], true, false),\n   (`(id), `symm_apply, (fun e ↦ e.symm.toFun), [], true, false),\n   ...,\n   ...]\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.getProjectionExprs\"><span class=\"name\">Simps</span>.<span class=\"name\">getProjectionExprs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(stx : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tgt rhs : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.Config\">Simps.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionData\">Simps.ProjectionData</a>)</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L887-L894","name":"Lean.Expr.instantiateLambdasOrApps","line":887,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Expr.instantiateLambdasOrApps","doc":"`instantiateLambdasOrApps es e` instantiates lambdas in `e` by expressions from `es`.\nIf the length of `es` is larger than the number of lambdas in `e`,\nthen the term is applied to the remaining terms.\nAlso reduces head let-expressions in `e`, including those after instantiating all lambdas.\n\nThis is very similar to `expr.substs`, but this also reduces head let-expressions. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Lean.Expr.instantiateLambdasOrApps\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">instantiateLambdasOrApps</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(es : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L882-L885","name":"Simps.Config.lemmasOnly","line":882,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.Config.lemmasOnly","doc":"A common configuration for `@[simps]`: don't tag the generated lemmas with `@[simp]`.\nUse this using `@[simps (config := .lemmasOnly)]`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.Config.lemmasOnly\"><span class=\"name\">Simps</span>.<span class=\"name\">Config</span>.<span class=\"name\">lemmasOnly</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.Config\">Simps.Config</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L877-L880","name":"Simps.Config.asFn","line":877,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.Config.asFn","doc":"A common configuration for `@[simps]`: generate equalities between functions instead equalities\nbetween fully applied Expressions. Use this using `@[simps (config := .asFn)]`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.Config.asFn\"><span class=\"name\">Simps</span>.<span class=\"name\">Config</span>.<span class=\"name\">asFn</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.Config\">Simps.Config</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L874-L875","name":"Simps.elabSimpsConfig","line":874,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.elabSimpsConfig","doc":"Function elaborating `Config` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.elabSimpsConfig\"><span class=\"name\">Simps</span>.<span class=\"name\">elabSimpsConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> → <span class=\"fn\"><a href=\"./Lean/Elab/Command.html#Lean.Elab.Command.CommandElabM\">Lean.Elab.Command.CommandElabM</a> <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.Config\">Simps.Config</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L872-L872","name":"Simps.instInhabitedConfig","line":872,"kind":"instance","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.instInhabitedConfig","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.instInhabitedConfig\"><span class=\"name\">Simps</span>.<span class=\"name\">instInhabitedConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.Config\">Simps.Config</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L871-L871","name":"Simps.Config.debug","line":871,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.Config.debug","doc":"Output debug messages. Not used much, use `set_option simps.debug true` instead. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.Config.debug\"><span class=\"name\">Simps</span>.<span class=\"name\">Config</span>.<span class=\"name\">debug</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.Config\">Simps.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L869-L869","name":"Simps.Config.notRecursive","line":869,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.Config.notRecursive","doc":"List of types in which we are not recursing to generate simplification lemmas.\nE.g. if we write `@[simps] def e : α × β ≃ β × α := ...` we will generate `e_apply` and not\n`e_apply_fst`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.Config.notRecursive\"><span class=\"name\">Simps</span>.<span class=\"name\">Config</span>.<span class=\"name\">notRecursive</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.Config\">Simps.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L865-L865","name":"Simps.Config.fullyApplied","line":865,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.Config.fullyApplied","doc":"Generated lemmas that are fully applied, i.e. generates equalities between applied functions.\nSet this to `false` to generate equalities between functions. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.Config.fullyApplied\"><span class=\"name\">Simps</span>.<span class=\"name\">Config</span>.<span class=\"name\">fullyApplied</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.Config\">Simps.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L862-L862","name":"Simps.Config.rhsMd","line":862,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.Config.rhsMd","doc":"TransparencyMode used to reduce the right-hand side in order to detect whether it is a\nconstructor. Note: was `none` in Lean 3 "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.Config.rhsMd\"><span class=\"name\">Simps</span>.<span class=\"name\">Config</span>.<span class=\"name\">rhsMd</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.Config\">Simps.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode\">Lean.Meta.TransparencyMode</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L859-L859","name":"Simps.Config.typeMd","line":859,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.Config.typeMd","doc":"TransparencyMode used to reduce the type in order to detect whether it is a structure. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.Config.typeMd\"><span class=\"name\">Simps</span>.<span class=\"name\">Config</span>.<span class=\"name\">typeMd</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.Config\">Simps.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode\">Lean.Meta.TransparencyMode</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L857-L857","name":"Simps.Config.simpRhs","line":857,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.Config.simpRhs","doc":"simplify the right-hand side of generated simp-lemmas using `dsimp, simp`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.Config.simpRhs\"><span class=\"name\">Simps</span>.<span class=\"name\">Config</span>.<span class=\"name\">simpRhs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.Config\">Simps.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L855-L855","name":"Simps.Config.attrs","line":855,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.Config.attrs","doc":"Other simp-attributes to apply to generated lemmas.\nAttributes that are currently not simp-attributes are not supported. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.Config.attrs\"><span class=\"name\">Simps</span>.<span class=\"name\">Config</span>.<span class=\"name\">attrs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.Config\">Simps.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L852-L852","name":"Simps.Config.isSimp","line":852,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.Config.isSimp","doc":"Make generated lemmas simp lemmas "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.Config.isSimp\"><span class=\"name\">Simps</span>.<span class=\"name\">Config</span>.<span class=\"name\">isSimp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.Config\">Simps.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L850-L850","name":"Simps.Config.mk","line":850,"kind":"ctor","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.Config.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.Config.mk\"><span class=\"name\">Simps</span>.<span class=\"name\">Config</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(isSimp : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(attrs : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(simpRhs : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(typeMd rhsMd : <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode\">Lean.Meta.TransparencyMode</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fullyApplied : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(notRecursive : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(debug : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.Config\">Simps.Config</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L849-L872","name":"Simps.Config","line":849,"kind":"structure","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.Config","doc":"Configuration options for `@[simps]` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.Config\"><span class=\"name\">Simps</span>.<span class=\"name\">Config</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L839-L847","name":"Simps.elabInitializeSimpsProjections","line":839,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.elabInitializeSimpsProjections","doc":"Function elaborating `initialize_simps_projections`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.elabInitializeSimpsProjections\"><span class=\"name\">Simps</span>.<span class=\"name\">elabInitializeSimpsProjections</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Command.html#Lean.Elab.Command.CommandElab\">Lean.Elab.Command.CommandElab</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L830-L837","name":"Simps.elabSimpsRule","line":830,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.elabSimpsRule","doc":"Parse a rule for `initialize_simps_projections`. It is `<name>→<name>`, `-<name>`, `+<name>`\nor `as_prefix <name>`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.elabSimpsRule\"><span class=\"name\">Simps</span>.<span class=\"name\">elabSimpsRule</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> → <span class=\"fn\"><a href=\"./Lean/Elab/Command.html#Lean.Elab.Command.CommandElabM\">Lean.Elab.Command.CommandElabM</a> <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionRule\">Simps.ProjectionRule</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L739-L809","name":"Simps.getRawProjections","line":739,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.getRawProjections","doc":"Get the projections used by `simps` associated to a given structure `str`.\n\nThe returned information is also stored in the environment extension `Simps.structureExt`, which\nis given to `str`. If `str` already has this attribute, the information is read from this\nextension instead. See the documentation for this extension for the data this tactic returns.\n\nThe returned universe levels are the universe levels of the structure. For the projections there\nare three cases\n* If the declaration `{StructureName}.Simps.{projectionName}` has been declared, then the value\n  of this declaration is used (after checking that it is definitionally equal to the actual\n  projection. If you rename the projection name, the declaration should have the *new* projection\n  name.\n* You can also declare a custom projection that is a composite of multiple projections.\n* Otherwise, for every class with the `notation_class` attribute, and the structure has an\n  instance of that notation class, then the projection of that notation class is used for the\n  projection that is definitionally equal to it (if there is such a projection).\n  This means in practice that coercions to function types and sorts will be used instead of\n  a projection, if this coercion is definitionally equal to a projection. Furthermore, for\n  notation classes like `Mul` and `Zero` those projections are used instead of the\n  corresponding projection.\n  Projections for coercions and notation classes are not automatically generated if they are\n  composites of multiple projections (for example when you use `extend` without the\n  `oldStructureCmd` (does this exist?)).\n* Otherwise, the projection of the structure is chosen.\n  For example: ``getRawProjections env `Prod`` gives the default projections.\n```\n  ([u, v], [(`fst, `(Prod.fst.{u v}), [0], true, false),\n     (`snd, `(@Prod.snd.{u v}), [1], true, false)])\n```\n\nOptionally, this command accepts three optional arguments:\n* If `traceIfExists` the command will always generate a trace message when the structure already\n  has an entry in `structureExt`.\n* The `rules` argument specifies whether projections should be added, renamed, used as prefix, and\n  not used by default.\n* if `trc` is true, this tactic will trace information just as if\n  `set_option trace.simps.verbose true` was set.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.getRawProjections\"><span class=\"name\">Simps</span>.<span class=\"name\">getRawProjections</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(stx : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(str : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(traceIfExists : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(rules : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionRule\">Simps.ProjectionRule</a></span> := <span class=\"fn\">#[]</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(trc : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionData\">Simps.ProjectionData</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L716-L737","name":"Simps.findAutomaticProjections","line":716,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.findAutomaticProjections","doc":"Auxiliary function for `getRawProjections`.\nFind custom projections, automatically found by simps.\nThese come from `DFunLike` and `SetLike` instances. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.findAutomaticProjections\"><span class=\"name\">Simps</span>.<span class=\"name\">findAutomaticProjections</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(str : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(projs : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData\">Simps.ParsedProjectionData</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData\">Simps.ParsedProjectionData</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L671-L714","name":"Simps.findAutomaticProjectionsAux","line":671,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.findAutomaticProjectionsAux","doc":"If a structure has a field that corresponds to a coercion to functions or sets, or corresponds\n  to notation, find the custom projection that uses this coercion or notation.\n  Returns the custom projection and the name of the projection used.\n\nWe catch most errors this function causes, so that we don't fail if an unrelated projection has\nan applicable name. (e.g. `Iso.inv`)\n\nImplementation note: getting rid of TermElabM is tricky, since `Expr.mkAppOptM` doesn't allow to\nkeep metavariables around, which are necessary for `OutParam`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.findAutomaticProjectionsAux\"><span class=\"name\">Simps</span>.<span class=\"name\">findAutomaticProjectionsAux</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(str : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(proj : <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData\">Simps.ParsedProjectionData</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(args : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L655-L669","name":"Simps.checkForUnusedCustomProjs","line":655,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.checkForUnusedCustomProjs","doc":"Checks if there are declarations in the current file in the namespace `{str}.Simps` that are\nnot used. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.checkForUnusedCustomProjs\"><span class=\"name\">Simps</span>.<span class=\"name\">checkForUnusedCustomProjs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(stx : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(str : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(projs : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData\">Simps.ParsedProjectionData</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L616-L653","name":"Simps.findProjection","line":616,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.findProjection","doc":"Auxiliary function for `getRawProjections`.\nGenerates the default projection, and looks for a custom projection declared by the user,\nand replaces the default projection with the custom one, if it can find it. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.findProjection\"><span class=\"name\">Simps</span>.<span class=\"name\">findProjection</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(str : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(proj : <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData\">Simps.ParsedProjectionData</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(rawUnivs : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData\">Simps.ParsedProjectionData</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L570-L614","name":"Simps.applyProjectionRules","line":570,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.applyProjectionRules","doc":"Execute the projection renamings (and turning off projections) as specified by `rules`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.applyProjectionRules\"><span class=\"name\">Simps</span>.<span class=\"name\">applyProjectionRules</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(projs : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData\">Simps.ParsedProjectionData</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(rules : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionRule\">Simps.ProjectionRule</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData\">Simps.ParsedProjectionData</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L552-L568","name":"Simps.mkParsedProjectionData","line":552,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.mkParsedProjectionData","doc":"Get the default `ParsedProjectionData` for structure `str`.\nIt first returns the direct fields of the structure in the right order, and then\nall (non-subobject fields) of all parent structures. The subobject fields are precisely the\nnon-default fields. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.mkParsedProjectionData\"><span class=\"name\">Simps</span>.<span class=\"name\">mkParsedProjectionData</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(structName : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData\">Simps.ParsedProjectionData</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L531-L550","name":"Simps.getCompositeOfProjections","line":531,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.getCompositeOfProjections","doc":"Suppose we are given a structure `str` and a projection `proj`, that could be multiple nested\nprojections (separated by `_`), where each projection could be a projection of a parent structure.\nThis function returns an expression that is the composition of these projections and a\nlist of natural numbers, that are the projection numbers of the applied projections.\nNote that this function is similar to elaborating dot notation, but it can do a little more.\nExample: if we do\n```\nstructure gradedFun (A : ℕ → Type*) where\n  toFun := ∀ i j, A i →+ A j →+ A (i + j)\ninitialize_simps_projections (toFun_toFun_toFun → myMul)\n```\nwe will be able to generate the \"projection\"\n  `fun {A} (f : gradedFun A) (x : A i) (y : A j) ↦ ↑(↑(f.toFun i j) x) y`,\nwhich projection notation cannot do. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.getCompositeOfProjections\"><span class=\"name\">Simps</span>.<span class=\"name\">getCompositeOfProjections</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(structName : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(proj : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L510-L529","name":"Simps.getCompositeOfProjectionsAux","line":510,"kind":"opaque","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.getCompositeOfProjectionsAux","doc":"Auxiliary function of `getCompositeOfProjections`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.getCompositeOfProjectionsAux\"><span class=\"name\">Simps</span>.<span class=\"name\">getCompositeOfProjectionsAux</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(proj : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(pos : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(args : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L468-L480","name":"Simps.findProjectionIndices","line":468,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.findProjectionIndices","doc":"Find the indices of the projections that need to be applied to elaborate `$e.$projName`.\nExample: If `e : α ≃+ β` and ``projName = `invFun`` then this returns `[0, 1]`, because the first\nprojection of `MulEquiv` is `toEquiv` and the second projection of `Equiv` is `invFun`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.findProjectionIndices\"><span class=\"name\">Simps</span>.<span class=\"name\">findProjectionIndices</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(strName projName : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L452-L466","name":"Simps.projectionsInfo","line":452,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.projectionsInfo","doc":"Returns the projection information of a structure. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.projectionsInfo\"><span class=\"name\">Simps</span>.<span class=\"name\">projectionsInfo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(l : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionData\">Simps.ProjectionData</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(pref : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(str : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L441-L450","name":"Simps.instToMessageDataProjectionRule","line":441,"kind":"instance","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.instToMessageDataProjectionRule","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.instToMessageDataProjectionRule\"><span class=\"name\">Simps</span>.<span class=\"name\">instToMessageDataProjectionRule</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Message.html#Lean.ToMessageData\">Lean.ToMessageData</a> <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionRule\">Simps.ProjectionRule</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L438-L439","name":"Simps.ProjectionRule.prefix","line":438,"kind":"ctor","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionRule.prefix","doc":"A prefix rule `prefix fieldName` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionRule.prefix\"><span class=\"name\">Simps</span>.<span class=\"name\">ProjectionRule</span>.<span class=\"name\">prefix</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> → <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionRule\">Simps.ProjectionRule</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L436-L437","name":"Simps.ProjectionRule.erase","line":436,"kind":"ctor","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionRule.erase","doc":"A hiding rule `-fieldName` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionRule.erase\"><span class=\"name\">Simps</span>.<span class=\"name\">ProjectionRule</span>.<span class=\"name\">erase</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> → <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionRule\">Simps.ProjectionRule</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L434-L435","name":"Simps.ProjectionRule.add","line":434,"kind":"ctor","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionRule.add","doc":"An adding rule `+fieldName` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionRule.add\"><span class=\"name\">Simps</span>.<span class=\"name\">ProjectionRule</span>.<span class=\"name\">add</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> → <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionRule\">Simps.ProjectionRule</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L429-L433","name":"Simps.ProjectionRule.rename","line":429,"kind":"ctor","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionRule.rename","doc":"A renaming rule `before→after` or\nEach name comes with the syntax used to write the rule,\nwhich is used to declare hover information. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionRule.rename\"><span class=\"name\">Simps</span>.<span class=\"name\">ProjectionRule</span>.<span class=\"name\">rename</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(oldName : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(oldStx : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(newName : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(newStx : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionRule\">Simps.ProjectionRule</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L426-L439","name":"Simps.ProjectionRule","line":426,"kind":"inductive","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionRule","doc":"The type of rules that specify how metadata for projections in changes.\nSee `initialize_simps_projections`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionRule\"><span class=\"name\">Simps</span>.<span class=\"name\">ProjectionRule</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L420-L424","name":"Simps.instToMessageDataParsedProjectionData","line":420,"kind":"instance","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.instToMessageDataParsedProjectionData","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.instToMessageDataParsedProjectionData\"><span class=\"name\">Simps</span>.<span class=\"name\">instToMessageDataParsedProjectionData</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Message.html#Lean.ToMessageData\">Lean.ToMessageData</a> <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData\">Simps.ParsedProjectionData</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L416-L418","name":"Simps.ParsedProjectionData.toProjectionData","line":416,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData.toProjectionData","doc":"Turn `ParsedProjectionData` into `ProjectionData`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData.toProjectionData\"><span class=\"name\">Simps</span>.<span class=\"name\">ParsedProjectionData</span>.<span class=\"name\">toProjectionData</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData\">Simps.ParsedProjectionData</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionData\">Simps.ProjectionData</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L414-L414","name":"Simps.ParsedProjectionData.isCustom","line":414,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData.isCustom","doc":"is this a projection that is changed by the user? "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData.isCustom\"><span class=\"name\">Simps</span>.<span class=\"name\">ParsedProjectionData</span>.<span class=\"name\">isCustom</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData\">Simps.ParsedProjectionData</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L412-L412","name":"Simps.ParsedProjectionData.projNrs","line":412,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData.projNrs","doc":"the list of projection numbers this expression corresponds to "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData.projNrs\"><span class=\"name\">Simps</span>.<span class=\"name\">ParsedProjectionData</span>.<span class=\"name\">projNrs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData\">Simps.ParsedProjectionData</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L410-L410","name":"Simps.ParsedProjectionData.expr?","line":410,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData.expr?","doc":"projection expression "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData.expr?\"><span class=\"name\">Simps</span>.<span class=\"name\">ParsedProjectionData</span>.<span class=\"name\">expr?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData\">Simps.ParsedProjectionData</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L408-L408","name":"Simps.ParsedProjectionData.isPrefix","line":408,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData.isPrefix","doc":"is the projection name a prefix? "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData.isPrefix\"><span class=\"name\">Simps</span>.<span class=\"name\">ParsedProjectionData</span>.<span class=\"name\">isPrefix</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData\">Simps.ParsedProjectionData</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L406-L406","name":"Simps.ParsedProjectionData.isDefault","line":406,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData.isDefault","doc":"will simp lemmas be generated for with (without specifically naming this?) "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData.isDefault\"><span class=\"name\">Simps</span>.<span class=\"name\">ParsedProjectionData</span>.<span class=\"name\">isDefault</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData\">Simps.ParsedProjectionData</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L404-L404","name":"Simps.ParsedProjectionData.newStx","line":404,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData.newStx","doc":"syntax that provided `newName` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData.newStx\"><span class=\"name\">Simps</span>.<span class=\"name\">ParsedProjectionData</span>.<span class=\"name\">newStx</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData\">Simps.ParsedProjectionData</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L402-L402","name":"Simps.ParsedProjectionData.newName","line":402,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData.newName","doc":"name for this projection used in the generated `simp` lemmas "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData.newName\"><span class=\"name\">Simps</span>.<span class=\"name\">ParsedProjectionData</span>.<span class=\"name\">newName</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData\">Simps.ParsedProjectionData</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L400-L400","name":"Simps.ParsedProjectionData.strStx","line":400,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData.strStx","doc":"syntax that might have provided `strName` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData.strStx\"><span class=\"name\">Simps</span>.<span class=\"name\">ParsedProjectionData</span>.<span class=\"name\">strStx</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData\">Simps.ParsedProjectionData</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L398-L398","name":"Simps.ParsedProjectionData.strName","line":398,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData.strName","doc":"name for this projection used in the structure definition "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData.strName\"><span class=\"name\">Simps</span>.<span class=\"name\">ParsedProjectionData</span>.<span class=\"name\">strName</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData\">Simps.ParsedProjectionData</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L396-L396","name":"Simps.ParsedProjectionData.mk","line":396,"kind":"ctor","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData.mk\"><span class=\"name\">Simps</span>.<span class=\"name\">ParsedProjectionData</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(strName : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(strStx : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(newName : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(newStx : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(isDefault isPrefix : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(expr? : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(projNrs : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(isCustom : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData\">Simps.ParsedProjectionData</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L395-L414","name":"Simps.ParsedProjectionData","line":395,"kind":"structure","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData","doc":"Projection data used internally in `getRawProjections`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ParsedProjectionData\"><span class=\"name\">Simps</span>.<span class=\"name\">ParsedProjectionData</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L383-L393","name":"Simps.structureExt","line":383,"kind":"opaque","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.structureExt","doc":"The `Simps.structureExt` environment extension specifies the preferred projections of the given\nstructure, used by the `@[simps]` attribute.\n- You can generate this with the command `initialize_simps_projections`.\n- If not generated, the `@[simps]` attribute will generate this automatically.\n- To change the default value, see Note [custom simps projection].\n- The first argument is the list of names of the universe variables used in the structure\n- The second argument is an array that consists of the projection data for each projection.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.structureExt\"><span class=\"name\">Simps</span>.<span class=\"name\">structureExt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Batteries/Lean/NameMapAttribute.html#Lean.NameMapExtension\">Lean.NameMapExtension</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionData\">Simps.ProjectionData</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L378-L381","name":"Simps.instToMessageDataProjectionData","line":378,"kind":"instance","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.instToMessageDataProjectionData","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.instToMessageDataProjectionData\"><span class=\"name\">Simps</span>.<span class=\"name\">instToMessageDataProjectionData</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Message.html#Lean.ToMessageData\">Lean.ToMessageData</a> <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionData\">Simps.ProjectionData</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L376-L376","name":"Simps.instInhabitedProjectionData","line":376,"kind":"instance","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.instInhabitedProjectionData","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.instInhabitedProjectionData\"><span class=\"name\">Simps</span>.<span class=\"name\">instInhabitedProjectionData</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionData\">Simps.ProjectionData</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L375-L375","name":"Simps.ProjectionData.isPrefix","line":375,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionData.isPrefix","doc":"A boolean specifying whether this projection is written as prefix. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionData.isPrefix\"><span class=\"name\">Simps</span>.<span class=\"name\">ProjectionData</span>.<span class=\"name\">isPrefix</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionData\">Simps.ProjectionData</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L373-L373","name":"Simps.ProjectionData.isDefault","line":373,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionData.isDefault","doc":"A boolean specifying whether `simp` lemmas are generated for this projection by default. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionData.isDefault\"><span class=\"name\">Simps</span>.<span class=\"name\">ProjectionData</span>.<span class=\"name\">isDefault</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionData\">Simps.ProjectionData</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L371-L371","name":"Simps.ProjectionData.projNrs","line":371,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionData.projNrs","doc":"A list of natural numbers, which is the projection number(s) that have to be applied to the\nExpression. For example the list `[0, 1]` corresponds to applying the first projection of the\nstructure, and then the second projection of the resulting structure (this assumes that the\ntarget of the first projection is a structure with at least two projections).\nThe composition of these projections is required to be definitionally equal to the provided\nExpression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionData.projNrs\"><span class=\"name\">Simps</span>.<span class=\"name\">ProjectionData</span>.<span class=\"name\">projNrs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionData\">Simps.ProjectionData</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L364-L364","name":"Simps.ProjectionData.expr","line":364,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionData.expr","doc":"An Expression used by simps for the projection. It must be definitionally equal to an original\nprojection (or a composition of multiple projections).\nThese Expressions can contain the universe parameters specified in the first argument of\n`structureExt`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionData.expr\"><span class=\"name\">Simps</span>.<span class=\"name\">ProjectionData</span>.<span class=\"name\">expr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionData\">Simps.ProjectionData</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L359-L359","name":"Simps.ProjectionData.name","line":359,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionData.name","doc":"The name used in the generated `simp` lemmas "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionData.name\"><span class=\"name\">Simps</span>.<span class=\"name\">ProjectionData</span>.<span class=\"name\">name</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionData\">Simps.ProjectionData</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L357-L357","name":"Simps.ProjectionData.mk","line":357,"kind":"ctor","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionData.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionData.mk\"><span class=\"name\">Simps</span>.<span class=\"name\">ProjectionData</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(name : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(expr : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(projNrs : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(isDefault isPrefix : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionData\">Simps.ProjectionData</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L356-L376","name":"Simps.ProjectionData","line":356,"kind":"structure","docLink":"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionData","doc":"Projection data for a single projection of a structure "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Simps.ProjectionData\"><span class=\"name\">Simps</span>.<span class=\"name\">ProjectionData</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L345-L346","name":"Lean.Parser.Command.commandInitialize_simps_projections?_","line":345,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Command.commandInitialize_simps_projections?_","doc":"This command allows customisation of the lemmas generated by `simps`.\n\nBy default, tagging a definition of an element `myObj` of a structure `MyStruct` with `@[simps]`\ngenerates one `@[simp]` lemma `myObj_myProj` for each projection `myProj` of `MyStruct`. There are a\nfew exceptions to this general rule:\n* For algebraic structures, we will automatically use the notation (like `Mul`)\n  for the projections if such an instance is available.\n* By default, the projections to parent structures are not default projections,\n  but all the data-carrying fields are (including those in parent structures).\n\nThis default behavior is customisable as such:\n* You can disable a projection by default by running\n  `initialize_simps_projections MulEquiv (-invFun)`\n  This will ensure that no simp lemmas are generated for this projection,\n  unless this projection is explicitly specified by the user (as in\n  `@[simps invFun] def myEquiv : MulEquiv _ _ := _`).\n* Conversely, you can enable a projection by default by running\n  `initialize_simps_projections MulEquiv (+toEquiv)`.\n* You can specify custom names by writing e.g.\n  `initialize_simps_projections MulEquiv (toFun → apply, invFun → symm_apply)`.\n* If you want the projection name added as a prefix in the generated lemma name, you can use\n  `as_prefix fieldName`:\n  `initialize_simps_projections MulEquiv (toFun → coe, as_prefix coe)`\n  Note that this does not influence the parsing of projection names: if you have a declaration\n  `foo` and you want to apply the projections `snd`, `coe` (which is a prefix) and `fst`, in that\n  order you can run `@[simps snd_coe_fst] def foo ...` and this will generate a lemma with the\n  name `coe_foo_snd_fst`.\n\nHere are a few extra pieces of information:\n  * Run `initialize_simps_projections?` (or `set_option trace.simps.verbose true`)\n  to see the generated projections.\n* Running `initialize_simps_projections MyStruct` without arguments is not necessary, it has the\n  same effect if you just add `@[simps]` to a declaration.\n* It is recommended to call `@[simps]` or `initialize_simps_projections` in the same file as the\n  structure declaration. Otherwise, the projections could be generated multiple times in different\n  files.\n\nSome common uses:\n* If you define a new homomorphism-like structure (like `MulHom`) you can just run\n  `initialize_simps_projections` after defining the `DFunLike` instance (or instance that implies\n  a `DFunLike` instance).\n  ```\n    instance {mM : Mul M} {mN : Mul N} : FunLike (MulHom M N) M N := ...\n    initialize_simps_projections MulHom (toFun → apply)\n  ```\n  This will generate `foo_apply` lemmas for each declaration `foo`.\n* If you prefer `coe_foo` lemmas that state equalities between functions, use\n  `initialize_simps_projections MulHom (toFun → coe, as_prefix coe)`\n  In this case you have to use `@[simps (config := .asFn)]` whenever you call `@[simps]`.\n* You can also initialize to use both, in which case you have to choose which one to use by default,\n  by using either of the following\n  ```\n    initialize_simps_projections MulHom (toFun → apply, toFun → coe, as_prefix coe, -coe)\n    initialize_simps_projections MulHom (toFun → apply, toFun → coe, as_prefix coe, -apply)\n  ```\n  In the first case, you can get both lemmas using `@[simps, simps (config := .asFn) coe]` and in\n  the second case you can get both lemmas using `@[simps (config := .asFn), simps apply]`.\n* If you declare a new homomorphism-like structure (like `RelEmbedding`),\n  then `initialize_simps_projections` will automatically find any `DFunLike` coercions\n  that will be used as the default projection for the `toFun` field.\n  ```\n    initialize_simps_projections relEmbedding (toFun → apply)\n  ```\n* If you have an isomorphism-like structure (like `Equiv`) you often want to define a custom\n  projection for the inverse:\n  ```\n    def Equiv.Simps.symm_apply (e : α ≃ β) : β → α := e.symm\n    initialize_simps_projections Equiv (toFun → apply, invFun → symm_apply)\n  ```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Command.commandInitialize_simps_projections?_\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">commandInitialize_simps_projections?_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L270-L342","name":"Lean.Parser.Command.initialize_simps_projections","line":270,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Command.initialize_simps_projections","doc":"This command allows customisation of the lemmas generated by `simps`.\n\nBy default, tagging a definition of an element `myObj` of a structure `MyStruct` with `@[simps]`\ngenerates one `@[simp]` lemma `myObj_myProj` for each projection `myProj` of `MyStruct`. There are a\nfew exceptions to this general rule:\n* For algebraic structures, we will automatically use the notation (like `Mul`)\n  for the projections if such an instance is available.\n* By default, the projections to parent structures are not default projections,\n  but all the data-carrying fields are (including those in parent structures).\n\nThis default behavior is customisable as such:\n* You can disable a projection by default by running\n  `initialize_simps_projections MulEquiv (-invFun)`\n  This will ensure that no simp lemmas are generated for this projection,\n  unless this projection is explicitly specified by the user (as in\n  `@[simps invFun] def myEquiv : MulEquiv _ _ := _`).\n* Conversely, you can enable a projection by default by running\n  `initialize_simps_projections MulEquiv (+toEquiv)`.\n* You can specify custom names by writing e.g.\n  `initialize_simps_projections MulEquiv (toFun → apply, invFun → symm_apply)`.\n* If you want the projection name added as a prefix in the generated lemma name, you can use\n  `as_prefix fieldName`:\n  `initialize_simps_projections MulEquiv (toFun → coe, as_prefix coe)`\n  Note that this does not influence the parsing of projection names: if you have a declaration\n  `foo` and you want to apply the projections `snd`, `coe` (which is a prefix) and `fst`, in that\n  order you can run `@[simps snd_coe_fst] def foo ...` and this will generate a lemma with the\n  name `coe_foo_snd_fst`.\n\nHere are a few extra pieces of information:\n  * Run `initialize_simps_projections?` (or `set_option trace.simps.verbose true`)\n  to see the generated projections.\n* Running `initialize_simps_projections MyStruct` without arguments is not necessary, it has the\n  same effect if you just add `@[simps]` to a declaration.\n* It is recommended to call `@[simps]` or `initialize_simps_projections` in the same file as the\n  structure declaration. Otherwise, the projections could be generated multiple times in different\n  files.\n\nSome common uses:\n* If you define a new homomorphism-like structure (like `MulHom`) you can just run\n  `initialize_simps_projections` after defining the `DFunLike` instance (or instance that implies\n  a `DFunLike` instance).\n  ```\n    instance {mM : Mul M} {mN : Mul N} : FunLike (MulHom M N) M N := ...\n    initialize_simps_projections MulHom (toFun → apply)\n  ```\n  This will generate `foo_apply` lemmas for each declaration `foo`.\n* If you prefer `coe_foo` lemmas that state equalities between functions, use\n  `initialize_simps_projections MulHom (toFun → coe, as_prefix coe)`\n  In this case you have to use `@[simps (config := .asFn)]` whenever you call `@[simps]`.\n* You can also initialize to use both, in which case you have to choose which one to use by default,\n  by using either of the following\n  ```\n    initialize_simps_projections MulHom (toFun → apply, toFun → coe, as_prefix coe, -coe)\n    initialize_simps_projections MulHom (toFun → apply, toFun → coe, as_prefix coe, -apply)\n  ```\n  In the first case, you can get both lemmas using `@[simps, simps (config := .asFn) coe]` and in\n  the second case you can get both lemmas using `@[simps (config := .asFn), simps apply]`.\n* If you declare a new homomorphism-like structure (like `RelEmbedding`),\n  then `initialize_simps_projections` will automatically find any `DFunLike` coercions\n  that will be used as the default projection for the `toFun` field.\n  ```\n    initialize_simps_projections relEmbedding (toFun → apply)\n  ```\n* If you have an isomorphism-like structure (like `Equiv`) you often want to define a custom\n  projection for the inverse:\n  ```\n    def Equiv.Simps.symm_apply (e : α ≃ β) : β → α := e.symm\n    initialize_simps_projections Equiv (toFun → apply, invFun → symm_apply)\n  ```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Command.initialize_simps_projections\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">initialize_simps_projections</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L267-L268","name":"Lean.Parser.Command.simpsProj","line":267,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Command.simpsProj","doc":"Syntax for `initialize_simps_projections`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Command.simpsProj\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">simpsProj</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L265-L266","name":"Lean.Parser.Command.simpsRule","line":265,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Command.simpsRule","doc":"Syntax for a single rule in `initialize_simps_projections`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Command.simpsRule\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">simpsRule</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L263-L264","name":"Lean.Parser.Command.simpsRule.prefix","line":263,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Command.simpsRule.prefix","doc":"Syntax for making a projection prefix. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Command.simpsRule.prefix\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">simpsRule</span>.<span class=\"name\">prefix</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L261-L262","name":"Lean.Parser.Command.simpsRule.add","line":261,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Command.simpsRule.add","doc":"Syntax for making a projection default in `initialize_simps_projections`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Command.simpsRule.add\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">simpsRule</span>.<span class=\"name\">add</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L259-L260","name":"Lean.Parser.Command.simpsRule.erase","line":259,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Command.simpsRule.erase","doc":"Syntax for making a projection non-default in `initialize_simps_projections`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Command.simpsRule.erase\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">simpsRule</span>.<span class=\"name\">erase</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L257-L258","name":"Lean.Parser.Command.simpsRule.rename","line":257,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Command.simpsRule.rename","doc":"Syntax for renaming a projection in `initialize_simps_projections`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Command.simpsRule.rename\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">simpsRule</span>.<span class=\"name\">rename</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L250-L253","name":"Lean.Parser.linter.simpsUnusedCustomDeclarations","line":250,"kind":"opaque","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.linter.simpsUnusedCustomDeclarations","doc":"Linter to check that no unused custom declarations are declared for simps. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.linter.simpsUnusedCustomDeclarations\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">linter</span>.<span class=\"name\">simpsUnusedCustomDeclarations</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/Options.html#Lean.Option\">Lean.Option</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L245-L248","name":"Lean.Parser.linter.simpsNoConstructor","line":245,"kind":"opaque","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.linter.simpsNoConstructor","doc":"Linter to check that `simps!` is used when needed "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.linter.simpsNoConstructor\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">linter</span>.<span class=\"name\">simpsNoConstructor</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/Options.html#Lean.Option\">Lean.Option</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L241-L241","name":"Lean.Parser.Attr.attrSimps?!_","line":241,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Attr.attrSimps?!_","doc":"The `@[simps]` attribute automatically derives lemmas specifying the projections of this\ndeclaration.\n\nExample:\n```lean\n@[simps] def foo : ℕ × ℤ := (1, 2)\n```\nderives two `simp` lemmas:\n```lean\n@[simp] lemma foo_fst : foo.fst = 1\n@[simp] lemma foo_snd : foo.snd = 2\n```\n\n* It does not derive `simp` lemmas for the prop-valued projections.\n* It will automatically reduce newly created beta-redexes, but will not unfold any definitions.\n* If the structure has a coercion to either sorts or functions, and this is defined to be one\n  of the projections, then this coercion will be used instead of the projection.\n* If the structure is a class that has an instance to a notation class, like `Neg` or `Mul`,\n  then this notation is used instead of the corresponding projection.\n* You can specify custom projections, by giving a declaration with name\n  `{StructureName}.Simps.{projectionName}`. See Note [custom simps projection].\n\n  Example:\n  ```lean\n  def Equiv.Simps.invFun (e : α ≃ β) : β → α := e.symm\n  @[simps] def Equiv.trans (e₁ : α ≃ β) (e₂ : β ≃ γ) : α ≃ γ :=\n  ⟨e₂ ∘ e₁, e₁.symm ∘ e₂.symm⟩\n  ```\n  generates\n  ```\n  @[simp] lemma Equiv.trans_toFun : ∀ {α β γ} (e₁ e₂) (a : α), ⇑(e₁.trans e₂) a = (⇑e₂ ∘ ⇑e₁) a\n  @[simp] lemma Equiv.trans_invFun : ∀ {α β γ} (e₁ e₂) (a : γ),\n    ⇑((e₁.trans e₂).symm) a = (⇑(e₁.symm) ∘ ⇑(e₂.symm)) a\n  ```\n\n* You can specify custom projection names, by specifying the new projection names using\n  `initialize_simps_projections`.\n  Example: `initialize_simps_projections Equiv (toFun → apply, invFun → symm_apply)`.\n  See `initialize_simps_projections` for more information.\n\n* If one of the fields itself is a structure, this command will recursively create\n  `simp` lemmas for all fields in that structure.\n  * Exception: by default it will not recursively create `simp` lemmas for fields in the structures\n    `Prod`, `PProd`, and `Opposite`. You can give explicit projection names or change the value of\n    `Simps.Config.notRecursive` to override this behavior.\n\n  Example:\n  ```lean\n  structure MyProd (α β : Type*) := (fst : α) (snd : β)\n  @[simps] def foo : Prod ℕ ℕ × MyProd ℕ ℕ := ⟨⟨1, 2⟩, 3, 4⟩\n  ```\n  generates\n  ```lean\n  @[simp] lemma foo_fst : foo.fst = (1, 2)\n  @[simp] lemma foo_snd_fst : foo.snd.fst = 3\n  @[simp] lemma foo_snd_snd : foo.snd.snd = 4\n  ```\n\n* You can use `@[simps proj1 proj2 ...]` to only generate the projection lemmas for the specified\n  projections.\n* Recursive projection names can be specified using `proj1_proj2_proj3`.\n  This will create a lemma of the form `foo.proj1.proj2.proj3 = ...`.\n\n  Example:\n  ```lean\n  structure MyProd (α β : Type*) := (fst : α) (snd : β)\n  @[simps fst fst_fst snd] def foo : Prod ℕ ℕ × MyProd ℕ ℕ := ⟨⟨1, 2⟩, 3, 4⟩\n  ```\n  generates\n  ```lean\n  @[simp] lemma foo_fst : foo.fst = (1, 2)\n  @[simp] lemma foo_fst_fst : foo.fst.fst = 1\n  @[simp] lemma foo_snd : foo.snd = {fst := 3, snd := 4}\n  ```\n* If one of the values is an eta-expanded structure, we will eta-reduce this structure.\n\n  Example:\n  ```lean\n  structure EquivPlusData (α β) extends α ≃ β where\n    data : Bool\n  @[simps] def EquivPlusData.rfl {α} : EquivPlusData α α := { Equiv.refl α with data := true }\n  ```\n  generates the following:\n  ```lean\n  @[simp] lemma bar_toEquiv : ∀ {α : Sort*}, bar.toEquiv = Equiv.refl α\n  @[simp] lemma bar_data : ∀ {α : Sort*}, bar.data = true\n  ```\n  This is true, even though Lean inserts an eta-expanded version of `Equiv.refl α` in the\n  definition of `bar`.\n* For configuration options, see the doc string of `Simps.Config`.\n* The precise syntax is `simps (config := e)? ident*`, where `e : Expr` is an expression of type\n  `Simps.Config` and `ident*` is a list of desired projection names.\n* `@[simps]` reduces let-expressions where necessary.\n* When option `trace.simps.verbose` is true, `simps` will print the projections it finds and the\n  lemmas it generates. The same can be achieved by using `@[simps?]`.\n* Use `@[to_additive (attr := simps)]` to apply both `to_additive` and `simps` to a definition\n  This will also generate the additive versions of all `simp` lemmas.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Attr.attrSimps?!_\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">attrSimps?!_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L240-L240","name":"Lean.Parser.Attr.attrSimps!?_","line":240,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Attr.attrSimps!?_","doc":"The `@[simps]` attribute automatically derives lemmas specifying the projections of this\ndeclaration.\n\nExample:\n```lean\n@[simps] def foo : ℕ × ℤ := (1, 2)\n```\nderives two `simp` lemmas:\n```lean\n@[simp] lemma foo_fst : foo.fst = 1\n@[simp] lemma foo_snd : foo.snd = 2\n```\n\n* It does not derive `simp` lemmas for the prop-valued projections.\n* It will automatically reduce newly created beta-redexes, but will not unfold any definitions.\n* If the structure has a coercion to either sorts or functions, and this is defined to be one\n  of the projections, then this coercion will be used instead of the projection.\n* If the structure is a class that has an instance to a notation class, like `Neg` or `Mul`,\n  then this notation is used instead of the corresponding projection.\n* You can specify custom projections, by giving a declaration with name\n  `{StructureName}.Simps.{projectionName}`. See Note [custom simps projection].\n\n  Example:\n  ```lean\n  def Equiv.Simps.invFun (e : α ≃ β) : β → α := e.symm\n  @[simps] def Equiv.trans (e₁ : α ≃ β) (e₂ : β ≃ γ) : α ≃ γ :=\n  ⟨e₂ ∘ e₁, e₁.symm ∘ e₂.symm⟩\n  ```\n  generates\n  ```\n  @[simp] lemma Equiv.trans_toFun : ∀ {α β γ} (e₁ e₂) (a : α), ⇑(e₁.trans e₂) a = (⇑e₂ ∘ ⇑e₁) a\n  @[simp] lemma Equiv.trans_invFun : ∀ {α β γ} (e₁ e₂) (a : γ),\n    ⇑((e₁.trans e₂).symm) a = (⇑(e₁.symm) ∘ ⇑(e₂.symm)) a\n  ```\n\n* You can specify custom projection names, by specifying the new projection names using\n  `initialize_simps_projections`.\n  Example: `initialize_simps_projections Equiv (toFun → apply, invFun → symm_apply)`.\n  See `initialize_simps_projections` for more information.\n\n* If one of the fields itself is a structure, this command will recursively create\n  `simp` lemmas for all fields in that structure.\n  * Exception: by default it will not recursively create `simp` lemmas for fields in the structures\n    `Prod`, `PProd`, and `Opposite`. You can give explicit projection names or change the value of\n    `Simps.Config.notRecursive` to override this behavior.\n\n  Example:\n  ```lean\n  structure MyProd (α β : Type*) := (fst : α) (snd : β)\n  @[simps] def foo : Prod ℕ ℕ × MyProd ℕ ℕ := ⟨⟨1, 2⟩, 3, 4⟩\n  ```\n  generates\n  ```lean\n  @[simp] lemma foo_fst : foo.fst = (1, 2)\n  @[simp] lemma foo_snd_fst : foo.snd.fst = 3\n  @[simp] lemma foo_snd_snd : foo.snd.snd = 4\n  ```\n\n* You can use `@[simps proj1 proj2 ...]` to only generate the projection lemmas for the specified\n  projections.\n* Recursive projection names can be specified using `proj1_proj2_proj3`.\n  This will create a lemma of the form `foo.proj1.proj2.proj3 = ...`.\n\n  Example:\n  ```lean\n  structure MyProd (α β : Type*) := (fst : α) (snd : β)\n  @[simps fst fst_fst snd] def foo : Prod ℕ ℕ × MyProd ℕ ℕ := ⟨⟨1, 2⟩, 3, 4⟩\n  ```\n  generates\n  ```lean\n  @[simp] lemma foo_fst : foo.fst = (1, 2)\n  @[simp] lemma foo_fst_fst : foo.fst.fst = 1\n  @[simp] lemma foo_snd : foo.snd = {fst := 3, snd := 4}\n  ```\n* If one of the values is an eta-expanded structure, we will eta-reduce this structure.\n\n  Example:\n  ```lean\n  structure EquivPlusData (α β) extends α ≃ β where\n    data : Bool\n  @[simps] def EquivPlusData.rfl {α} : EquivPlusData α α := { Equiv.refl α with data := true }\n  ```\n  generates the following:\n  ```lean\n  @[simp] lemma bar_toEquiv : ∀ {α : Sort*}, bar.toEquiv = Equiv.refl α\n  @[simp] lemma bar_data : ∀ {α : Sort*}, bar.data = true\n  ```\n  This is true, even though Lean inserts an eta-expanded version of `Equiv.refl α` in the\n  definition of `bar`.\n* For configuration options, see the doc string of `Simps.Config`.\n* The precise syntax is `simps (config := e)? ident*`, where `e : Expr` is an expression of type\n  `Simps.Config` and `ident*` is a list of desired projection names.\n* `@[simps]` reduces let-expressions where necessary.\n* When option `trace.simps.verbose` is true, `simps` will print the projections it finds and the\n  lemmas it generates. The same can be achieved by using `@[simps?]`.\n* Use `@[to_additive (attr := simps)]` to apply both `to_additive` and `simps` to a definition\n  This will also generate the additive versions of all `simp` lemmas.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Attr.attrSimps!?_\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">attrSimps!?_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L239-L239","name":"Lean.Parser.Attr.attrSimps!_","line":239,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Attr.attrSimps!_","doc":"The `@[simps]` attribute automatically derives lemmas specifying the projections of this\ndeclaration.\n\nExample:\n```lean\n@[simps] def foo : ℕ × ℤ := (1, 2)\n```\nderives two `simp` lemmas:\n```lean\n@[simp] lemma foo_fst : foo.fst = 1\n@[simp] lemma foo_snd : foo.snd = 2\n```\n\n* It does not derive `simp` lemmas for the prop-valued projections.\n* It will automatically reduce newly created beta-redexes, but will not unfold any definitions.\n* If the structure has a coercion to either sorts or functions, and this is defined to be one\n  of the projections, then this coercion will be used instead of the projection.\n* If the structure is a class that has an instance to a notation class, like `Neg` or `Mul`,\n  then this notation is used instead of the corresponding projection.\n* You can specify custom projections, by giving a declaration with name\n  `{StructureName}.Simps.{projectionName}`. See Note [custom simps projection].\n\n  Example:\n  ```lean\n  def Equiv.Simps.invFun (e : α ≃ β) : β → α := e.symm\n  @[simps] def Equiv.trans (e₁ : α ≃ β) (e₂ : β ≃ γ) : α ≃ γ :=\n  ⟨e₂ ∘ e₁, e₁.symm ∘ e₂.symm⟩\n  ```\n  generates\n  ```\n  @[simp] lemma Equiv.trans_toFun : ∀ {α β γ} (e₁ e₂) (a : α), ⇑(e₁.trans e₂) a = (⇑e₂ ∘ ⇑e₁) a\n  @[simp] lemma Equiv.trans_invFun : ∀ {α β γ} (e₁ e₂) (a : γ),\n    ⇑((e₁.trans e₂).symm) a = (⇑(e₁.symm) ∘ ⇑(e₂.symm)) a\n  ```\n\n* You can specify custom projection names, by specifying the new projection names using\n  `initialize_simps_projections`.\n  Example: `initialize_simps_projections Equiv (toFun → apply, invFun → symm_apply)`.\n  See `initialize_simps_projections` for more information.\n\n* If one of the fields itself is a structure, this command will recursively create\n  `simp` lemmas for all fields in that structure.\n  * Exception: by default it will not recursively create `simp` lemmas for fields in the structures\n    `Prod`, `PProd`, and `Opposite`. You can give explicit projection names or change the value of\n    `Simps.Config.notRecursive` to override this behavior.\n\n  Example:\n  ```lean\n  structure MyProd (α β : Type*) := (fst : α) (snd : β)\n  @[simps] def foo : Prod ℕ ℕ × MyProd ℕ ℕ := ⟨⟨1, 2⟩, 3, 4⟩\n  ```\n  generates\n  ```lean\n  @[simp] lemma foo_fst : foo.fst = (1, 2)\n  @[simp] lemma foo_snd_fst : foo.snd.fst = 3\n  @[simp] lemma foo_snd_snd : foo.snd.snd = 4\n  ```\n\n* You can use `@[simps proj1 proj2 ...]` to only generate the projection lemmas for the specified\n  projections.\n* Recursive projection names can be specified using `proj1_proj2_proj3`.\n  This will create a lemma of the form `foo.proj1.proj2.proj3 = ...`.\n\n  Example:\n  ```lean\n  structure MyProd (α β : Type*) := (fst : α) (snd : β)\n  @[simps fst fst_fst snd] def foo : Prod ℕ ℕ × MyProd ℕ ℕ := ⟨⟨1, 2⟩, 3, 4⟩\n  ```\n  generates\n  ```lean\n  @[simp] lemma foo_fst : foo.fst = (1, 2)\n  @[simp] lemma foo_fst_fst : foo.fst.fst = 1\n  @[simp] lemma foo_snd : foo.snd = {fst := 3, snd := 4}\n  ```\n* If one of the values is an eta-expanded structure, we will eta-reduce this structure.\n\n  Example:\n  ```lean\n  structure EquivPlusData (α β) extends α ≃ β where\n    data : Bool\n  @[simps] def EquivPlusData.rfl {α} : EquivPlusData α α := { Equiv.refl α with data := true }\n  ```\n  generates the following:\n  ```lean\n  @[simp] lemma bar_toEquiv : ∀ {α : Sort*}, bar.toEquiv = Equiv.refl α\n  @[simp] lemma bar_data : ∀ {α : Sort*}, bar.data = true\n  ```\n  This is true, even though Lean inserts an eta-expanded version of `Equiv.refl α` in the\n  definition of `bar`.\n* For configuration options, see the doc string of `Simps.Config`.\n* The precise syntax is `simps (config := e)? ident*`, where `e : Expr` is an expression of type\n  `Simps.Config` and `ident*` is a list of desired projection names.\n* `@[simps]` reduces let-expressions where necessary.\n* When option `trace.simps.verbose` is true, `simps` will print the projections it finds and the\n  lemmas it generates. The same can be achieved by using `@[simps?]`.\n* Use `@[to_additive (attr := simps)]` to apply both `to_additive` and `simps` to a definition\n  This will also generate the additive versions of all `simp` lemmas.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Attr.attrSimps!_\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">attrSimps!_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L238-L238","name":"Lean.Parser.Attr.attrSimps?_","line":238,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Attr.attrSimps?_","doc":"The `@[simps]` attribute automatically derives lemmas specifying the projections of this\ndeclaration.\n\nExample:\n```lean\n@[simps] def foo : ℕ × ℤ := (1, 2)\n```\nderives two `simp` lemmas:\n```lean\n@[simp] lemma foo_fst : foo.fst = 1\n@[simp] lemma foo_snd : foo.snd = 2\n```\n\n* It does not derive `simp` lemmas for the prop-valued projections.\n* It will automatically reduce newly created beta-redexes, but will not unfold any definitions.\n* If the structure has a coercion to either sorts or functions, and this is defined to be one\n  of the projections, then this coercion will be used instead of the projection.\n* If the structure is a class that has an instance to a notation class, like `Neg` or `Mul`,\n  then this notation is used instead of the corresponding projection.\n* You can specify custom projections, by giving a declaration with name\n  `{StructureName}.Simps.{projectionName}`. See Note [custom simps projection].\n\n  Example:\n  ```lean\n  def Equiv.Simps.invFun (e : α ≃ β) : β → α := e.symm\n  @[simps] def Equiv.trans (e₁ : α ≃ β) (e₂ : β ≃ γ) : α ≃ γ :=\n  ⟨e₂ ∘ e₁, e₁.symm ∘ e₂.symm⟩\n  ```\n  generates\n  ```\n  @[simp] lemma Equiv.trans_toFun : ∀ {α β γ} (e₁ e₂) (a : α), ⇑(e₁.trans e₂) a = (⇑e₂ ∘ ⇑e₁) a\n  @[simp] lemma Equiv.trans_invFun : ∀ {α β γ} (e₁ e₂) (a : γ),\n    ⇑((e₁.trans e₂).symm) a = (⇑(e₁.symm) ∘ ⇑(e₂.symm)) a\n  ```\n\n* You can specify custom projection names, by specifying the new projection names using\n  `initialize_simps_projections`.\n  Example: `initialize_simps_projections Equiv (toFun → apply, invFun → symm_apply)`.\n  See `initialize_simps_projections` for more information.\n\n* If one of the fields itself is a structure, this command will recursively create\n  `simp` lemmas for all fields in that structure.\n  * Exception: by default it will not recursively create `simp` lemmas for fields in the structures\n    `Prod`, `PProd`, and `Opposite`. You can give explicit projection names or change the value of\n    `Simps.Config.notRecursive` to override this behavior.\n\n  Example:\n  ```lean\n  structure MyProd (α β : Type*) := (fst : α) (snd : β)\n  @[simps] def foo : Prod ℕ ℕ × MyProd ℕ ℕ := ⟨⟨1, 2⟩, 3, 4⟩\n  ```\n  generates\n  ```lean\n  @[simp] lemma foo_fst : foo.fst = (1, 2)\n  @[simp] lemma foo_snd_fst : foo.snd.fst = 3\n  @[simp] lemma foo_snd_snd : foo.snd.snd = 4\n  ```\n\n* You can use `@[simps proj1 proj2 ...]` to only generate the projection lemmas for the specified\n  projections.\n* Recursive projection names can be specified using `proj1_proj2_proj3`.\n  This will create a lemma of the form `foo.proj1.proj2.proj3 = ...`.\n\n  Example:\n  ```lean\n  structure MyProd (α β : Type*) := (fst : α) (snd : β)\n  @[simps fst fst_fst snd] def foo : Prod ℕ ℕ × MyProd ℕ ℕ := ⟨⟨1, 2⟩, 3, 4⟩\n  ```\n  generates\n  ```lean\n  @[simp] lemma foo_fst : foo.fst = (1, 2)\n  @[simp] lemma foo_fst_fst : foo.fst.fst = 1\n  @[simp] lemma foo_snd : foo.snd = {fst := 3, snd := 4}\n  ```\n* If one of the values is an eta-expanded structure, we will eta-reduce this structure.\n\n  Example:\n  ```lean\n  structure EquivPlusData (α β) extends α ≃ β where\n    data : Bool\n  @[simps] def EquivPlusData.rfl {α} : EquivPlusData α α := { Equiv.refl α with data := true }\n  ```\n  generates the following:\n  ```lean\n  @[simp] lemma bar_toEquiv : ∀ {α : Sort*}, bar.toEquiv = Equiv.refl α\n  @[simp] lemma bar_data : ∀ {α : Sort*}, bar.data = true\n  ```\n  This is true, even though Lean inserts an eta-expanded version of `Equiv.refl α` in the\n  definition of `bar`.\n* For configuration options, see the doc string of `Simps.Config`.\n* The precise syntax is `simps (config := e)? ident*`, where `e : Expr` is an expression of type\n  `Simps.Config` and `ident*` is a list of desired projection names.\n* `@[simps]` reduces let-expressions where necessary.\n* When option `trace.simps.verbose` is true, `simps` will print the projections it finds and the\n  lemmas it generates. The same can be achieved by using `@[simps?]`.\n* Use `@[to_additive (attr := simps)]` to apply both `to_additive` and `simps` to a definition\n  This will also generate the additive versions of all `simp` lemmas.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Attr.attrSimps?_\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">attrSimps?_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L136-L236","name":"Lean.Parser.Attr.simps","line":136,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Attr.simps","doc":"The `@[simps]` attribute automatically derives lemmas specifying the projections of this\ndeclaration.\n\nExample:\n```lean\n@[simps] def foo : ℕ × ℤ := (1, 2)\n```\nderives two `simp` lemmas:\n```lean\n@[simp] lemma foo_fst : foo.fst = 1\n@[simp] lemma foo_snd : foo.snd = 2\n```\n\n* It does not derive `simp` lemmas for the prop-valued projections.\n* It will automatically reduce newly created beta-redexes, but will not unfold any definitions.\n* If the structure has a coercion to either sorts or functions, and this is defined to be one\n  of the projections, then this coercion will be used instead of the projection.\n* If the structure is a class that has an instance to a notation class, like `Neg` or `Mul`,\n  then this notation is used instead of the corresponding projection.\n* You can specify custom projections, by giving a declaration with name\n  `{StructureName}.Simps.{projectionName}`. See Note [custom simps projection].\n\n  Example:\n  ```lean\n  def Equiv.Simps.invFun (e : α ≃ β) : β → α := e.symm\n  @[simps] def Equiv.trans (e₁ : α ≃ β) (e₂ : β ≃ γ) : α ≃ γ :=\n  ⟨e₂ ∘ e₁, e₁.symm ∘ e₂.symm⟩\n  ```\n  generates\n  ```\n  @[simp] lemma Equiv.trans_toFun : ∀ {α β γ} (e₁ e₂) (a : α), ⇑(e₁.trans e₂) a = (⇑e₂ ∘ ⇑e₁) a\n  @[simp] lemma Equiv.trans_invFun : ∀ {α β γ} (e₁ e₂) (a : γ),\n    ⇑((e₁.trans e₂).symm) a = (⇑(e₁.symm) ∘ ⇑(e₂.symm)) a\n  ```\n\n* You can specify custom projection names, by specifying the new projection names using\n  `initialize_simps_projections`.\n  Example: `initialize_simps_projections Equiv (toFun → apply, invFun → symm_apply)`.\n  See `initialize_simps_projections` for more information.\n\n* If one of the fields itself is a structure, this command will recursively create\n  `simp` lemmas for all fields in that structure.\n  * Exception: by default it will not recursively create `simp` lemmas for fields in the structures\n    `Prod`, `PProd`, and `Opposite`. You can give explicit projection names or change the value of\n    `Simps.Config.notRecursive` to override this behavior.\n\n  Example:\n  ```lean\n  structure MyProd (α β : Type*) := (fst : α) (snd : β)\n  @[simps] def foo : Prod ℕ ℕ × MyProd ℕ ℕ := ⟨⟨1, 2⟩, 3, 4⟩\n  ```\n  generates\n  ```lean\n  @[simp] lemma foo_fst : foo.fst = (1, 2)\n  @[simp] lemma foo_snd_fst : foo.snd.fst = 3\n  @[simp] lemma foo_snd_snd : foo.snd.snd = 4\n  ```\n\n* You can use `@[simps proj1 proj2 ...]` to only generate the projection lemmas for the specified\n  projections.\n* Recursive projection names can be specified using `proj1_proj2_proj3`.\n  This will create a lemma of the form `foo.proj1.proj2.proj3 = ...`.\n\n  Example:\n  ```lean\n  structure MyProd (α β : Type*) := (fst : α) (snd : β)\n  @[simps fst fst_fst snd] def foo : Prod ℕ ℕ × MyProd ℕ ℕ := ⟨⟨1, 2⟩, 3, 4⟩\n  ```\n  generates\n  ```lean\n  @[simp] lemma foo_fst : foo.fst = (1, 2)\n  @[simp] lemma foo_fst_fst : foo.fst.fst = 1\n  @[simp] lemma foo_snd : foo.snd = {fst := 3, snd := 4}\n  ```\n* If one of the values is an eta-expanded structure, we will eta-reduce this structure.\n\n  Example:\n  ```lean\n  structure EquivPlusData (α β) extends α ≃ β where\n    data : Bool\n  @[simps] def EquivPlusData.rfl {α} : EquivPlusData α α := { Equiv.refl α with data := true }\n  ```\n  generates the following:\n  ```lean\n  @[simp] lemma bar_toEquiv : ∀ {α : Sort*}, bar.toEquiv = Equiv.refl α\n  @[simp] lemma bar_data : ∀ {α : Sort*}, bar.data = true\n  ```\n  This is true, even though Lean inserts an eta-expanded version of `Equiv.refl α` in the\n  definition of `bar`.\n* For configuration options, see the doc string of `Simps.Config`.\n* The precise syntax is `simps (config := e)? ident*`, where `e : Expr` is an expression of type\n  `Simps.Config` and `ident*` is a list of desired projection names.\n* `@[simps]` reduces let-expressions where necessary.\n* When option `trace.simps.verbose` is true, `simps` will print the projections it finds and the\n  lemmas it generates. The same can be achieved by using `@[simps?]`.\n* Use `@[to_additive (attr := simps)]` to apply both `to_additive` and `simps` to a definition\n  This will also generate the additive versions of all `simp` lemmas.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Attr.simps\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">simps</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L133-L134","name":"Lean.Parser.Attr.simpsArgsRest","line":133,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Attr.simpsArgsRest","doc":"arguments to `@[simps]` attribute. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Lean.Parser.Attr.simpsArgsRest\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">simpsArgsRest</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L111-L113","name":"hasSimpAttribute","line":111,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#hasSimpAttribute","doc":"Tests whether `declName` has the `@[simp]` attribute in `env`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#hasSimpAttribute\"><span class=\"name\">hasSimpAttribute</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(env : <a href=\"./Lean/Environment.html#Lean.Environment\">Lean.Environment</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(declName : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L100-L107","name":"Lean.Meta.mkSimpContext","line":100,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Meta.mkSimpContext","doc":"Make `Simp.Context` giving data instead of Syntax. Doesn't support arguments.\nIntended to be very similar to `Lean.Elab.Tactic.mkSimpContext`\nTodo: support arguments. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Lean.Meta.mkSimpContext\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkSimpContext</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Init/MetaTypes.html#Lean.Meta.Simp.Config\">Lean.Meta.Simp.Config</a> :=\n  <span class=\"fn\">{ <span class=\"fn\">maxSteps</span> := <a href=\"./Init/MetaTypes.html#Lean.Meta.Simp.defaultMaxSteps\">Lean.Meta.Simp.defaultMaxSteps</a>, <span class=\"fn\">maxDischargeDepth</span> := <span class=\"fn\">2</span>, <span class=\"fn\">contextual</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>, <span class=\"fn\">memoize</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>,\n    <span class=\"fn\">singlePass</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>, <span class=\"fn\">zeta</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>, <span class=\"fn\">beta</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>, <span class=\"fn\">eta</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>, <span class=\"fn\">etaStruct</span> := <a href=\"./Init/MetaTypes.html#Lean.Meta.EtaStructMode.all\">Lean.Meta.EtaStructMode.all</a>,\n    <span class=\"fn\">iota</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>, <span class=\"fn\">proj</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>, <span class=\"fn\">decide</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>, <span class=\"fn\">arith</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>, <span class=\"fn\">autoUnfold</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>, <span class=\"fn\">dsimp</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>,\n    <span class=\"fn\">failIfUnchanged</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>, <span class=\"fn\">ground</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>, <span class=\"fn\">unfoldPartialApp</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>, <span class=\"fn\">zetaDelta</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>, <span class=\"fn\">index</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>,\n    <span class=\"fn\">implicitDefEqProofs</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(simpOnly : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(kind : <a href=\"./Lean/Elab/Tactic/Simp.html#Lean.Elab.Tactic.SimpKind\">Lean.Elab.Tactic.SimpKind</a> := <a href=\"./Lean/Elab/Tactic/Simp.html#Lean.Elab.Tactic.SimpKind.simp\">Lean.Elab.Tactic.SimpKind.simp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(dischargeWrapper : <a href=\"./Lean/Elab/Tactic/Simp.html#Lean.Elab.Tactic.Simp.DischargeWrapper\">Lean.Elab.Tactic.Simp.DischargeWrapper</a> := <a href=\"./Lean/Elab/Tactic/Simp.html#Lean.Elab.Tactic.Simp.DischargeWrapper.default\">Lean.Elab.Tactic.Simp.DischargeWrapper.default</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hasStar : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Context\">Lean.Meta.Simp.Context</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L66-L98","name":"Lean.Meta.mkSimpContextResult","line":66,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#Lean.Meta.mkSimpContextResult","doc":"Make `MkSimpContextResult` giving data instead of Syntax. Doesn't support arguments.\nIntended to be very similar to `Lean.Elab.Tactic.mkSimpContext`\nTodo: support arguments. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#Lean.Meta.mkSimpContextResult\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkSimpContextResult</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Init/MetaTypes.html#Lean.Meta.Simp.Config\">Lean.Meta.Simp.Config</a> :=\n  <span class=\"fn\">{ <span class=\"fn\">maxSteps</span> := <a href=\"./Init/MetaTypes.html#Lean.Meta.Simp.defaultMaxSteps\">Lean.Meta.Simp.defaultMaxSteps</a>, <span class=\"fn\">maxDischargeDepth</span> := <span class=\"fn\">2</span>, <span class=\"fn\">contextual</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>, <span class=\"fn\">memoize</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>,\n    <span class=\"fn\">singlePass</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>, <span class=\"fn\">zeta</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>, <span class=\"fn\">beta</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>, <span class=\"fn\">eta</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>, <span class=\"fn\">etaStruct</span> := <a href=\"./Init/MetaTypes.html#Lean.Meta.EtaStructMode.all\">Lean.Meta.EtaStructMode.all</a>,\n    <span class=\"fn\">iota</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>, <span class=\"fn\">proj</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>, <span class=\"fn\">decide</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>, <span class=\"fn\">arith</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>, <span class=\"fn\">autoUnfold</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>, <span class=\"fn\">dsimp</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>,\n    <span class=\"fn\">failIfUnchanged</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>, <span class=\"fn\">ground</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>, <span class=\"fn\">unfoldPartialApp</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>, <span class=\"fn\">zetaDelta</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>, <span class=\"fn\">index</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>,\n    <span class=\"fn\">implicitDefEqProofs</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(simpOnly : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(kind : <a href=\"./Lean/Elab/Tactic/Simp.html#Lean.Elab.Tactic.SimpKind\">Lean.Elab.Tactic.SimpKind</a> := <a href=\"./Lean/Elab/Tactic/Simp.html#Lean.Elab.Tactic.SimpKind.simp\">Lean.Elab.Tactic.SimpKind.simp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(dischargeWrapper : <a href=\"./Lean/Elab/Tactic/Simp.html#Lean.Elab.Tactic.Simp.DischargeWrapper\">Lean.Elab.Tactic.Simp.DischargeWrapper</a> := <a href=\"./Lean/Elab/Tactic/Simp.html#Lean.Elab.Tactic.Simp.DischargeWrapper.default\">Lean.Elab.Tactic.Simp.DischargeWrapper.default</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hasStar : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Elab/Tactic/Simp.html#Lean.Elab.Tactic.MkSimpContextResult\">Lean.Elab.Tactic.MkSimpContextResult</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Simps/Basic.lean#L57-L61","name":"updateName","line":57,"kind":"def","docLink":"./Mathlib/Tactic/Simps/Basic.html#updateName","doc":"`updateName nm s isPrefix` adds `s` to the last component of `nm`,\neither as prefix or as suffix (specified by `isPrefix`), separated by `_`.\nUsed by `simps_add_projections`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simps/Basic.html#updateName\"><span class=\"name\">updateName</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(nm : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(s : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(isPrefix : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></div></div>"}]}