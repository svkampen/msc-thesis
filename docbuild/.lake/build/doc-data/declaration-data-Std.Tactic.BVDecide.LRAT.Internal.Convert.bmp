{"name":"Std.Tactic.BVDecide.LRAT.Internal.Convert","instances":[],"imports":["Std.Sat.CNF.RelabelFin","Std.Tactic.BVDecide.LRAT.Internal.Formula"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Tactic/BVDecide/LRAT/Internal/Convert.lean#L143-L167","name":"Std.Tactic.BVDecide.LRAT.Internal.CNF.unsat_of_convertLRAT_unsat","line":143,"kind":"theorem","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.unsat_of_convertLRAT_unsat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.unsat_of_convertLRAT_unsat\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">CNF</span>.<span class=\"name\">unsat_of_convertLRAT_unsat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cnf : <span class=\"fn\"><a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF\">Std.Sat.CNF</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Entails.html#Std.Tactic.BVDecide.LRAT.Internal.Unsatisfiable\">Std.Tactic.BVDecide.LRAT.Internal.Unsatisfiable</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/PosFin.html#Std.Tactic.BVDecide.LRAT.Internal.PosFin\">Std.Tactic.BVDecide.LRAT.Internal.PosFin</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">cnf</span>.numLiterals</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">1</span>)</span>)</span>\n    <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT\">Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT</a> <span class=\"fn\">cnf</span>)</span></span> →\n  <span class=\"fn\"><span class=\"fn\">cnf</span>.Unsat</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Tactic/BVDecide/LRAT/Internal/Convert.lean#L133-L141","name":"Std.Tactic.BVDecide.LRAT.Internal.unsat_of_cons_none_unsat","line":133,"kind":"theorem","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.unsat_of_cons_none_unsat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.unsat_of_cons_none_unsat\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">unsat_of_cons_none_unsat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">Nat</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(clauses : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Clause.html#Std.Tactic.BVDecide.LRAT.Internal.DefaultClause\">Std.Tactic.BVDecide.LRAT.Internal.DefaultClause</a> <span class=\"fn\">n</span>)</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Entails.html#Std.Tactic.BVDecide.LRAT.Internal.Unsatisfiable\">Std.Tactic.BVDecide.LRAT.Internal.Unsatisfiable</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/PosFin.html#Std.Tactic.BVDecide.LRAT.Internal.PosFin\">Std.Tactic.BVDecide.LRAT.Internal.PosFin</a> <span class=\"fn\">n</span>)</span>\n    <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Formula/Implementation.html#Std.Tactic.BVDecide.LRAT.Internal.DefaultFormula.ofArray\">Std.Tactic.BVDecide.LRAT.Internal.DefaultFormula.ofArray</a> <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\">none</span> <a href=\"./Init/Prelude.html#List.cons\">::</a> <span class=\"fn\">clauses</span>)</span>.toArray</span>)</span></span> →\n  <span class=\"fn\"><a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Entails.html#Std.Tactic.BVDecide.LRAT.Internal.Unsatisfiable\">Std.Tactic.BVDecide.LRAT.Internal.Unsatisfiable</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/PosFin.html#Std.Tactic.BVDecide.LRAT.Internal.PosFin\">Std.Tactic.BVDecide.LRAT.Internal.PosFin</a> <span class=\"fn\">n</span>)</span>\n    <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Formula/Implementation.html#Std.Tactic.BVDecide.LRAT.Internal.DefaultFormula.ofArray\">Std.Tactic.BVDecide.LRAT.Internal.DefaultFormula.ofArray</a> <span class=\"fn\"><span class=\"fn\">clauses</span>.toArray</span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Tactic/BVDecide/LRAT/Internal/Convert.lean#L128-L131","name":"Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT_readyForRatAdd","line":128,"kind":"theorem","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT_readyForRatAdd","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT_readyForRatAdd\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">CNF</span>.<span class=\"name\">convertLRAT_readyForRatAdd</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cnf : <span class=\"fn\"><a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF\">Std.Sat.CNF</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT\">Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT</a> <span class=\"fn\">cnf</span>)</span>.ReadyForRatAdd</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Tactic/BVDecide/LRAT/Internal/Convert.lean#L123-L126","name":"Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT_readyForRupAdd","line":123,"kind":"theorem","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT_readyForRupAdd","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT_readyForRupAdd\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">CNF</span>.<span class=\"name\">convertLRAT_readyForRupAdd</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cnf : <span class=\"fn\"><a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF\">Std.Sat.CNF</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT\">Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT</a> <span class=\"fn\">cnf</span>)</span>.ReadyForRupAdd</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Tactic/BVDecide/LRAT/Internal/Convert.lean#L109-L121","name":"Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT","line":109,"kind":"def","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT","doc":"Convert a `CNF Nat` with a certain maximum variable number into the `DefaultFormula`\nformat for usage with `bv_decide`'s `LRAT.Internal`.\n\nNotably this:\n1. Increments all variables as DIMACS variables start at 1 instead of 0\n2. Adds a leading `none` clause. This clause *must* be persistent as the LRAT checker wants to have\n  the DIMACS file line by line and the DIMACS file begins with the `p cnf x y` meta instruction.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">CNF</span>.<span class=\"name\">convertLRAT</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cnf : <span class=\"fn\"><a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF\">Std.Sat.CNF</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Formula/Implementation.html#Std.Tactic.BVDecide.LRAT.Internal.DefaultFormula\">Std.Tactic.BVDecide.LRAT.Internal.DefaultFormula</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">cnf</span>.numLiterals</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">1</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Tactic/BVDecide/LRAT/Internal/Convert.lean#L95-L107","name":"Std.Tactic.BVDecide.LRAT.Internal.CNF.Clause.convertLRAT_sat_of_sat","line":95,"kind":"theorem","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.Clause.convertLRAT_sat_of_sat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.Clause.convertLRAT_sat_of_sat\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">CNF</span>.<span class=\"name\">Clause</span>.<span class=\"name\">convertLRAT_sat_of_sat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">Nat</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{lratClause : <span class=\"fn\"><a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Clause.html#Std.Tactic.BVDecide.LRAT.Internal.DefaultClause\">Std.Tactic.BVDecide.LRAT.Internal.DefaultClause</a> <span class=\"fn\">n</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{assign : <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/BVDecide/LRAT/Internal/PosFin.html#Std.Tactic.BVDecide.LRAT.Internal.PosFin\">Std.Tactic.BVDecide.LRAT.Internal.PosFin</a> <span class=\"fn\">n</span></span> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(clause : <span class=\"fn\"><a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF.Clause\">Std.Sat.CNF.Clause</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/PosFin.html#Std.Tactic.BVDecide.LRAT.Internal.PosFin\">Std.Tactic.BVDecide.LRAT.Internal.PosFin</a> <span class=\"fn\">n</span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.Clause.convertLRAT'\">Std.Tactic.BVDecide.LRAT.Internal.CNF.Clause.convertLRAT'</a> <span class=\"fn\">clause</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Option.some\">some</a> <span class=\"fn\">lratClause</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF.Clause.eval\">Std.Sat.CNF.Clause.eval</a> <span class=\"fn\">assign</span> <span class=\"fn\">clause</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span> → <span class=\"fn\"><a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Entails.html#Std.Tactic.BVDecide.LRAT.Internal.Entails.eval\">Std.Tactic.BVDecide.LRAT.Internal.Entails.eval</a> <span class=\"fn\">assign</span> <span class=\"fn\">lratClause</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Tactic/BVDecide/LRAT/Internal/Convert.lean#L58-L93","name":"Std.Tactic.BVDecide.LRAT.Internal.CNF.Clause.mem_lrat_of_mem","line":58,"kind":"theorem","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.Clause.mem_lrat_of_mem","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.Clause.mem_lrat_of_mem\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">CNF</span>.<span class=\"name\">Clause</span>.<span class=\"name\">mem_lrat_of_mem</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">Nat</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{l : <span class=\"fn\"><a href=\"./Std/Sat/CNF/Literal.html#Std.Sat.Literal\">Std.Sat.Literal</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/PosFin.html#Std.Tactic.BVDecide.LRAT.Internal.PosFin\">Std.Tactic.BVDecide.LRAT.Internal.PosFin</a> <span class=\"fn\">n</span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{lratClause : <span class=\"fn\"><a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Clause.html#Std.Tactic.BVDecide.LRAT.Internal.DefaultClause\">Std.Tactic.BVDecide.LRAT.Internal.DefaultClause</a> <span class=\"fn\">n</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(clause : <span class=\"fn\"><a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF.Clause\">Std.Sat.CNF.Clause</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/PosFin.html#Std.Tactic.BVDecide.LRAT.Internal.PosFin\">Std.Tactic.BVDecide.LRAT.Internal.PosFin</a> <span class=\"fn\">n</span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h1 : <span class=\"fn\"><span class=\"fn\">l</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">clause</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h2 : <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Clause.html#Std.Tactic.BVDecide.LRAT.Internal.DefaultClause.ofArray\">Std.Tactic.BVDecide.LRAT.Internal.DefaultClause.ofArray</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List.toArray\">List.toArray</a> <span class=\"fn\">clause</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Option.some\">some</a> <span class=\"fn\">lratClause</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">l</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\"><span class=\"fn\">lratClause</span>.clause</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Tactic/BVDecide/LRAT/Internal/Convert.lean#L46-L56","name":"Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT'","line":46,"kind":"def","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT'","doc":"Turn a `CNF PosFin` into the representation used by the LRAT checker.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT'\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">CNF</span>.<span class=\"name\">convertLRAT'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">Nat</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(clauses : <span class=\"fn\"><a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF\">Std.Sat.CNF</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/PosFin.html#Std.Tactic.BVDecide.LRAT.Internal.PosFin\">Std.Tactic.BVDecide.LRAT.Internal.PosFin</a> <span class=\"fn\">n</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Clause.html#Std.Tactic.BVDecide.LRAT.Internal.DefaultClause\">Std.Tactic.BVDecide.LRAT.Internal.DefaultClause</a> <span class=\"fn\">n</span>)</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Tactic/BVDecide/LRAT/Internal/Convert.lean#L40-L44","name":"Std.Tactic.BVDecide.LRAT.Internal.CNF.Clause.convertLRAT'","line":40,"kind":"def","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.Clause.convertLRAT'","doc":"Turn a `CNF.Clause PosFin` into the representation used by the LRAT checker.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.Clause.convertLRAT'\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">CNF</span>.<span class=\"name\">Clause</span>.<span class=\"name\">convertLRAT'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">Nat</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(clause : <span class=\"fn\"><a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF.Clause\">Std.Sat.CNF.Clause</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/PosFin.html#Std.Tactic.BVDecide.LRAT.Internal.PosFin\">Std.Tactic.BVDecide.LRAT.Internal.PosFin</a> <span class=\"fn\">n</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Clause.html#Std.Tactic.BVDecide.LRAT.Internal.DefaultClause\">Std.Tactic.BVDecide.LRAT.Internal.DefaultClause</a> <span class=\"fn\">n</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Tactic/BVDecide/LRAT/Internal/Convert.lean#L28-L38","name":"Std.Tactic.BVDecide.LRAT.Internal.CNF.unsat_of_lift_unsat","line":28,"kind":"theorem","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.unsat_of_lift_unsat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.unsat_of_lift_unsat\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">CNF</span>.<span class=\"name\">unsat_of_lift_unsat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cnf : <span class=\"fn\"><a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF\">Std.Sat.CNF</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.lift\">Std.Tactic.BVDecide.LRAT.Internal.CNF.lift</a> <span class=\"fn\">cnf</span>)</span>.Unsat</span> → <span class=\"fn\"><span class=\"fn\">cnf</span>.Unsat</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Std/Tactic/BVDecide/LRAT/Internal/Convert.lean#L19-L26","name":"Std.Tactic.BVDecide.LRAT.Internal.CNF.lift","line":19,"kind":"def","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.lift","doc":"Turn a `CNF Nat`, that might contain `0` as a variable, to a `CNF PosFin`.\nThis representation is guaranteed to not have `0` and is limited to an upper bound of\nvariable indices.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.lift\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">CNF</span>.<span class=\"name\">lift</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cnf : <span class=\"fn\"><a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF\">Std.Sat.CNF</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF\">Std.Sat.CNF</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/PosFin.html#Std.Tactic.BVDecide.LRAT.Internal.PosFin\">Std.Tactic.BVDecide.LRAT.Internal.PosFin</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">cnf</span>.numLiterals</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">1</span>)</span>)</span></span></div></div>"}]}