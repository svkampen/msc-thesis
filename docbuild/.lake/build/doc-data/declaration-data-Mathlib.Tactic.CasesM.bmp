{"name":"Mathlib.Tactic.CasesM","instances":[],"imports":["Init","Mathlib.Init","Lean.Elab.Tactic.Conv.Pattern"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CasesM.lean#L152-L166","name":"Mathlib.Tactic.constructorM","line":152,"kind":"def","docLink":"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.constructorM","doc":"* `constructorm p_1, ..., p_n` applies the `constructor` tactic to the main goal\n  if `type` matches one of the given patterns.\n* `constructorm* p` is a more efficient and compact version of `· repeat constructorm p`.\n  It is more efficient because the pattern is compiled once.\n\nExample: The following tactic proves any theorem like `True ∧ (True ∨ True)` consisting of\nand/or/true:\n```\nconstructorm* _ ∨ _, _ ∧ _, True\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.constructorM\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">constructorM</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CasesM.lean#L143-L150","name":"Mathlib.Tactic.constructorMatching.go","line":143,"kind":"opaque","docLink":"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.constructorMatching.go","doc":"Auxiliary for `constructorMatching`. Accumulates generated subgoals in `acc`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.constructorMatching.go\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">constructorMatching</span>.<span class=\"name\">go</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(matcher : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(acc : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span> := <span class=\"fn\">#[]</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CasesM.lean#L122-L150","name":"Mathlib.Tactic.constructorMatching","line":122,"kind":"def","docLink":"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.constructorMatching","doc":"Core tactic for `constructorm`. Calls `constructor` on all subgoals for which\n`matcher ldecl.type` returns true.\n* `recursive`: if true, it calls itself repeatedly on the resulting subgoals\n* `throwOnNoMatch`: if true, throws an error if no match is found\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.constructorMatching\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">constructorMatching</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(matcher : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(recursive : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(throwOnNoMatch : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CasesM.lean#L118-L120","name":"Mathlib.Tactic.casesType!","line":118,"kind":"def","docLink":"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.casesType!","doc":"* `cases_type I` applies the `cases` tactic to a hypothesis `h : (I ...)`\n* `cases_type I_1 ... I_n` applies the `cases` tactic to a hypothesis\n  `h : (I_1 ...)` or ... or `h : (I_n ...)`\n* `cases_type* I` is shorthand for `· repeat cases_type I`\n* `cases_type! I` only applies `cases` if the number of resulting subgoals is <= 1.\n\nExample: The following tactic destructs all conjunctions and disjunctions in the current goal.\n```\ncases_type* Or And\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.casesType!\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">casesType!</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CasesM.lean#L103-L116","name":"Mathlib.Tactic.casesType","line":103,"kind":"def","docLink":"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.casesType","doc":"* `cases_type I` applies the `cases` tactic to a hypothesis `h : (I ...)`\n* `cases_type I_1 ... I_n` applies the `cases` tactic to a hypothesis\n  `h : (I_1 ...)` or ... or `h : (I_n ...)`\n* `cases_type* I` is shorthand for `· repeat cases_type I`\n* `cases_type! I` only applies `cases` if the number of resulting subgoals is <= 1.\n\nExample: The following tactic destructs all conjunctions and disjunctions in the current goal.\n```\ncases_type* Or And\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.casesType\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">casesType</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CasesM.lean#L97-L101","name":"Mathlib.Tactic.elabCasesType","line":97,"kind":"def","docLink":"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.elabCasesType","doc":"Common implementation of `cases_type` and `cases_type!`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.elabCasesType\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">elabCasesType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(heads : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Meta.html#Lean.Syntax.Ident\">Lean.Ident</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(recursive : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(allowSplit : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CasesM.lean#L80-L95","name":"Mathlib.Tactic.casesM","line":80,"kind":"def","docLink":"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.casesM","doc":"* `casesm p` applies the `cases` tactic to a hypothesis `h : type`\n  if `type` matches the pattern `p`.\n* `casesm p_1, ..., p_n` applies the `cases` tactic to a hypothesis `h : type`\n  if `type` matches one of the given patterns.\n* `casesm* p` is a more efficient and compact version of `· repeat casesm p`.\n  It is more efficient because the pattern is compiled once.\n\nExample: The following tactic destructs all conjunctions and disjunctions in the current context.\n```\ncasesm* _ ∨ _, _ ∧ _\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.casesM\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">casesM</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CasesM.lean#L75-L78","name":"Mathlib.Tactic.matchPatterns","line":75,"kind":"def","docLink":"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.matchPatterns","doc":"Returns true if any of the patterns match the expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.matchPatterns\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">matchPatterns</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(pats : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.AbstractMVarsResult\">Lean.Meta.AbstractMVarsResult</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CasesM.lean#L68-L73","name":"Mathlib.Tactic.elabPatterns","line":68,"kind":"def","docLink":"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.elabPatterns","doc":"Elaborate a list of terms with holes into a list of patterns. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.elabPatterns\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">elabPatterns</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(pats : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.AbstractMVarsResult\">Lean.Meta.AbstractMVarsResult</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CasesM.lean#L57-L61","name":"Lean.MVarId.casesType","line":57,"kind":"def","docLink":"./Mathlib/Tactic/CasesM.html#Lean.MVarId.casesType","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Lean.MVarId.casesType\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">casesType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(heads : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(recursive : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(allowSplit : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CasesM.lean#L33-L55","name":"Lean.MVarId.casesMatching.go","line":33,"kind":"opaque","docLink":"./Mathlib/Tactic/CasesM.html#Lean.MVarId.casesMatching.go","doc":"Auxiliary for `casesMatching`. Accumulates generated subgoals in `acc`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Lean.MVarId.casesMatching.go\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">casesMatching</span>.<span class=\"name\">go</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(matcher : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(recursive : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(allowSplit : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(acc : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span> := <span class=\"fn\">#[]</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CasesM.lean#L17-L55","name":"Lean.MVarId.casesMatching","line":17,"kind":"def","docLink":"./Mathlib/Tactic/CasesM.html#Lean.MVarId.casesMatching","doc":"Core tactic for `casesm` and `cases_type`. Calls `cases` on all fvars in `g` for which\n`matcher ldecl.type` returns true.\n* `recursive`: if true, it calls itself repeatedly on the resulting subgoals\n* `allowSplit`: if false, it will skip any hypotheses where `cases` returns more than one subgoal.\n* `throwOnNoMatch`: if true, then throws an error if no match is found\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CasesM.html#Lean.MVarId.casesMatching\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">casesMatching</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(matcher : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(recursive : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(allowSplit throwOnNoMatch : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span></div></div>"}]}