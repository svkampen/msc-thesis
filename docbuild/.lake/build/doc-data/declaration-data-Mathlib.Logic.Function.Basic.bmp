{"name":"Mathlib.Logic.Function.Basic","instances":[{"typeNames":["Eq"],"name":"Function.decidableEqPFun","className":"Decidable"},{"typeNames":[],"name":"Function.hasUncurryBase","className":"Function.HasUncurry"},{"typeNames":["Prod"],"name":"Function.hasUncurryInduction","className":"Function.HasUncurry"},{"typeNames":["Function.uncurry"],"name":"instDecidableUncurryOfFstSnd_mathlib","className":"Decidable"},{"typeNames":["Function.curry"],"name":"instDecidableCurryOfMk_mathlib","className":"Decidable"}],"imports":["Init","Mathlib.Data.Set.Defs","Mathlib.Logic.Basic","Mathlib.Logic.ExistsUnique","Mathlib.Logic.Nonempty","Batteries.Tactic.Init","Mathlib.Order.Defs.PartialOrder","Mathlib.Order.Defs.Unbundled"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L981-L983","name":"instDecidableCurryOfMk_mathlib","line":981,"kind":"instance","docLink":"./Mathlib/Logic/Function/Basic.html#instDecidableCurryOfMk_mathlib","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#instDecidableCurryOfMk_mathlib\"><span class=\"name\">instDecidableCurryOfMk_mathlib</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> u_4}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{r : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">β</span></span> → <a href=\"./foundational_types.html\">Prop</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{a : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{b : <span class=\"fn\">β</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> <span class=\"fn\">(<span class=\"fn\">r</span> <span class=\"fn\">(<span class=\"fn\">a</span>, <span class=\"fn\">b</span>)</span>)</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> <span class=\"fn\">(<a href=\"./Init/Data/Function.html#Function.curry\">Function.curry</a> <span class=\"fn\">r</span> <span class=\"fn\">a</span> <span class=\"fn\">b</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L977-L979","name":"instDecidableUncurryOfFstSnd_mathlib","line":977,"kind":"instance","docLink":"./Mathlib/Logic/Function/Basic.html#instDecidableUncurryOfFstSnd_mathlib","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#instDecidableUncurryOfFstSnd_mathlib\"><span class=\"name\">instDecidableUncurryOfFstSnd_mathlib</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> u_4}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{r : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><span class=\"fn\">β</span> → <a href=\"./foundational_types.html\">Prop</a></span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{x : <span class=\"fn\"><span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> <span class=\"fn\">(<span class=\"fn\">r</span> <span class=\"fn\"><span class=\"fn\">x</span>.fst</span> <span class=\"fn\"><span class=\"fn\">x</span>.snd</span>)</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> <span class=\"fn\">(<a href=\"./Init/Data/Function.html#Function.uncurry\">Function.uncurry</a> <span class=\"fn\">r</span> <span class=\"fn\">x</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L973-L975","name":"InvImage.equivalence","line":973,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#InvImage.equivalence","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#InvImage.equivalence\"><span class=\"name\">InvImage</span>.<span class=\"name\">equivalence</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> v}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(r : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">β</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Init/Core.html#Equivalence\">Equivalence</a> <span class=\"fn\">r</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Core.html#Equivalence\">Equivalence</a> <span class=\"fn\">(<a href=\"./Init/Core.html#InvImage\">InvImage</a> <span class=\"fn\">r</span> <span class=\"fn\">f</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L968-L971","name":"Set.SeparatesPoints","line":968,"kind":"def","docLink":"./Mathlib/Logic/Function/Basic.html#Set.SeparatesPoints","doc":"A set of functions \"separates points\"\nif for each pair of distinct points there is a function taking different values on them. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Set.SeparatesPoints\"><span class=\"name\">Set</span>.<span class=\"name\">SeparatesPoints</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> u_4}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(A : <span class=\"fn\"><a href=\"./Mathlib/Data/Set/Defs.html#Set\">Set</a> <span class=\"fn\">(<span class=\"fn\">α</span> → <span class=\"fn\">β</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L963-L966","name":"Function.LeftInverse.cast_eq","line":963,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.LeftInverse.cast_eq","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.LeftInverse.cast_eq\"><span class=\"name\">Function</span>.<span class=\"name\">LeftInverse</span>.<span class=\"name\">cast_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <span class=\"fn\"><span class=\"fn\">β</span> → <a href=\"./foundational_types.html\">Sort</a> v</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.LeftInverse\">Function.LeftInverse</a> <span class=\"fn\">g</span> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(C : <span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><span class=\"fn\">γ</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">a</span>)</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#cast\">cast</a> <span class=\"fn\">⋯</span> <span class=\"fn\">(<span class=\"fn\">C</span> <span class=\"fn\">(<span class=\"fn\">g</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">a</span>)</span>)</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">C</span> <span class=\"fn\">a</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L957-L961","name":"Function.LeftInverse.eq_rec_on_eq","line":957,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.LeftInverse.eq_rec_on_eq","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.LeftInverse.eq_rec_on_eq\"><span class=\"name\">Function</span>.<span class=\"name\">LeftInverse</span>.<span class=\"name\">eq_rec_on_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <span class=\"fn\"><span class=\"fn\">β</span> → <a href=\"./foundational_types.html\">Sort</a> v</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.LeftInverse\">Function.LeftInverse</a> <span class=\"fn\">g</span> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(C : <span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><span class=\"fn\">γ</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">a</span>)</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Eq.recOn\">Eq.recOn</a> <span class=\"fn\">⋯</span> <span class=\"fn\">(<span class=\"fn\">C</span> <span class=\"fn\">(<span class=\"fn\">g</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">a</span>)</span>)</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">C</span> <span class=\"fn\">a</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L951-L955","name":"Function.LeftInverse.eq_rec_eq","line":951,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.LeftInverse.eq_rec_eq","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.LeftInverse.eq_rec_eq\"><span class=\"name\">Function</span>.<span class=\"name\">LeftInverse</span>.<span class=\"name\">eq_rec_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <span class=\"fn\"><span class=\"fn\">β</span> → <a href=\"./foundational_types.html\">Sort</a> v</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.LeftInverse\">Function.LeftInverse</a> <span class=\"fn\">g</span> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(C : <span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><span class=\"fn\">γ</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">a</span>)</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">⋯</span> ▸ <span class=\"fn\"><span class=\"fn\">C</span> <span class=\"fn\">(<span class=\"fn\">g</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">a</span>)</span>)</span></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">C</span> <span class=\"fn\">a</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L947-L949","name":"cast_inj","line":947,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#cast_inj","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#cast_inj\"><span class=\"name\">cast_inj</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α β : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{x y : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#cast\">cast</a> <span class=\"fn\">h</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#cast\">cast</a> <span class=\"fn\">h</span> <span class=\"fn\">y</span></span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L942-L945","name":"eq_rec_inj","line":942,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#eq_rec_inj","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#eq_rec_inj\"><span class=\"name\">eq_rec_inj</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{a a' : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Type</a> u_3</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x y : <span class=\"fn\"><span class=\"fn\">C</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">h</span> ▸ <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">h</span> ▸ <span class=\"fn\">y</span></span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L935-L937","name":"cast_bijective","line":935,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#cast_bijective","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#cast_bijective\"><span class=\"name\">cast_bijective</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α β : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Bijective\">Function.Bijective</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#cast\">cast</a> <span class=\"fn\">h</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L931-L933","name":"eq_mpr_bijective","line":931,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#eq_mpr_bijective","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#eq_mpr_bijective\"><span class=\"name\">eq_mpr_bijective</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α β : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Bijective\">Function.Bijective</a> <span class=\"fn\"><span class=\"fn\">h</span>.mpr</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L925-L929","name":"eq_mp_bijective","line":925,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#eq_mp_bijective","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#eq_mp_bijective\"><span class=\"name\">eq_mp_bijective</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α β : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Bijective\">Function.Bijective</a> <span class=\"fn\"><span class=\"fn\">h</span>.mp</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L921-L923","name":"eq_rec_on_bijective","line":921,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#eq_rec_on_bijective","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#eq_rec_on_bijective\"><span class=\"name\">eq_rec_on_bijective</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Sort</a> u_3</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{a a' : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Bijective\">Function.Bijective</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> : <span class=\"fn\"><span class=\"fn\">C</span> <span class=\"fn\">a</span></span>) =&gt; <span class=\"fn\"><span class=\"fn\">h</span> ▸ <span class=\"fn\">x</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L913-L916","name":"Set.piecewise","line":913,"kind":"def","docLink":"./Mathlib/Logic/Function/Basic.html#Set.piecewise","doc":"`s.piecewise f g` is the function equal to `f` on the set `s`, and to `g` on its complement. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Set.piecewise\"><span class=\"name\">Set</span>.<span class=\"name\">piecewise</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Sort</a> v</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Mathlib/Data/Set/Defs.html#Set\">Set</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f g : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">i</span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">(<span class=\"fn\">j</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> <span class=\"fn\">(<span class=\"fn\">j</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">s</span>)</span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">i</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L906-L911","name":"Symmetric.forall_existsUnique_iff","line":906,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Symmetric.forall_existsUnique_iff","doc":"A symmetric relation `r : α → α → Prop` is \"function-like\"\n(for each `a` there exists a unique `b` such that `r a b`)\nif and only if it is `(f · = ·)` for some involutive function `f`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Symmetric.forall_existsUnique_iff\"><span class=\"name\">Symmetric</span>.<span class=\"name\">forall_existsUnique_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{r : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hr : <span class=\"fn\"><a href=\"./Mathlib/Order/Defs/Unbundled.html#Symmetric\">Symmetric</a> <span class=\"fn\">r</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(∀ (<span class=\"fn\">a</span> : <span class=\"fn\">α</span>), <span class=\"fn\">∃! <span class=\"fn\">b</span> : <span class=\"fn\">α</span>, <span class=\"fn\"><span class=\"fn\">r</span> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span></span>)</span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">∃ (<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span></span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.Involutive\">Function.Involutive</a> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\">∀ {<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>}, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">r</span> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L897-L904","name":"Symmetric.forall_existsUnique_iff'","line":897,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Symmetric.forall_existsUnique_iff'","doc":"A symmetric relation `r : α → α → Prop` is \"function-like\"\n(for each `a` there exists a unique `b` such that `r a b`)\nif and only if it is `(f · = ·)` for some involutive function `f`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Symmetric.forall_existsUnique_iff'\"><span class=\"name\">Symmetric</span>.<span class=\"name\">forall_existsUnique_iff'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{r : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hr : <span class=\"fn\"><a href=\"./Mathlib/Order/Defs/Unbundled.html#Symmetric\">Symmetric</a> <span class=\"fn\">r</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(∀ (<span class=\"fn\">a</span> : <span class=\"fn\">α</span>), <span class=\"fn\">∃! <span class=\"fn\">b</span> : <span class=\"fn\">α</span>, <span class=\"fn\"><span class=\"fn\">r</span> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span></span>)</span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">∃ (<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span></span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.Involutive\">Function.Involutive</a> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\"><span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">fun (<span class=\"fn\">x1</span> <span class=\"fn\">x2</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">x1</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">x2</span></span></span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L890-L895","name":"forall_existsUnique_iff'","line":890,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#forall_existsUnique_iff'","doc":"A relation `r : α → β → Prop` is \"function-like\"\n(for each `a` there exists a unique `b` such that `r a b`)\nif and only if it is `(f · = ·)` for some function `f`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#forall_existsUnique_iff'\"><span class=\"name\">forall_existsUnique_iff'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{r : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><span class=\"fn\">β</span> → <a href=\"./foundational_types.html\">Prop</a></span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(∀ (<span class=\"fn\">a</span> : <span class=\"fn\">α</span>), <span class=\"fn\">∃! <span class=\"fn\">b</span> : <span class=\"fn\">β</span>, <span class=\"fn\"><span class=\"fn\">r</span> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span></span>)</span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">∃ (<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>), <span class=\"fn\"><span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">fun (<span class=\"fn\">x1</span> : <span class=\"fn\">α</span>) (<span class=\"fn\">x2</span> : <span class=\"fn\">β</span>) =&gt; <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">x1</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">x2</span></span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L879-L888","name":"forall_existsUnique_iff","line":879,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#forall_existsUnique_iff","doc":"A relation `r : α → β → Prop` is \"function-like\"\n(for each `a` there exists a unique `b` such that `r a b`)\nif and only if it is `(f · = ·)` for some function `f`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#forall_existsUnique_iff\"><span class=\"name\">forall_existsUnique_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{r : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><span class=\"fn\">β</span> → <a href=\"./foundational_types.html\">Prop</a></span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(∀ (<span class=\"fn\">a</span> : <span class=\"fn\">α</span>), <span class=\"fn\">∃! <span class=\"fn\">b</span> : <span class=\"fn\">β</span>, <span class=\"fn\"><span class=\"fn\">r</span> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span></span>)</span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">∃ (<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>), <span class=\"fn\">∀ {<span class=\"fn\">a</span> : <span class=\"fn\">α</span>} {<span class=\"fn\">b</span> : <span class=\"fn\">β</span>}, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">r</span> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L869-L871","name":"Function.sometimes_spec","line":869,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.sometimes_spec","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.sometimes_spec\"><span class=\"name\">Function</span>.<span class=\"name\">sometimes_spec</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{p : <a href=\"./foundational_types.html\">Prop</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">p</span> → <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">p</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">a</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">(<a href=\"./Mathlib/Logic/Function/Basic.html#Function.sometimes\">Function.sometimes</a> <span class=\"fn\">f</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L866-L867","name":"Function.sometimes_eq","line":866,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.sometimes_eq","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.sometimes_eq\"><span class=\"name\">Function</span>.<span class=\"name\">sometimes_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{p : <a href=\"./foundational_types.html\">Prop</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">p</span> → <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">p</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.sometimes\">Function.sometimes</a> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">a</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L860-L864","name":"Function.sometimes","line":860,"kind":"def","docLink":"./Mathlib/Logic/Function/Basic.html#Function.sometimes","doc":"`sometimes f` evaluates to some value of `f`, if it exists. This function is especially\ninteresting in the case where `α` is a proposition, in which case `f` is necessarily a\nconstant function, so that `sometimes f = f a` for all `a`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.sometimes\"><span class=\"name\">Function</span>.<span class=\"name\">sometimes</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">β</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L851-L852","name":"Function.Injective2.eq_iff","line":851,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Injective2.eq_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Injective2.eq_iff\"><span class=\"name\">Function</span>.<span class=\"name\">Injective2</span>.<span class=\"name\">eq_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">γ</span></span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.Injective2\">Function.Injective2</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{a₁ a₂ : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{b₁ b₂ : <span class=\"fn\">β</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">a₁</span> <span class=\"fn\">b₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">a₂</span> <span class=\"fn\">b₂</span></span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a₂</span></span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\"><span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₂</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L845-L849","name":"Function.Injective2.right'","line":845,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Injective2.right'","doc":"As a map from the right argument to a unary function, `f` is injective. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Injective2.right'\"><span class=\"name\">Function</span>.<span class=\"name\">Injective2</span>.<span class=\"name\">right'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">γ</span></span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.Injective2\">Function.Injective2</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">fun (<span class=\"fn\">b</span> : <span class=\"fn\">β</span>) (<span class=\"fn\">a</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L840-L843","name":"Function.Injective2.left'","line":840,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Injective2.left'","doc":"As a map from the left argument to a unary function, `f` is injective. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Injective2.left'\"><span class=\"name\">Function</span>.<span class=\"name\">Injective2</span>.<span class=\"name\">left'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">γ</span></span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.Injective2\">Function.Injective2</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L836-L838","name":"Function.Injective2.uncurry","line":836,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Injective2.uncurry","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Injective2.uncurry\"><span class=\"name\">Function</span>.<span class=\"name\">Injective2</span>.<span class=\"name\">uncurry</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_4}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> u_5}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Type</a> u_6}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">γ</span></span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.Injective2\">Function.Injective2</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">(<a href=\"./Init/Data/Function.html#Function.uncurry\">Function.uncurry</a> <span class=\"fn\">f</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L832-L834","name":"Function.Injective2.right","line":832,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Injective2.right","doc":"A binary injective function is injective when only the right argument varies. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Injective2.right\"><span class=\"name\">Function</span>.<span class=\"name\">Injective2</span>.<span class=\"name\">right</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">γ</span></span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.Injective2\">Function.Injective2</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">a</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L828-L830","name":"Function.Injective2.left","line":828,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Injective2.left","doc":"A binary injective function is injective when only the left argument varies. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Injective2.left\"><span class=\"name\">Function</span>.<span class=\"name\">Injective2</span>.<span class=\"name\">left</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">γ</span></span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.Injective2\">Function.Injective2</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <span class=\"fn\">β</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">fun (<span class=\"fn\">a</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L818-L822","name":"Function.Injective2","line":818,"kind":"def","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Injective2","doc":"The property of a binary function `f : α → β → γ` being injective.\nMathematically this should be thought of as the corresponding function `α × β → γ` being injective.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Injective2\"><span class=\"name\">Function</span>.<span class=\"name\">Injective2</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">γ</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L814-L816","name":"Function.symmetric_apply_eq_iff","line":814,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.symmetric_apply_eq_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.symmetric_apply_eq_iff\"><span class=\"name\">Function</span>.<span class=\"name\">symmetric_apply_eq_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Order/Defs/Unbundled.html#Symmetric\">Symmetric</a> <span class=\"fn\">fun (<span class=\"fn\">x1</span> <span class=\"fn\">x2</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">x1</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">x2</span></span></span>)</span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.Involutive\">Function.Involutive</a> <span class=\"fn\">f</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L812-L812","name":"Function.not_bijective","line":812,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.not_bijective","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.not_bijective\"><span class=\"name\">Function</span>.<span class=\"name\">not_bijective</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Bijective\">Function.Bijective</a> <a href=\"./Init/Prelude.html#Not\">Not</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L811-L811","name":"Function.not_surjective","line":811,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.not_surjective","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.not_surjective\"><span class=\"name\">Function</span>.<span class=\"name\">not_surjective</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <a href=\"./Init/Prelude.html#Not\">Not</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L810-L810","name":"Function.not_injective","line":810,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.not_injective","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.not_injective\"><span class=\"name\">Function</span>.<span class=\"name\">not_injective</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <a href=\"./Init/Prelude.html#Not\">Not</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L809-L809","name":"Function.not_involutive","line":809,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.not_involutive","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.not_involutive\"><span class=\"name\">Function</span>.<span class=\"name\">not_involutive</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.Involutive\">Function.Involutive</a> <a href=\"./Init/Prelude.html#Not\">Not</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L803-L805","name":"Function.Involutive.eq_iff","line":803,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Involutive.eq_iff","doc":"An involution commutes across an equality. Compare to `Function.Injective.eq_iff`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Involutive.eq_iff\"><span class=\"name\">Function</span>.<span class=\"name\">Involutive</span>.<span class=\"name\">eq_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.Involutive\">Function.Involutive</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{x y : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">y</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L799-L801","name":"Function.Involutive.ite_not","line":799,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Involutive.ite_not","doc":"Involuting an `ite` of an involuted value `x : α` negates the `Prop` condition in the `ite`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Involutive.ite_not\"><span class=\"name\">Function</span>.<span class=\"name\">Involutive</span>.<span class=\"name\">ite_not</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.Involutive\">Function.Involutive</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(P : <a href=\"./foundational_types.html\">Prop</a>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> <span class=\"fn\">P</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">(if <span class=\"fn\">P</span> then <span class=\"fn\">x</span> else <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">x</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">if <span class=\"fn\"><a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">P</span></span> then <span class=\"fn\">x</span> else <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">x</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L797-L797","name":"Function.Involutive.bijective","line":797,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Involutive.bijective","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Involutive.bijective\"><span class=\"name\">Function</span>.<span class=\"name\">Involutive</span>.<span class=\"name\">bijective</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.Involutive\">Function.Involutive</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Bijective\">Function.Bijective</a> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L795-L795","name":"Function.Involutive.surjective","line":795,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Involutive.surjective","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Involutive.surjective\"><span class=\"name\">Function</span>.<span class=\"name\">Involutive</span>.<span class=\"name\">surjective</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.Involutive\">Function.Involutive</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L793-L793","name":"Function.Involutive.injective","line":793,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Involutive.injective","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Involutive.injective\"><span class=\"name\">Function</span>.<span class=\"name\">Involutive</span>.<span class=\"name\">injective</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.Involutive\">Function.Involutive</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L791-L791","name":"Function.Involutive.rightInverse","line":791,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Involutive.rightInverse","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Involutive.rightInverse\"><span class=\"name\">Function</span>.<span class=\"name\">Involutive</span>.<span class=\"name\">rightInverse</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.Involutive\">Function.Involutive</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.RightInverse\">Function.RightInverse</a> <span class=\"fn\">f</span> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L787-L789","name":"Function.Involutive.leftInverse_iff","line":787,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Involutive.leftInverse_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Involutive.leftInverse_iff\"><span class=\"name\">Function</span>.<span class=\"name\">Involutive</span>.<span class=\"name\">leftInverse_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.Involutive\">Function.Involutive</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.LeftInverse\">Function.LeftInverse</a> <span class=\"fn\">g</span> <span class=\"fn\">f</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\">g</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">f</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L785-L785","name":"Function.Involutive.leftInverse","line":785,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Involutive.leftInverse","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Involutive.leftInverse\"><span class=\"name\">Function</span>.<span class=\"name\">Involutive</span>.<span class=\"name\">leftInverse</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.Involutive\">Function.Involutive</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.LeftInverse\">Function.LeftInverse</a> <span class=\"fn\">f</span> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L781-L783","name":"Function.Involutive.comp_self","line":781,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Involutive.comp_self","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Involutive.comp_self\"><span class=\"name\">Function</span>.<span class=\"name\">Involutive</span>.<span class=\"name\">comp_self</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.Involutive\">Function.Involutive</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">id</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L772-L773","name":"Bool.involutive_not","line":772,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Bool.involutive_not","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Bool.involutive_not\"><span class=\"name\">Bool</span>.<span class=\"name\">involutive_not</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.Involutive\">Function.Involutive</a> <a href=\"./Init/Prelude.html#Bool.not\">not</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L768-L770","name":"Function.Involutive","line":768,"kind":"def","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Involutive","doc":"A function is involutive, if `f ∘ f = id`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Involutive\"><span class=\"name\">Function</span>.<span class=\"name\">Involutive</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L763-L764","name":"Function.hasUncurryInduction","line":763,"kind":"instance","docLink":"./Mathlib/Logic/Function/Basic.html#Function.hasUncurryInduction","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.hasUncurryInduction\"><span class=\"name\">Function</span>.<span class=\"name\">hasUncurryInduction</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{δ : <a href=\"./foundational_types.html\">Type</a> u_4}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.HasUncurry\">Function.HasUncurry</a> <span class=\"fn\">β</span> <span class=\"fn\">γ</span> <span class=\"fn\">δ</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.HasUncurry\">Function.HasUncurry</a> <span class=\"fn\">(<span class=\"fn\">α</span> → <span class=\"fn\">β</span>)</span> <span class=\"fn\">(<span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">γ</span>)</span> <span class=\"fn\">δ</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L760-L761","name":"Function.hasUncurryBase","line":760,"kind":"instance","docLink":"./Mathlib/Logic/Function/Basic.html#Function.hasUncurryBase","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.hasUncurryBase\"><span class=\"name\">Function</span>.<span class=\"name\">hasUncurryBase</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.HasUncurry\">Function.HasUncurry</a> <span class=\"fn\">(<span class=\"fn\">α</span> → <span class=\"fn\">β</span>)</span> <span class=\"fn\">α</span> <span class=\"fn\">β</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L758-L758","name":"Function.«term↿_»","line":758,"kind":"def","docLink":"./Mathlib/Logic/Function/Basic.html#Function.«term↿_»","doc":"Uncurrying operator. The most generic use is to recursively uncurry. For instance\n`f : α → β → γ → δ` will be turned into `↿f : α × β × γ → δ`. One can also add instances\nfor bundled maps. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.«term↿_»\"><span class=\"name\">Function</span>.<span class=\"name\">«term↿_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L756-L756","name":"Function.HasUncurry.uncurry","line":756,"kind":"def","docLink":"./Mathlib/Logic/Function/Basic.html#Function.HasUncurry.uncurry","doc":"Uncurrying operator. The most generic use is to recursively uncurry. For instance\n`f : α → β → γ → δ` will be turned into `↿f : α × β × γ → δ`. One can also add instances\nfor bundled maps. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.HasUncurry.uncurry\"><span class=\"name\">Function</span>.<span class=\"name\">HasUncurry</span>.<span class=\"name\">uncurry</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_5}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><a href=\"./Init/Prelude.html#outParam\">outParam</a> <a href=\"./foundational_types.html\">(Type</a> u_6)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <span class=\"fn\"><a href=\"./Init/Prelude.html#outParam\">outParam</a> <a href=\"./foundational_types.html\">(Type</a> u_7)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[self : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.HasUncurry\">Function.HasUncurry</a> <span class=\"fn\">α</span> <span class=\"fn\">β</span> <span class=\"fn\">γ</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">γ</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L752-L752","name":"Function.HasUncurry.mk","line":752,"kind":"ctor","docLink":"./Mathlib/Logic/Function/Basic.html#Function.HasUncurry.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.HasUncurry.mk\"><span class=\"name\">Function</span>.<span class=\"name\">HasUncurry</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_5}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><a href=\"./Init/Prelude.html#outParam\">outParam</a> <a href=\"./foundational_types.html\">(Type</a> u_6)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <span class=\"fn\"><a href=\"./Init/Prelude.html#outParam\">outParam</a> <a href=\"./foundational_types.html\">(Type</a> u_7)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(uncurry : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">γ</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.HasUncurry\">Function.HasUncurry</a> <span class=\"fn\">α</span> <span class=\"fn\">β</span> <span class=\"fn\">γ</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L749-L756","name":"Function.HasUncurry","line":749,"kind":"class","docLink":"./Mathlib/Logic/Function/Basic.html#Function.HasUncurry","doc":"Records a way to turn an element of `α` into a function from `β` to `γ`. The most generic use\nis to recursively uncurry. For instance `f : α → β → γ → δ` will be turned into\n`↿f : α × β × γ → δ`. One can also add instances for bundled maps. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">class</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.HasUncurry\"><span class=\"name\">Function</span>.<span class=\"name\">HasUncurry</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(α : <a href=\"./foundational_types.html\">Type</a> u_5)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(β : <span class=\"fn\"><a href=\"./Init/Prelude.html#outParam\">outParam</a> <a href=\"./foundational_types.html\">(Type</a> u_6)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(γ : <span class=\"fn\"><a href=\"./Init/Prelude.html#outParam\">outParam</a> <a href=\"./foundational_types.html\">(Type</a> u_7)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> (max (max u_5 u_6) u_7)</div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L739-L741","name":"Function.uncurry_bicompl","line":739,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.uncurry_bicompl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.uncurry_bicompl\"><span class=\"name\">Function</span>.<span class=\"name\">uncurry_bicompl</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{δ : <a href=\"./foundational_types.html\">Type</a> u_4}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{ε : <a href=\"./foundational_types.html\">Type</a> u_5}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">γ</span> → <span class=\"fn\"><span class=\"fn\">δ</span> → <span class=\"fn\">ε</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">γ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">δ</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Data/Function.html#Function.uncurry\">Function.uncurry</a> <span class=\"fn\">(<a href=\"./Mathlib/Logic/Function/Basic.html#Function.bicompl\">Function.bicompl</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span> <span class=\"fn\">h</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Data/Function.html#Function.uncurry\">Function.uncurry</a> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\"><a href=\"./Init/Core.html#Prod.map\">Prod.map</a> <span class=\"fn\">g</span> <span class=\"fn\">h</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L736-L737","name":"Function.uncurry_bicompr","line":736,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.uncurry_bicompr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.uncurry_bicompr\"><span class=\"name\">Function</span>.<span class=\"name\">uncurry_bicompr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{δ : <a href=\"./foundational_types.html\">Type</a> u_4}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">γ</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">γ</span> → <span class=\"fn\">δ</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Data/Function.html#Function.uncurry\">Function.uncurry</a> <span class=\"fn\">(<a href=\"./Mathlib/Logic/Function/Basic.html#Function.bicompr\">Function.bicompr</a> <span class=\"fn\">g</span> <span class=\"fn\">f</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">g</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\"><a href=\"./Init/Data/Function.html#Function.uncurry\">Function.uncurry</a> <span class=\"fn\">f</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L729-L731","name":"Function.bicompr","line":729,"kind":"def","docLink":"./Mathlib/Logic/Function/Basic.html#Function.bicompr","doc":"Compose a unary function `f` with a binary function `g`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.bicompr\"><span class=\"name\">Function</span>.<span class=\"name\">bicompr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{δ : <a href=\"./foundational_types.html\">Type</a> u_4}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">γ</span> → <span class=\"fn\">δ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">γ</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <span class=\"fn\">β</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">δ</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L724-L727","name":"Function.bicompl","line":724,"kind":"def","docLink":"./Mathlib/Logic/Function/Basic.html#Function.bicompl","doc":"Compose a binary function `f` with a pair of unary functions `g` and `h`.\nIf both arguments of `f` have the same type and `g = h`, then `bicompl f g g = f on g`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.bicompl\"><span class=\"name\">Function</span>.<span class=\"name\">bicompl</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{δ : <a href=\"./foundational_types.html\">Type</a> u_4}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{ε : <a href=\"./foundational_types.html\">Type</a> u_5}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">γ</span> → <span class=\"fn\"><span class=\"fn\">δ</span> → <span class=\"fn\">ε</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">γ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">δ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <span class=\"fn\">β</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">ε</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L717-L718","name":"Function.uncurry_def","line":717,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.uncurry_def","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.uncurry_def\"><span class=\"name\">Function</span>.<span class=\"name\">uncurry_def</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">γ</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Data/Function.html#Function.uncurry\">Function.uncurry</a> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">fun (<span class=\"fn\">p</span> : <span class=\"fn\"><span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">β</span></span>) =&gt; <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\"><span class=\"fn\">p</span>.fst</span> <span class=\"fn\"><span class=\"fn\">p</span>.snd</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L711-L713","name":"Function.FactorsThrough.comp_right","line":711,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.FactorsThrough.comp_right","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.FactorsThrough.comp_right\"><span class=\"name\">Function</span>.<span class=\"name\">FactorsThrough</span>.<span class=\"name\">comp_right</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{δ : <a href=\"./foundational_types.html\">Sort</a> u_4}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">γ</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.FactorsThrough\">Function.FactorsThrough</a> <span class=\"fn\">g</span> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g' : <span class=\"fn\"><span class=\"fn\">δ</span> → <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.FactorsThrough\">Function.FactorsThrough</a> <span class=\"fn\">(<span class=\"fn\">g</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">g'</span>)</span> <span class=\"fn\">(<span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">g'</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L707-L709","name":"Function.FactorsThrough.comp_left","line":707,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.FactorsThrough.comp_left","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.FactorsThrough.comp_left\"><span class=\"name\">Function</span>.<span class=\"name\">FactorsThrough</span>.<span class=\"name\">comp_left</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{δ : <a href=\"./foundational_types.html\">Sort</a> u_4}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">γ</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.FactorsThrough\">Function.FactorsThrough</a> <span class=\"fn\">g</span> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g' : <span class=\"fn\"><span class=\"fn\">γ</span> → <span class=\"fn\">δ</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.FactorsThrough\">Function.FactorsThrough</a> <span class=\"fn\">(<span class=\"fn\">g'</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">g</span>)</span> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L705-L705","name":"Function.FactorsThrough.rfl","line":705,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.FactorsThrough.rfl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.FactorsThrough.rfl\"><span class=\"name\">Function</span>.<span class=\"name\">FactorsThrough</span>.<span class=\"name\">rfl</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.FactorsThrough\">Function.FactorsThrough</a> <span class=\"fn\">f</span> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L696-L699","name":"Function.Bijective.comp_right","line":696,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Bijective.comp_right","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Bijective.comp_right\"><span class=\"name\">Function</span>.<span class=\"name\">Bijective</span>.<span class=\"name\">comp_right</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Bijective\">Function.Bijective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Bijective\">Function.Bijective</a> <span class=\"fn\">fun (<span class=\"fn\">g</span> : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">γ</span></span>) =&gt; <span class=\"fn\"><span class=\"fn\">g</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">f</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L692-L694","name":"Function.Injective.surjective_comp_right","line":692,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Injective.surjective_comp_right","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Injective.surjective_comp_right\"><span class=\"name\">Function</span>.<span class=\"name\">Injective</span>.<span class=\"name\">surjective_comp_right</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">γ</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">fun (<span class=\"fn\">g</span> : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">γ</span></span>) =&gt; <span class=\"fn\"><span class=\"fn\">g</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">f</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L688-L690","name":"Function.Injective.surjective_comp_right'","line":688,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Injective.surjective_comp_right'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Injective.surjective_comp_right'\"><span class=\"name\">Function</span>.<span class=\"name\">Injective</span>.<span class=\"name\">surjective_comp_right'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g₀ : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">γ</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">fun (<span class=\"fn\">g</span> : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">γ</span></span>) =&gt; <span class=\"fn\"><span class=\"fn\">g</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">f</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L684-L686","name":"Function.extend_comp","line":684,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.extend_comp","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.extend_comp\"><span class=\"name\">Function</span>.<span class=\"name\">extend_comp</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">γ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e' : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">γ</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.extend\">Function.extend</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span> <span class=\"fn\">e'</span></span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">g</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L680-L682","name":"Function.extend_const","line":680,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.extend_const","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.extend_const\"><span class=\"name\">Function</span>.<span class=\"name\">extend_const</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(c : <span class=\"fn\">γ</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Logic/Function/Basic.html#Function.extend\">Function.extend</a> <span class=\"fn\">f</span> <span class=\"fn\">(fun (<span class=\"fn\">x</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\">c</span>)</span> <span class=\"fn\">fun (<span class=\"fn\">x</span> : <span class=\"fn\">β</span>) =&gt; <span class=\"fn\">c</span></span>)</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> : <span class=\"fn\">β</span>) =&gt; <span class=\"fn\">c</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L676-L678","name":"Function.FactorsThrough.extend_comp","line":676,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.FactorsThrough.extend_comp","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.FactorsThrough.extend_comp\"><span class=\"name\">Function</span>.<span class=\"name\">FactorsThrough</span>.<span class=\"name\">extend_comp</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">γ</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(e' : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">γ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.FactorsThrough\">Function.FactorsThrough</a> <span class=\"fn\">g</span> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.extend\">Function.extend</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span> <span class=\"fn\">e'</span></span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">g</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L669-L674","name":"Function.extend_injective","line":669,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.extend_injective","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.extend_injective\"><span class=\"name\">Function</span>.<span class=\"name\">extend_injective</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e' : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">γ</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">fun (<span class=\"fn\">g</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">γ</span></span>) =&gt; <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.extend\">Function.extend</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span> <span class=\"fn\">e'</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L665-L667","name":"Function.apply_extend","line":665,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.apply_extend","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.apply_extend\"><span class=\"name\">Function</span>.<span class=\"name\">apply_extend</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{δ : <a href=\"./foundational_types.html\">Sort</a> u_4}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">γ</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><span class=\"fn\">γ</span> → <span class=\"fn\">δ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e' : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">γ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <span class=\"fn\">β</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span> <span class=\"fn\">(<a href=\"./Mathlib/Logic/Function/Basic.html#Function.extend\">Function.extend</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span> <span class=\"fn\">e'</span> <span class=\"fn\">b</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.extend\">Function.extend</a> <span class=\"fn\">f</span> <span class=\"fn\">(<span class=\"fn\">F</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">g</span>)</span> <span class=\"fn\">(<span class=\"fn\">F</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">e'</span>)</span> <span class=\"fn\">b</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L660-L663","name":"Function.factorsThrough_iff","line":660,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.factorsThrough_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.factorsThrough_iff\"><span class=\"name\">Function</span>.<span class=\"name\">factorsThrough_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">γ</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">γ</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.FactorsThrough\">Function.FactorsThrough</a> <span class=\"fn\">g</span> <span class=\"fn\">f</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">∃ (<span class=\"fn\">e</span> : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">γ</span></span>), <span class=\"fn\"><span class=\"fn\">g</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">e</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">f</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L655-L658","name":"Function.extend_apply'","line":655,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.extend_apply'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.extend_apply'\"><span class=\"name\">Function</span>.<span class=\"name\">extend_apply'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">γ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e' : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">γ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <span class=\"fn\">β</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hb : <span class=\"fn\"><a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">∃ (<span class=\"fn\">a</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.extend\">Function.extend</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span> <span class=\"fn\">e'</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">e'</span> <span class=\"fn\">b</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L650-L653","name":"Function.Injective.extend_apply","line":650,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Injective.extend_apply","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Injective.extend_apply\"><span class=\"name\">Function</span>.<span class=\"name\">Injective</span>.<span class=\"name\">extend_apply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">γ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e' : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">γ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.extend\">Function.extend</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span> <span class=\"fn\">e'</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">a</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">g</span> <span class=\"fn\">a</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L645-L648","name":"Function.FactorsThrough.extend_apply","line":645,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.FactorsThrough.extend_apply","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.FactorsThrough.extend_apply\"><span class=\"name\">Function</span>.<span class=\"name\">FactorsThrough</span>.<span class=\"name\">extend_apply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">γ</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.FactorsThrough\">Function.FactorsThrough</a> <span class=\"fn\">g</span> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e' : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">γ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.extend\">Function.extend</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span> <span class=\"fn\">e'</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">a</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">g</span> <span class=\"fn\">a</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L642-L643","name":"Function.Injective.factorsThrough","line":642,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Injective.factorsThrough","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Injective.factorsThrough\"><span class=\"name\">Function</span>.<span class=\"name\">Injective</span>.<span class=\"name\">factorsThrough</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">γ</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.FactorsThrough\">Function.FactorsThrough</a> <span class=\"fn\">g</span> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L637-L640","name":"Function.extend_def","line":637,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.extend_def","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.extend_def\"><span class=\"name\">Function</span>.<span class=\"name\">extend_def</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">γ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e' : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">γ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <span class=\"fn\">β</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> <span class=\"fn\">(∃ (<span class=\"fn\">a</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span>)</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.extend\">Function.extend</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span> <span class=\"fn\">e'</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">if h : <span class=\"fn\">∃ (<span class=\"fn\">a</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span> then <span class=\"fn\"><span class=\"fn\">g</span> <span class=\"fn\">(<a href=\"./Init/Classical.html#Classical.choose\">Classical.choose</a> <span class=\"fn\">h</span>)</span></span> else <span class=\"fn\"><span class=\"fn\">e'</span> <span class=\"fn\">b</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L633-L635","name":"Function.FactorsThrough","line":633,"kind":"def","docLink":"./Mathlib/Logic/Function/Basic.html#Function.FactorsThrough","doc":"g factors through f : `f a = f b → g a = g b` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.FactorsThrough\"><span class=\"name\">Function</span>.<span class=\"name\">FactorsThrough</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">γ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L618-L631","name":"Function.extend","line":618,"kind":"def","docLink":"./Mathlib/Logic/Function/Basic.html#Function.extend","doc":"Extension of a function `g : α → γ` along a function `f : α → β`.\n\nFor every `a : α`, `f a` is sent to `g a`. `f` might not be surjective, so we use an auxiliary\nfunction `j : β → γ` by sending `b : β` not in the range of `f` to `j b`. If you do not care about\nthe behavior outside the range, `j` can be used as a junk value by setting it to be `0` or\n`Classical.arbitrary` (assuming `γ` is nonempty).\n\nThis definition is mathematically meaningful only when `f a₁ = f a₂ → g a₁ = g a₂` (spelled\n`g.FactorsThrough f`). In particular this holds if `f` is injective.\n\nA typical use case is extending a function from a subtype to the entire type. If you wish to extend\n`g : {b : β // p b} → γ` to a function `β → γ`, you should use `Function.extend Subtype.val g j`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.extend\"><span class=\"name\">Function</span>.<span class=\"name\">extend</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">γ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">γ</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">γ</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L604-L608","name":"Function.update_idem","line":604,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.update_idem","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.update_idem\"><span class=\"name\">Function</span>.<span class=\"name\">update_idem</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Sort</a> u_1</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{a : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(v w : <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.update\">Function.update</a> <span class=\"fn\">(<a href=\"./Mathlib/Logic/Function/Basic.html#Function.update\">Function.update</a> <span class=\"fn\">f</span> <span class=\"fn\">a</span> <span class=\"fn\">v</span>)</span> <span class=\"fn\">a</span> <span class=\"fn\">w</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.update\">Function.update</a> <span class=\"fn\">f</span> <span class=\"fn\">a</span> <span class=\"fn\">w</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L593-L602","name":"Function.update_comm","line":593,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.update_comm","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.update_comm\"><span class=\"name\">Function</span>.<span class=\"name\">update_comm</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Sort</a> u_1</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{a b : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(v : <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.update\">Function.update</a> <span class=\"fn\">(<a href=\"./Mathlib/Logic/Function/Basic.html#Function.update\">Function.update</a> <span class=\"fn\">f</span> <span class=\"fn\">a</span> <span class=\"fn\">v</span>)</span> <span class=\"fn\">b</span> <span class=\"fn\">w</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.update\">Function.update</a> <span class=\"fn\">(<a href=\"./Mathlib/Logic/Function/Basic.html#Function.update\">Function.update</a> <span class=\"fn\">f</span> <span class=\"fn\">b</span> <span class=\"fn\">w</span>)</span> <span class=\"fn\">a</span> <span class=\"fn\">v</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L589-L591","name":"Function.comp_update","line":589,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.comp_update","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.comp_update\"><span class=\"name\">Function</span>.<span class=\"name\">comp_update</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α' : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α'</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(v : <span class=\"fn\">α'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.update\">Function.update</a> <span class=\"fn\">g</span> <span class=\"fn\">i</span> <span class=\"fn\">v</span></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.update\">Function.update</a> <span class=\"fn\">(<span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">g</span>)</span> <span class=\"fn\">i</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">v</span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L585-L587","name":"Function.pred_update","line":585,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.pred_update","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.pred_update\"><span class=\"name\">Function</span>.<span class=\"name\">pred_update</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Sort</a> v</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\">⦃<span class=\"fn\">a</span> : <span class=\"fn\">α</span>⦄ → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a</span></span> → <a href=\"./foundational_types.html\">Prop</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a' : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(v : <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">(<a href=\"./Mathlib/Logic/Function/Basic.html#Function.update\">Function.update</a> <span class=\"fn\">f</span> <span class=\"fn\">a'</span> <span class=\"fn\">v</span> <span class=\"fn\">a</span>)</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span></span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">v</span></span></span> <a href=\"./Init/Prelude.html#Or\">∨</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\">a'</span></span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">a</span>)</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L577-L583","name":"Function.apply_update₂","line":577,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.apply_update₂","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.apply_update₂\"><span class=\"name\">Function</span>.<span class=\"name\">apply_update₂</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{ι : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">ι</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <span class=\"fn\"><span class=\"fn\">ι</span> → <a href=\"./foundational_types.html\">Sort</a> u_2</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">ι</span> → <a href=\"./foundational_types.html\">Sort</a> u_3</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <span class=\"fn\"><span class=\"fn\">ι</span> → <a href=\"./foundational_types.html\">Sort</a> u_4</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\">ι</span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">α</span> <span class=\"fn\">i</span></span> → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">i</span></span> → <span class=\"fn\"><span class=\"fn\">γ</span> <span class=\"fn\">i</span></span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\">ι</span>) → <span class=\"fn\"><span class=\"fn\">α</span> <span class=\"fn\">i</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\">ι</span>) → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">i</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\">ι</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(v : <span class=\"fn\"><span class=\"fn\">α</span> <span class=\"fn\">i</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">i</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\">ι</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j</span> <span class=\"fn\">(<a href=\"./Mathlib/Logic/Function/Basic.html#Function.update\">Function.update</a> <span class=\"fn\">g</span> <span class=\"fn\">i</span> <span class=\"fn\">v</span> <span class=\"fn\">j</span>)</span> <span class=\"fn\">(<a href=\"./Mathlib/Logic/Function/Basic.html#Function.update\">Function.update</a> <span class=\"fn\">h</span> <span class=\"fn\">i</span> <span class=\"fn\">w</span> <span class=\"fn\">j</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.update\">Function.update</a> <span class=\"fn\">(fun (<span class=\"fn\">k</span> : <span class=\"fn\">ι</span>) =&gt; <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\">g</span> <span class=\"fn\">k</span>)</span> <span class=\"fn\">(<span class=\"fn\">h</span> <span class=\"fn\">k</span>)</span></span>)</span> <span class=\"fn\">i</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">i</span> <span class=\"fn\">v</span> <span class=\"fn\">w</span>)</span> <span class=\"fn\">j</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L569-L575","name":"Function.apply_update","line":569,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.apply_update","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.apply_update\"><span class=\"name\">Function</span>.<span class=\"name\">apply_update</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{ι : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">ι</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <span class=\"fn\"><span class=\"fn\">ι</span> → <a href=\"./foundational_types.html\">Sort</a> u_2</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">ι</span> → <a href=\"./foundational_types.html\">Sort</a> u_3</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\">ι</span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">α</span> <span class=\"fn\">i</span></span> → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">i</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\">ι</span>) → <span class=\"fn\"><span class=\"fn\">α</span> <span class=\"fn\">i</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\">ι</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(v : <span class=\"fn\"><span class=\"fn\">α</span> <span class=\"fn\">i</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\">ι</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">j</span> <span class=\"fn\">(<a href=\"./Mathlib/Logic/Function/Basic.html#Function.update\">Function.update</a> <span class=\"fn\">g</span> <span class=\"fn\">i</span> <span class=\"fn\">v</span> <span class=\"fn\">j</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.update\">Function.update</a> <span class=\"fn\">(fun (<span class=\"fn\">k</span> : <span class=\"fn\">ι</span>) =&gt; <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">k</span> <span class=\"fn\">(<span class=\"fn\">g</span> <span class=\"fn\">k</span>)</span></span>)</span> <span class=\"fn\">i</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">i</span> <span class=\"fn\">v</span>)</span> <span class=\"fn\">j</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L563-L567","name":"Function.update_comp_eq_of_injective","line":563,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.update_comp_eq_of_injective","doc":"Non-dependent version of `Function.update_comp_eq_of_injective'` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.update_comp_eq_of_injective\"><span class=\"name\">Function</span>.<span class=\"name\">update_comp_eq_of_injective</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α' : <a href=\"./foundational_types.html\">Sort</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">α'</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">α'</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α'</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">β</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.update\">Function.update</a> <span class=\"fn\">g</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">i</span>)</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.update\">Function.update</a> <span class=\"fn\">(<span class=\"fn\">g</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">f</span>)</span> <span class=\"fn\">i</span> <span class=\"fn\">a</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L559-L561","name":"Function.update_comp_eq_of_injective'","line":559,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.update_comp_eq_of_injective'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.update_comp_eq_of_injective'\"><span class=\"name\">Function</span>.<span class=\"name\">update_comp_eq_of_injective'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Sort</a> v</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α' : <a href=\"./foundational_types.html\">Sort</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">α'</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a</span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α'</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\">α'</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">i</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(fun (<span class=\"fn\">j</span> : <span class=\"fn\">α'</span>) =&gt; <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.update\">Function.update</a> <span class=\"fn\">g</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">i</span>)</span> <span class=\"fn\">a</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">j</span>)</span></span>)</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.update\">Function.update</a> <span class=\"fn\">(fun (<span class=\"fn\">i</span> : <span class=\"fn\">α'</span>) =&gt; <span class=\"fn\"><span class=\"fn\">g</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">i</span>)</span></span>)</span> <span class=\"fn\">i</span> <span class=\"fn\">a</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L554-L557","name":"Function.update_comp_eq_of_forall_ne","line":554,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.update_comp_eq_of_forall_ne","doc":"Non-dependent version of `Function.update_comp_eq_of_forall_ne'` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.update_comp_eq_of_forall_ne\"><span class=\"name\">Function</span>.<span class=\"name\">update_comp_eq_of_forall_ne</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α' : <a href=\"./foundational_types.html\">Sort</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">α'</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">α'</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α'</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{i : <span class=\"fn\">α'</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">β</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">x</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\">i</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.update\">Function.update</a> <span class=\"fn\">g</span> <span class=\"fn\">i</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">g</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">f</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L548-L550","name":"Function.update_comp_eq_of_forall_ne'","line":548,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.update_comp_eq_of_forall_ne'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.update_comp_eq_of_forall_ne'\"><span class=\"name\">Function</span>.<span class=\"name\">update_comp_eq_of_forall_ne'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Sort</a> v</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α' : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a</span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α'</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{i : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">i</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">x</span> : <span class=\"fn\">α'</span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\">i</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(fun (<span class=\"fn\">j</span> : <span class=\"fn\">α'</span>) =&gt; <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.update\">Function.update</a> <span class=\"fn\">g</span> <span class=\"fn\">i</span> <span class=\"fn\">a</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">j</span>)</span></span>)</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">fun (<span class=\"fn\">j</span> : <span class=\"fn\">α'</span>) =&gt; <span class=\"fn\"><span class=\"fn\">g</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">j</span>)</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L544-L546","name":"Function.update_eq_self","line":544,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.update_eq_self","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.update_eq_self\"><span class=\"name\">Function</span>.<span class=\"name\">update_eq_self</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Sort</a> v</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.update\">Function.update</a> <span class=\"fn\">f</span> <span class=\"fn\">a</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">a</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L542-L542","name":"Function.update_ne_self_iff","line":542,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.update_ne_self_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.update_ne_self_iff\"><span class=\"name\">Function</span>.<span class=\"name\">update_ne_self_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Sort</a> v</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a</span></span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{a : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{b : <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.update\">Function.update</a> <span class=\"fn\">f</span> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\">f</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">a</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L540-L540","name":"Function.ne_update_self_iff","line":540,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.ne_update_self_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.ne_update_self_iff\"><span class=\"name\">Function</span>.<span class=\"name\">ne_update_self_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Sort</a> v</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a</span></span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{a : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{b : <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.update\">Function.update</a> <span class=\"fn\">f</span> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\">b</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L538-L538","name":"Function.eq_update_self_iff","line":538,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.eq_update_self_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.eq_update_self_iff\"><span class=\"name\">Function</span>.<span class=\"name\">eq_update_self_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Sort</a> v</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a</span></span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{a : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{b : <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.update\">Function.update</a> <span class=\"fn\">f</span> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L536-L536","name":"Function.update_eq_self_iff","line":536,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.update_eq_self_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.update_eq_self_iff\"><span class=\"name\">Function</span>.<span class=\"name\">update_eq_self_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Sort</a> v</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a</span></span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{a : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{b : <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.update\">Function.update</a> <span class=\"fn\">f</span> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">f</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">a</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L532-L534","name":"Function.eq_update_iff","line":532,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.eq_update_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.eq_update_iff\"><span class=\"name\">Function</span>.<span class=\"name\">eq_update_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Sort</a> v</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{a : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{b : <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f g : <span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a</span></span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">g</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.update\">Function.update</a> <span class=\"fn\">f</span> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">g</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\">∀ (<span class=\"fn\">x</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\">a</span></span> → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">g</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">x</span></span></span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L528-L530","name":"Function.update_eq_iff","line":528,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.update_eq_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.update_eq_iff\"><span class=\"name\">Function</span>.<span class=\"name\">update_eq_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Sort</a> v</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{a : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{b : <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f g : <span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a</span></span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.update\">Function.update</a> <span class=\"fn\">f</span> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">g</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">g</span> <span class=\"fn\">a</span></span></span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\">∀ (<span class=\"fn\">x</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\">a</span></span> → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">g</span> <span class=\"fn\">x</span></span></span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L523-L526","name":"Function.exists_update_iff","line":523,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.exists_update_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.exists_update_iff\"><span class=\"name\">Function</span>.<span class=\"name\">exists_update_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Sort</a> v</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a</span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{a : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{b : <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(p : <span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a</span></span> → <a href=\"./foundational_types.html\">Prop</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(∃ (<span class=\"fn\">x</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">p</span> <span class=\"fn\">x</span> <span class=\"fn\">(<a href=\"./Mathlib/Logic/Function/Basic.html#Function.update\">Function.update</a> <span class=\"fn\">f</span> <span class=\"fn\">a</span> <span class=\"fn\">b</span> <span class=\"fn\">x</span>)</span></span>)</span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">p</span> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Or\">∨</a> <span class=\"fn\">∃ (<span class=\"fn\">x</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\"><span class=\"fn\">p</span> <span class=\"fn\">x</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">x</span>)</span></span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L518-L521","name":"Function.forall_update_iff","line":518,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.forall_update_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.forall_update_iff\"><span class=\"name\">Function</span>.<span class=\"name\">forall_update_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Sort</a> v</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a</span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{a : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{b : <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(p : <span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a</span></span> → <a href=\"./foundational_types.html\">Prop</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(∀ (<span class=\"fn\">x</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">p</span> <span class=\"fn\">x</span> <span class=\"fn\">(<a href=\"./Mathlib/Logic/Function/Basic.html#Function.update\">Function.update</a> <span class=\"fn\">f</span> <span class=\"fn\">a</span> <span class=\"fn\">b</span> <span class=\"fn\">x</span>)</span></span>)</span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">p</span> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\">∀ (<span class=\"fn\">x</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\">a</span></span> → <span class=\"fn\"><span class=\"fn\">p</span> <span class=\"fn\">x</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">x</span>)</span></span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L514-L516","name":"Function.update_injective","line":514,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.update_injective","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.update_injective\"><span class=\"name\">Function</span>.<span class=\"name\">update_injective</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Sort</a> v</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a' : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">(<a href=\"./Mathlib/Logic/Function/Basic.html#Function.update\">Function.update</a> <span class=\"fn\">f</span> <span class=\"fn\">a'</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L509-L512","name":"Function.surjective_eval","line":509,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.surjective_eval","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.surjective_eval\"><span class=\"name\">Function</span>.<span class=\"name\">surjective_eval</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Sort</a> v</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[h : <span class=\"fn\">∀ (<span class=\"fn\">a</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">(<span class=\"fn\">β</span> <span class=\"fn\">a</span>)</span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">(<a href=\"./Mathlib/Logic/Function/Basic.html#Function.eval\">Function.eval</a> <span class=\"fn\">a</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L504-L507","name":"Function.update_eq_const_of_subsingleton","line":504,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.update_eq_const_of_subsingleton","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.update_eq_const_of_subsingleton\"><span class=\"name\">Function</span>.<span class=\"name\">update_eq_const_of_subsingleton</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α' : <a href=\"./foundational_types.html\">Sort</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Core.html#Subsingleton\">Subsingleton</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(v : <span class=\"fn\">α'</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α'</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.update\">Function.update</a> <span class=\"fn\">f</span> <span class=\"fn\">a</span> <span class=\"fn\">v</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Function.const\">Function.const</a> <span class=\"fn\">α</span> <span class=\"fn\">v</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L499-L502","name":"Function.update_apply","line":499,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.update_apply","doc":"On non-dependent functions, `Function.update` can be expressed as an `ite` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.update_apply\"><span class=\"name\">Function</span>.<span class=\"name\">update_apply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a' : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <span class=\"fn\">β</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.update\">Function.update</a> <span class=\"fn\">f</span> <span class=\"fn\">a'</span> <span class=\"fn\">b</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">if <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span></span> then <span class=\"fn\">b</span> else <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">a</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L495-L497","name":"Function.update_noteq","line":495,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.update_noteq","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.update_noteq\"><span class=\"name\">Function</span>.<span class=\"name\">update_noteq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Sort</a> v</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{a a' : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\">a'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(v : <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.update\">Function.update</a> <span class=\"fn\">f</span> <span class=\"fn\">a'</span> <span class=\"fn\">v</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">a</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L491-L493","name":"Function.update_same","line":491,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.update_same","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.update_same\"><span class=\"name\">Function</span>.<span class=\"name\">update_same</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Sort</a> v</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(v : <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.update\">Function.update</a> <span class=\"fn\">f</span> <span class=\"fn\">a</span> <span class=\"fn\">v</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">v</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L487-L489","name":"Function.update","line":487,"kind":"def","docLink":"./Mathlib/Logic/Function/Basic.html#Function.update","doc":"Replacing the value of a function at a given point by a given value. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.update\"><span class=\"name\">Function</span>.<span class=\"name\">update</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Sort</a> v</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a' : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(v : <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L474-L477","name":"Function.Bijective.comp_left","line":474,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Bijective.comp_left","doc":"Composition by a bijective function on the left is itself bijective. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Bijective.comp_left\"><span class=\"name\">Function</span>.<span class=\"name\">Bijective</span>.<span class=\"name\">comp_left</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> v}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">γ</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hg : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Bijective\">Function.Bijective</a> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Bijective\">Function.Bijective</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>) =&gt; <span class=\"fn\"><span class=\"fn\">g</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">x</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L472-L472","name":"Function.bijective_pi_map","line":472,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.bijective_pi_map","doc":"**Alias** of `Function.Bijective.piMap`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.bijective_pi_map\"><span class=\"name\">Function</span>.<span class=\"name\">bijective_pi_map</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{ι : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <span class=\"fn\"><span class=\"fn\">ι</span> → <a href=\"./foundational_types.html\">Sort</a> u_2</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">ι</span> → <a href=\"./foundational_types.html\">Sort</a> u_3</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\">ι</span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">α</span> <span class=\"fn\">i</span></span> → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">i</span></span></span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\">∀ (<span class=\"fn\">i</span> : <span class=\"fn\">ι</span>), <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Bijective\">Function.Bijective</a> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">i</span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Bijective\">Function.Bijective</a> <span class=\"fn\">(<a href=\"./Mathlib/Logic/Function/Defs.html#Pi.map\">Pi.map</a> <span class=\"fn\">f</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L468-L470","name":"Function.Bijective.piMap","line":468,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Bijective.piMap","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Bijective.piMap\"><span class=\"name\">Function</span>.<span class=\"name\">Bijective</span>.<span class=\"name\">piMap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{ι : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <span class=\"fn\"><span class=\"fn\">ι</span> → <a href=\"./foundational_types.html\">Sort</a> u_2</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">ι</span> → <a href=\"./foundational_types.html\">Sort</a> u_3</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\">ι</span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">α</span> <span class=\"fn\">i</span></span> → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">i</span></span></span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\">∀ (<span class=\"fn\">i</span> : <span class=\"fn\">ι</span>), <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Bijective\">Function.Bijective</a> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">i</span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Bijective\">Function.Bijective</a> <span class=\"fn\">(<a href=\"./Mathlib/Logic/Function/Defs.html#Pi.map\">Pi.map</a> <span class=\"fn\">f</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L463-L466","name":"Function.Surjective.comp_left","line":463,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Surjective.comp_left","doc":"Composition by a surjective function on the left is itself surjective. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Surjective.comp_left\"><span class=\"name\">Function</span>.<span class=\"name\">Surjective</span>.<span class=\"name\">comp_left</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> v}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">γ</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hg : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>) =&gt; <span class=\"fn\"><span class=\"fn\">g</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">x</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L461-L461","name":"Function.surjective_pi_map","line":461,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.surjective_pi_map","doc":"**Alias** of `Function.Surjective.piMap`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.surjective_pi_map\"><span class=\"name\">Function</span>.<span class=\"name\">surjective_pi_map</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{ι : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <span class=\"fn\"><span class=\"fn\">ι</span> → <a href=\"./foundational_types.html\">Sort</a> u_2</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">ι</span> → <a href=\"./foundational_types.html\">Sort</a> u_3</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\">ι</span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">α</span> <span class=\"fn\">i</span></span> → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">i</span></span></span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\">∀ (<span class=\"fn\">i</span> : <span class=\"fn\">ι</span>), <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">i</span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">(<a href=\"./Mathlib/Logic/Function/Defs.html#Pi.map\">Pi.map</a> <span class=\"fn\">f</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L457-L459","name":"Function.Surjective.piMap","line":457,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Surjective.piMap","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Surjective.piMap\"><span class=\"name\">Function</span>.<span class=\"name\">Surjective</span>.<span class=\"name\">piMap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{ι : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <span class=\"fn\"><span class=\"fn\">ι</span> → <a href=\"./foundational_types.html\">Sort</a> u_2</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">ι</span> → <a href=\"./foundational_types.html\">Sort</a> u_3</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\">ι</span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">α</span> <span class=\"fn\">i</span></span> → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">i</span></span></span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\">∀ (<span class=\"fn\">i</span> : <span class=\"fn\">ι</span>), <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">i</span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">(<a href=\"./Mathlib/Logic/Function/Defs.html#Pi.map\">Pi.map</a> <span class=\"fn\">f</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L453-L455","name":"Function.surjective_to_subsingleton","line":453,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.surjective_to_subsingleton","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.surjective_to_subsingleton\"><span class=\"name\">Function</span>.<span class=\"name\">surjective_to_subsingleton</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> v}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[na : <span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Core.html#Subsingleton\">Subsingleton</a> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L450-L451","name":"Function.injective_surjInv","line":450,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.injective_surjInv","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.injective_surjInv\"><span class=\"name\">Function</span>.<span class=\"name\">injective_surjInv</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> v}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">(<a href=\"./Mathlib/Logic/Function/Basic.html#Function.surjInv\">Function.surjInv</a> <span class=\"fn\">h</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L446-L448","name":"Function.bijective_iff_has_inverse","line":446,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.bijective_iff_has_inverse","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.bijective_iff_has_inverse\"><span class=\"name\">Function</span>.<span class=\"name\">bijective_iff_has_inverse</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> v}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Bijective\">Function.Bijective</a> <span class=\"fn\">f</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">∃ (<span class=\"fn\">g</span> : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">α</span></span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.LeftInverse\">Function.LeftInverse</a> <span class=\"fn\">g</span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.RightInverse\">Function.RightInverse</a> <span class=\"fn\">g</span> <span class=\"fn\">f</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L443-L444","name":"Function.surjective_iff_hasRightInverse","line":443,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.surjective_iff_hasRightInverse","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.surjective_iff_hasRightInverse\"><span class=\"name\">Function</span>.<span class=\"name\">surjective_iff_hasRightInverse</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> v}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">f</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.HasRightInverse\">Function.HasRightInverse</a> <span class=\"fn\">f</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L440-L441","name":"Function.Surjective.hasRightInverse","line":440,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Surjective.hasRightInverse","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Surjective.hasRightInverse\"><span class=\"name\">Function</span>.<span class=\"name\">Surjective</span>.<span class=\"name\">hasRightInverse</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> v}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.HasRightInverse\">Function.HasRightInverse</a> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L437-L438","name":"Function.leftInverse_surjInv","line":437,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.leftInverse_surjInv","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.leftInverse_surjInv\"><span class=\"name\">Function</span>.<span class=\"name\">leftInverse_surjInv</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> v}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Bijective\">Function.Bijective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.LeftInverse\">Function.LeftInverse</a> <span class=\"fn\">(<a href=\"./Mathlib/Logic/Function/Basic.html#Function.surjInv\">Function.surjInv</a> <span class=\"fn\">⋯</span>)</span> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L434-L435","name":"Function.rightInverse_surjInv","line":434,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.rightInverse_surjInv","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.rightInverse_surjInv\"><span class=\"name\">Function</span>.<span class=\"name\">rightInverse_surjInv</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> v}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.RightInverse\">Function.RightInverse</a> <span class=\"fn\">(<a href=\"./Mathlib/Logic/Function/Basic.html#Function.surjInv\">Function.surjInv</a> <span class=\"fn\">hf</span>)</span> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L431-L432","name":"Function.surjInv_eq","line":431,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.surjInv_eq","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.surjInv_eq\"><span class=\"name\">Function</span>.<span class=\"name\">surjInv_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> v}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <span class=\"fn\">β</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">(<a href=\"./Mathlib/Logic/Function/Basic.html#Function.surjInv\">Function.surjInv</a> <span class=\"fn\">h</span> <span class=\"fn\">b</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L426-L429","name":"Function.surjInv","line":426,"kind":"def","docLink":"./Mathlib/Logic/Function/Basic.html#Function.surjInv","doc":"The inverse of a surjective function. (Unlike `invFun`, this does not require\n`α` to be inhabited.) "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.surjInv\"><span class=\"name\">Function</span>.<span class=\"name\">surjInv</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> v}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <span class=\"fn\">β</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">α</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L417-L418","name":"Function.injective_iff_hasLeftInverse","line":417,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.injective_iff_hasLeftInverse","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.injective_iff_hasLeftInverse\"><span class=\"name\">Function</span>.<span class=\"name\">injective_iff_hasLeftInverse</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.HasLeftInverse\">Function.HasLeftInverse</a> <span class=\"fn\">f</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L414-L415","name":"Function.Injective.hasLeftInverse","line":414,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Injective.hasLeftInverse","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Injective.hasLeftInverse\"><span class=\"name\">Function</span>.<span class=\"name\">Injective</span>.<span class=\"name\">hasLeftInverse</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.HasLeftInverse\">Function.HasLeftInverse</a> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L411-L412","name":"Function.invFun_comp","line":411,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.invFun_comp","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.invFun_comp\"><span class=\"name\">Function</span>.<span class=\"name\">invFun_comp</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.invFun\">Function.invFun</a> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">id</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L408-L409","name":"Function.invFun_surjective","line":408,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.invFun_surjective","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.invFun_surjective\"><span class=\"name\">Function</span>.<span class=\"name\">invFun_surjective</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">(<a href=\"./Mathlib/Logic/Function/Basic.html#Function.invFun\">Function.invFun</a> <span class=\"fn\">f</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L405-L406","name":"Function.leftInverse_invFun","line":405,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.leftInverse_invFun","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.leftInverse_invFun\"><span class=\"name\">Function</span>.<span class=\"name\">leftInverse_invFun</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.LeftInverse\">Function.LeftInverse</a> <span class=\"fn\">(<a href=\"./Mathlib/Logic/Function/Basic.html#Function.invFun\">Function.invFun</a> <span class=\"fn\">f</span>)</span> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L402-L403","name":"Function.rightInverse_invFun","line":402,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.rightInverse_invFun","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.rightInverse_invFun\"><span class=\"name\">Function</span>.<span class=\"name\">rightInverse_invFun</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.RightInverse\">Function.RightInverse</a> <span class=\"fn\">(<a href=\"./Mathlib/Logic/Function/Basic.html#Function.invFun\">Function.invFun</a> <span class=\"fn\">f</span>)</span> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L394-L400","name":"Function.invFun_eq_of_injective_of_rightInverse","line":394,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.invFun_eq_of_injective_of_rightInverse","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.invFun_eq_of_injective_of_rightInverse\"><span class=\"name\">Function</span>.<span class=\"name\">invFun_eq_of_injective_of_rightInverse</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hg : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.RightInverse\">Function.RightInverse</a> <span class=\"fn\">g</span> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.invFun\">Function.invFun</a> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">g</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L391-L392","name":"Function.invFun_neg","line":391,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.invFun_neg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.invFun_neg\"><span class=\"name\">Function</span>.<span class=\"name\">invFun_neg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{b : <span class=\"fn\">β</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">∃ (<span class=\"fn\">a</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.invFun\">Function.invFun</a> <span class=\"fn\">f</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Classical.choice\">Classical.choice</a> <span class=\"fn\">inst✝</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L387-L389","name":"Function.apply_invFun_apply","line":387,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.apply_invFun_apply","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.apply_invFun_apply\"><span class=\"name\">Function</span>.<span class=\"name\">apply_invFun_apply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> u_4}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{a : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">(<a href=\"./Mathlib/Logic/Function/Basic.html#Function.invFun\">Function.invFun</a> <span class=\"fn\">f</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">a</span>)</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">a</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L384-L385","name":"Function.invFun_eq","line":384,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.invFun_eq","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.invFun_eq\"><span class=\"name\">Function</span>.<span class=\"name\">invFun_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{b : <span class=\"fn\">β</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∃ (<span class=\"fn\">a</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">(<a href=\"./Mathlib/Logic/Function/Basic.html#Function.invFun\">Function.invFun</a> <span class=\"fn\">f</span> <span class=\"fn\">b</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L378-L382","name":"Function.invFun","line":378,"kind":"def","docLink":"./Mathlib/Logic/Function/Basic.html#Function.invFun","doc":"The inverse of a function (which is a left inverse if `f` is injective\nand a right inverse if `f` is surjective). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.invFun\"><span class=\"name\">Function</span>.<span class=\"name\">invFun</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L367-L368","name":"Function.partialInv_left","line":367,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.partialInv_left","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.partialInv_left\"><span class=\"name\">Function</span>.<span class=\"name\">partialInv_left</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_4}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_5}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(I : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.partialInv\">Function.partialInv</a> <span class=\"fn\">f</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">x</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Option.some\">some</a> <span class=\"fn\">x</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L353-L365","name":"Function.partialInv_of_injective","line":353,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.partialInv_of_injective","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.partialInv_of_injective\"><span class=\"name\">Function</span>.<span class=\"name\">partialInv_of_injective</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_4}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_5}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(I : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.IsPartialInv\">Function.IsPartialInv</a> <span class=\"fn\">f</span> <span class=\"fn\">(<a href=\"./Mathlib/Logic/Function/Basic.html#Function.partialInv\">Function.partialInv</a> <span class=\"fn\">f</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L348-L351","name":"Function.partialInv","line":348,"kind":"def","docLink":"./Mathlib/Logic/Function/Basic.html#Function.partialInv","doc":"We can use choice to construct explicitly a partial inverse for\na given injective function `f`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.partialInv\"><span class=\"name\">Function</span>.<span class=\"name\">partialInv</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_4}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_5}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <span class=\"fn\">β</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L340-L344","name":"Function.LeftInverse.eq_rightInverse","line":340,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.LeftInverse.eq_rightInverse","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.LeftInverse.eq_rightInverse\"><span class=\"name\">Function</span>.<span class=\"name\">LeftInverse</span>.<span class=\"name\">eq_rightInverse</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g₁ g₂ : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h₁ : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.LeftInverse\">Function.LeftInverse</a> <span class=\"fn\">g₁</span> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h₂ : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.RightInverse\">Function.RightInverse</a> <span class=\"fn\">g₂</span> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">g₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">g₂</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L336-L338","name":"Function.RightInverse.leftInverse_of_injective","line":336,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.RightInverse.leftInverse_of_injective","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.RightInverse.leftInverse_of_injective\"><span class=\"name\">Function</span>.<span class=\"name\">RightInverse</span>.<span class=\"name\">leftInverse_of_injective</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.RightInverse\">Function.RightInverse</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">g</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.LeftInverse\">Function.LeftInverse</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L332-L334","name":"Function.RightInverse.leftInverse_of_surjective","line":332,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.RightInverse.leftInverse_of_surjective","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.RightInverse.leftInverse_of_surjective\"><span class=\"name\">Function</span>.<span class=\"name\">RightInverse</span>.<span class=\"name\">leftInverse_of_surjective</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.RightInverse\">Function.RightInverse</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">f</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.LeftInverse\">Function.LeftInverse</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L328-L330","name":"Function.LeftInverse.rightInverse_of_surjective","line":328,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.LeftInverse.rightInverse_of_surjective","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.LeftInverse.rightInverse_of_surjective\"><span class=\"name\">Function</span>.<span class=\"name\">LeftInverse</span>.<span class=\"name\">rightInverse_of_surjective</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.LeftInverse\">Function.LeftInverse</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hg : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.RightInverse\">Function.RightInverse</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L324-L326","name":"Function.LeftInverse.rightInverse_of_injective","line":324,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.LeftInverse.rightInverse_of_injective","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.LeftInverse.rightInverse_of_injective\"><span class=\"name\">Function</span>.<span class=\"name\">LeftInverse</span>.<span class=\"name\">rightInverse_of_injective</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.LeftInverse\">Function.LeftInverse</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.RightInverse\">Function.RightInverse</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L321-L322","name":"Function.RightInverse.injective","line":321,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.RightInverse.injective","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.RightInverse.injective\"><span class=\"name\">Function</span>.<span class=\"name\">RightInverse</span>.<span class=\"name\">injective</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.RightInverse\">Function.RightInverse</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L318-L319","name":"Function.LeftInverse.surjective","line":318,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.LeftInverse.surjective","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.LeftInverse.surjective\"><span class=\"name\">Function</span>.<span class=\"name\">LeftInverse</span>.<span class=\"name\">surjective</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.LeftInverse\">Function.LeftInverse</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L315-L316","name":"Function.RightInverse.leftInverse","line":315,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.RightInverse.leftInverse","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.RightInverse.leftInverse\"><span class=\"name\">Function</span>.<span class=\"name\">RightInverse</span>.<span class=\"name\">leftInverse</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.RightInverse\">Function.RightInverse</a> <span class=\"fn\">g</span> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.LeftInverse\">Function.LeftInverse</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L312-L313","name":"Function.LeftInverse.rightInverse","line":312,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.LeftInverse.rightInverse","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.LeftInverse.rightInverse\"><span class=\"name\">Function</span>.<span class=\"name\">LeftInverse</span>.<span class=\"name\">rightInverse</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.LeftInverse\">Function.LeftInverse</a> <span class=\"fn\">g</span> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.RightInverse\">Function.RightInverse</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L308-L310","name":"Function.RightInverse.comp","line":308,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.RightInverse.comp","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.RightInverse.comp\"><span class=\"name\">Function</span>.<span class=\"name\">RightInverse</span>.<span class=\"name\">comp</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{h : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">γ</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{i : <span class=\"fn\"><span class=\"fn\">γ</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.RightInverse\">Function.RightInverse</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hh : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.RightInverse\">Function.RightInverse</a> <span class=\"fn\">h</span> <span class=\"fn\">i</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.RightInverse\">Function.RightInverse</a> <span class=\"fn\">(<span class=\"fn\">h</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">f</span>)</span> <span class=\"fn\">(<span class=\"fn\">g</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">i</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L304-L306","name":"Function.LeftInverse.comp","line":304,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.LeftInverse.comp","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.LeftInverse.comp\"><span class=\"name\">Function</span>.<span class=\"name\">LeftInverse</span>.<span class=\"name\">comp</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{h : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">γ</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{i : <span class=\"fn\"><span class=\"fn\">γ</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.LeftInverse\">Function.LeftInverse</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hh : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.LeftInverse\">Function.LeftInverse</a> <span class=\"fn\">h</span> <span class=\"fn\">i</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.LeftInverse\">Function.LeftInverse</a> <span class=\"fn\">(<span class=\"fn\">h</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">f</span>)</span> <span class=\"fn\">(<span class=\"fn\">g</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">i</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L301-L302","name":"Function.rightInverse_iff_comp","line":301,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.rightInverse_iff_comp","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.rightInverse_iff_comp\"><span class=\"name\">Function</span>.<span class=\"name\">rightInverse_iff_comp</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.RightInverse\">Function.RightInverse</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">g</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">id</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L298-L299","name":"Function.RightInverse.comp_eq_id","line":298,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.RightInverse.comp_eq_id","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.RightInverse.comp_eq_id\"><span class=\"name\">Function</span>.<span class=\"name\">RightInverse</span>.<span class=\"name\">comp_eq_id</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.RightInverse\">Function.RightInverse</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">g</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">id</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L295-L296","name":"Function.leftInverse_iff_comp","line":295,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.leftInverse_iff_comp","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.leftInverse_iff_comp\"><span class=\"name\">Function</span>.<span class=\"name\">leftInverse_iff_comp</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.LeftInverse\">Function.LeftInverse</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">g</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">id</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L292-L293","name":"Function.LeftInverse.comp_eq_id","line":292,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.LeftInverse.comp_eq_id","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.LeftInverse.comp_eq_id\"><span class=\"name\">Function</span>.<span class=\"name\">LeftInverse</span>.<span class=\"name\">comp_eq_id</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.LeftInverse\">Function.LeftInverse</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">g</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">id</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L288-L290","name":"Function.injective_of_isPartialInv_right","line":288,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.injective_of_isPartialInv_right","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.injective_of_isPartialInv_right\"><span class=\"name\">Function</span>.<span class=\"name\">injective_of_isPartialInv_right</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_4}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_5}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(H : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.IsPartialInv\">Function.IsPartialInv</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x y : <span class=\"fn\">β</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h₁ : <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\"><span class=\"fn\">g</span> <span class=\"fn\">x</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h₂ : <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\"><span class=\"fn\">g</span> <span class=\"fn\">y</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L284-L286","name":"Function.injective_of_isPartialInv","line":284,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.injective_of_isPartialInv","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.injective_of_isPartialInv\"><span class=\"name\">Function</span>.<span class=\"name\">injective_of_isPartialInv</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_4}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_5}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(H : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.IsPartialInv\">Function.IsPartialInv</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L281-L282","name":"Function.isPartialInv_left","line":281,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.isPartialInv_left","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.isPartialInv_left\"><span class=\"name\">Function</span>.<span class=\"name\">isPartialInv_left</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_4}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_5}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(H : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.IsPartialInv\">Function.IsPartialInv</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">g</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">x</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Option.some\">some</a> <span class=\"fn\">x</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L275-L279","name":"Function.IsPartialInv","line":275,"kind":"def","docLink":"./Mathlib/Logic/Function/Basic.html#Function.IsPartialInv","doc":"`g` is a partial inverse to `f` (an injective but not necessarily\nsurjective function) if `g y = some x` implies `f x = y`, and `g y = none`\nimplies that `y` is not in the range of `f`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.IsPartialInv\"><span class=\"name\">Function</span>.<span class=\"name\">IsPartialInv</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_4}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_5}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L260-L273","name":"Function.not_surjective_Type","line":260,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.not_surjective_Type","doc":"There is no surjection from `α : Type u` into `Type (max u v)`. This theorem\ndemonstrates why `Type : Type` would be inconsistent in Lean. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.not_surjective_Type\"><span class=\"name\">Function</span>.<span class=\"name\">not_surjective_Type</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Type</a> (max u v)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">f</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L254-L258","name":"Function.cantor_injective","line":254,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.cantor_injective","doc":"**Cantor's diagonal argument** implies that there are no injective functions from `Set α`\nto `α`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.cantor_injective\"><span class=\"name\">Function</span>.<span class=\"name\">cantor_injective</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_4}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Set/Defs.html#Set\">Set</a> <span class=\"fn\">α</span></span> → <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L248-L252","name":"Function.cantor_surjective","line":248,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.cantor_surjective","doc":"**Cantor's diagonal argument** implies that there are no surjective functions from `α`\nto `Set α`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.cantor_surjective\"><span class=\"name\">Function</span>.<span class=\"name\">cantor_surjective</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_4}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Set/Defs.html#Set\">Set</a> <span class=\"fn\">α</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">f</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L244-L246","name":"Function.Bijective.of_comp_iff'","line":244,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Bijective.of_comp_iff'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Bijective.of_comp_iff'\"><span class=\"name\">Function</span>.<span class=\"name\">Bijective</span>.<span class=\"name\">of_comp_iff'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Bijective\">Function.Bijective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">γ</span> → <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Bijective\">Function.Bijective</a> <span class=\"fn\">(<span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">g</span>)</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Bijective\">Function.Bijective</a> <span class=\"fn\">g</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L240-L242","name":"Function.Bijective.of_comp_iff","line":240,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Bijective.of_comp_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Bijective.of_comp_iff\"><span class=\"name\">Function</span>.<span class=\"name\">Bijective</span>.<span class=\"name\">of_comp_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">γ</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hg : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Bijective\">Function.Bijective</a> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Bijective\">Function.Bijective</a> <span class=\"fn\">(<span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">g</span>)</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Bijective\">Function.Bijective</a> <span class=\"fn\">f</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L230-L238","name":"Function.Bijective.existsUnique_iff","line":230,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Bijective.existsUnique_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Bijective.existsUnique_iff\"><span class=\"name\">Function</span>.<span class=\"name\">Bijective</span>.<span class=\"name\">existsUnique_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Bijective\">Function.Bijective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{p : <span class=\"fn\"><span class=\"fn\">β</span> → <a href=\"./foundational_types.html\">Prop</a></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(∃! <span class=\"fn\">y</span> : <span class=\"fn\">β</span>, <span class=\"fn\"><span class=\"fn\">p</span> <span class=\"fn\">y</span></span>)</span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">∃! <span class=\"fn\">x</span> : <span class=\"fn\">α</span>, <span class=\"fn\"><span class=\"fn\">p</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">x</span>)</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L225-L228","name":"Function.Bijective.existsUnique","line":225,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Bijective.existsUnique","doc":"Shorthand for using projection notation with `Function.bijective_iff_existsUnique`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Bijective.existsUnique\"><span class=\"name\">Function</span>.<span class=\"name\">Bijective</span>.<span class=\"name\">existsUnique</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Bijective\">Function.Bijective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <span class=\"fn\">β</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∃! <span class=\"fn\">a</span> : <span class=\"fn\">α</span>, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L219-L223","name":"Function.bijective_iff_existsUnique","line":219,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.bijective_iff_existsUnique","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.bijective_iff_existsUnique\"><span class=\"name\">Function</span>.<span class=\"name\">bijective_iff_existsUnique</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Bijective\">Function.Bijective</a> <span class=\"fn\">f</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">∀ (<span class=\"fn\">b</span> : <span class=\"fn\">β</span>), <span class=\"fn\">∃! <span class=\"fn\">a</span> : <span class=\"fn\">α</span>, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L214-L217","name":"Function.surjective_of_right_cancellable_Prop","line":214,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.surjective_of_right_cancellable_Prop","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.surjective_of_right_cancellable_Prop\"><span class=\"name\">Function</span>.<span class=\"name\">surjective_of_right_cancellable_Prop</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">g₁ </span><span class=\"fn\">g₂</span> : <span class=\"fn\"><span class=\"fn\">β</span> → <a href=\"./foundational_types.html\">Prop</a></span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">g₁</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">g₂</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">f</span></span></span> → <span class=\"fn\"><span class=\"fn\">g₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">g₂</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L210-L212","name":"Function.Surjective.right_cancellable","line":210,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Surjective.right_cancellable","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Surjective.right_cancellable\"><span class=\"name\">Function</span>.<span class=\"name\">Surjective</span>.<span class=\"name\">right_cancellable</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g₁ g₂ : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">γ</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">g₁</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">g₂</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">f</span></span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\">g₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">g₂</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L207-L208","name":"Function.Surjective.injective_comp_right","line":207,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Surjective.injective_comp_right","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Surjective.injective_comp_right\"><span class=\"name\">Function</span>.<span class=\"name\">Surjective</span>.<span class=\"name\">injective_comp_right</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">fun (<span class=\"fn\">g</span> : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">γ</span></span>) =&gt; <span class=\"fn\"><span class=\"fn\">g</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">f</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L203-L205","name":"Function.Surjective.exists₃","line":203,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Surjective.exists₃","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Surjective.exists₃\"><span class=\"name\">Function</span>.<span class=\"name\">Surjective</span>.<span class=\"name\">exists₃</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{p : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">β</span> → <span class=\"fn\">β</span> → <a href=\"./foundational_types.html\">Prop</a></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(∃ (<span class=\"fn\">y₁</span> : <span class=\"fn\">β</span>), <span class=\"fn\">∃ (<span class=\"fn\">y₂</span> : <span class=\"fn\">β</span>), <span class=\"fn\">∃ (<span class=\"fn\">y₃</span> : <span class=\"fn\">β</span>), <span class=\"fn\"><span class=\"fn\">p</span> <span class=\"fn\">y₁</span> <span class=\"fn\">y₂</span> <span class=\"fn\">y₃</span></span></span></span>)</span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">∃ (<span class=\"fn\">x₁</span> : <span class=\"fn\">α</span>), <span class=\"fn\">∃ (<span class=\"fn\">x₂</span> : <span class=\"fn\">α</span>), <span class=\"fn\">∃ (<span class=\"fn\">x₃</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">p</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">x₁</span>)</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">x₂</span>)</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">x₃</span>)</span></span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L199-L201","name":"Function.Surjective.exists₂","line":199,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Surjective.exists₂","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Surjective.exists₂\"><span class=\"name\">Function</span>.<span class=\"name\">Surjective</span>.<span class=\"name\">exists₂</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{p : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">β</span> → <a href=\"./foundational_types.html\">Prop</a></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(∃ (<span class=\"fn\">y₁</span> : <span class=\"fn\">β</span>), <span class=\"fn\">∃ (<span class=\"fn\">y₂</span> : <span class=\"fn\">β</span>), <span class=\"fn\"><span class=\"fn\">p</span> <span class=\"fn\">y₁</span> <span class=\"fn\">y₂</span></span></span>)</span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">∃ (<span class=\"fn\">x₁</span> : <span class=\"fn\">α</span>), <span class=\"fn\">∃ (<span class=\"fn\">x₂</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">p</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">x₁</span>)</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">x₂</span>)</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L192-L197","name":"Function.Surjective.exists","line":192,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Surjective.exists","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Surjective.exists\"><span class=\"name\">Function</span>.<span class=\"name\">Surjective</span>.<span class=\"name\">exists</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{p : <span class=\"fn\"><span class=\"fn\">β</span> → <a href=\"./foundational_types.html\">Prop</a></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(∃ (<span class=\"fn\">y</span> : <span class=\"fn\">β</span>), <span class=\"fn\"><span class=\"fn\">p</span> <span class=\"fn\">y</span></span>)</span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">∃ (<span class=\"fn\">x</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">p</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">x</span>)</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L188-L190","name":"Function.Surjective.forall₃","line":188,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Surjective.forall₃","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Surjective.forall₃\"><span class=\"name\">Function</span>.<span class=\"name\">Surjective</span>.<span class=\"name\">forall₃</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{p : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">β</span> → <span class=\"fn\">β</span> → <a href=\"./foundational_types.html\">Prop</a></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(∀ (<span class=\"fn\">y₁ </span><span class=\"fn\">y₂ </span><span class=\"fn\">y₃</span> : <span class=\"fn\">β</span>), <span class=\"fn\"><span class=\"fn\">p</span> <span class=\"fn\">y₁</span> <span class=\"fn\">y₂</span> <span class=\"fn\">y₃</span></span>)</span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">∀ (<span class=\"fn\">x₁ </span><span class=\"fn\">x₂ </span><span class=\"fn\">x₃</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">p</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">x₁</span>)</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">x₂</span>)</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">x₃</span>)</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L184-L186","name":"Function.Surjective.forall₂","line":184,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Surjective.forall₂","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Surjective.forall₂\"><span class=\"name\">Function</span>.<span class=\"name\">Surjective</span>.<span class=\"name\">forall₂</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{p : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">β</span> → <a href=\"./foundational_types.html\">Prop</a></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(∀ (<span class=\"fn\">y₁ </span><span class=\"fn\">y₂</span> : <span class=\"fn\">β</span>), <span class=\"fn\"><span class=\"fn\">p</span> <span class=\"fn\">y₁</span> <span class=\"fn\">y₂</span></span>)</span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">∀ (<span class=\"fn\">x₁ </span><span class=\"fn\">x₂</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">p</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">x₁</span>)</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">x₂</span>)</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L178-L182","name":"Function.Surjective.forall","line":178,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Surjective.forall","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Surjective.forall\"><span class=\"name\">Function</span>.<span class=\"name\">Surjective</span>.<span class=\"name\">forall</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{p : <span class=\"fn\"><span class=\"fn\">β</span> → <a href=\"./foundational_types.html\">Prop</a></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(∀ (<span class=\"fn\">y</span> : <span class=\"fn\">β</span>), <span class=\"fn\"><span class=\"fn\">p</span> <span class=\"fn\">y</span></span>)</span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">∀ (<span class=\"fn\">x</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">p</span> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">x</span>)</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L174-L176","name":"Function.decidableEqPFun","line":174,"kind":"instance","docLink":"./Mathlib/Logic/Function/Basic.html#Function.decidableEqPFun","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.decidableEqPFun\"><span class=\"name\">Function</span>.<span class=\"name\">decidableEqPFun</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./foundational_types.html\">Prop</a>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> <span class=\"fn\">p</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(α : <span class=\"fn\"><span class=\"fn\">p</span> → <a href=\"./foundational_types.html\">Type</a> u_4</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">(<span class=\"fn\">hp</span> : <span class=\"fn\">p</span>) → <span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">(<span class=\"fn\">α</span> <span class=\"fn\">hp</span>)</span></span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">((<span class=\"fn\">hp</span> : <span class=\"fn\">p</span>) → <span class=\"fn\"><span class=\"fn\">α</span> <span class=\"fn\">hp</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L169-L172","name":"Function.Surjective.of_comp_iff'","line":169,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Surjective.of_comp_iff'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Surjective.of_comp_iff'\"><span class=\"name\">Function</span>.<span class=\"name\">Surjective</span>.<span class=\"name\">of_comp_iff'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Bijective\">Function.Bijective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">γ</span> → <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">(<span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">g</span>)</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">g</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L165-L167","name":"Function.Injective.bijective₂_of_surjective","line":165,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Injective.bijective₂_of_surjective","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Injective.bijective₂_of_surjective\"><span class=\"name\">Function</span>.<span class=\"name\">Injective</span>.<span class=\"name\">bijective₂_of_surjective</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">γ</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hg : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(S : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">(<span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">g</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Bijective\">Function.Bijective</a> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Bijective\">Function.Bijective</a> <span class=\"fn\">g</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L162-L163","name":"Function.Surjective.of_comp_left","line":162,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Surjective.of_comp_left","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Surjective.of_comp_left\"><span class=\"name\">Function</span>.<span class=\"name\">Surjective</span>.<span class=\"name\">of_comp_left</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">γ</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(S : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">(<span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">g</span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">g</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L157-L160","name":"Function.Surjective.of_comp_iff","line":157,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Surjective.of_comp_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Surjective.of_comp_iff\"><span class=\"name\">Function</span>.<span class=\"name\">Surjective</span>.<span class=\"name\">of_comp_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">γ</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hg : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">(<span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">g</span>)</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">f</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L153-L155","name":"Function.Surjective.of_comp","line":153,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Surjective.of_comp","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Surjective.of_comp\"><span class=\"name\">Function</span>.<span class=\"name\">Surjective</span>.<span class=\"name\">of_comp</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">γ</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(S : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">(<span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">g</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L141-L151","name":"Function.Injective.dite","line":141,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Injective.dite","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Injective.dite\"><span class=\"name\">Function</span>.<span class=\"name\">Injective</span>.<span class=\"name\">dite</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(p : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidablePred\">DecidablePred</a> <span class=\"fn\">p</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">{ <span class=\"fn\">a</span> : <span class=\"fn\">α</span> // <span class=\"fn\"><span class=\"fn\">p</span> <span class=\"fn\">a</span></span> }</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f' : <span class=\"fn\"><span class=\"fn\">{ <span class=\"fn\">a</span> : <span class=\"fn\">α</span> // <span class=\"fn\"><a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\"><span class=\"fn\">p</span> <span class=\"fn\">a</span></span></span> }</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hf' : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(im_disj : <span class=\"fn\">∀ {<span class=\"fn\">x </span><span class=\"fn\">x'</span> : <span class=\"fn\">α</span>} {<span class=\"fn\">hx</span> : <span class=\"fn\"><span class=\"fn\">p</span> <span class=\"fn\">x</span></span>} {<span class=\"fn\">hx'</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\"><span class=\"fn\">p</span> <span class=\"fn\">x'</span></span></span>}, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">⟨<span class=\"fn\">x</span>, <span class=\"fn\">hx</span>⟩</span></span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\"><span class=\"fn\">f'</span> <span class=\"fn\">⟨<span class=\"fn\">x'</span>, <span class=\"fn\">hx'</span>⟩</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\">if h : <span class=\"fn\"><span class=\"fn\">p</span> <span class=\"fn\">x</span></span> then <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">⟨<span class=\"fn\">x</span>, <span class=\"fn\">h</span>⟩</span></span> else <span class=\"fn\"><span class=\"fn\">f'</span> <span class=\"fn\">⟨<span class=\"fn\">x</span>, <span class=\"fn\">h</span>⟩</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L138-L139","name":"Function.injective_of_subsingleton","line":138,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.injective_of_subsingleton","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.injective_of_subsingleton\"><span class=\"name\">Function</span>.<span class=\"name\">injective_of_subsingleton</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Core.html#Subsingleton\">Subsingleton</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L134-L136","name":"Function.Injective.comp_left","line":134,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Injective.comp_left","doc":"Composition by an injective function on the left is itself injective. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Injective.comp_left\"><span class=\"name\">Function</span>.<span class=\"name\">Injective</span>.<span class=\"name\">comp_left</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">γ</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hg : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">fun (<span class=\"fn\">x</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>) =&gt; <span class=\"fn\"><span class=\"fn\">g</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">x</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L132-L132","name":"Function.injective_pi_map","line":132,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.injective_pi_map","doc":"**Alias** of `Function.Injective.piMap`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.injective_pi_map\"><span class=\"name\">Function</span>.<span class=\"name\">injective_pi_map</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{ι : <a href=\"./foundational_types.html\">Sort</a> u_4}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <span class=\"fn\"><span class=\"fn\">ι</span> → <a href=\"./foundational_types.html\">Sort</a> u_5</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">ι</span> → <a href=\"./foundational_types.html\">Sort</a> u_6</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\">ι</span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">α</span> <span class=\"fn\">i</span></span> → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">i</span></span></span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\">∀ (<span class=\"fn\">i</span> : <span class=\"fn\">ι</span>), <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">i</span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">(<a href=\"./Mathlib/Logic/Function/Defs.html#Pi.map\">Pi.map</a> <span class=\"fn\">f</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L128-L130","name":"Function.Injective.piMap","line":128,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Injective.piMap","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Injective.piMap\"><span class=\"name\">Function</span>.<span class=\"name\">Injective</span>.<span class=\"name\">piMap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{ι : <a href=\"./foundational_types.html\">Sort</a> u_4}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <span class=\"fn\"><span class=\"fn\">ι</span> → <a href=\"./foundational_types.html\">Sort</a> u_5</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">ι</span> → <a href=\"./foundational_types.html\">Sort</a> u_6</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\">ι</span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">α</span> <span class=\"fn\">i</span></span> → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">i</span></span></span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\">∀ (<span class=\"fn\">i</span> : <span class=\"fn\">ι</span>), <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">i</span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">(<a href=\"./Mathlib/Logic/Function/Defs.html#Pi.map\">Pi.map</a> <span class=\"fn\">f</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L123-L126","name":"Function.Injective.of_comp_iff'","line":123,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Injective.of_comp_iff'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Injective.of_comp_iff'\"><span class=\"name\">Function</span>.<span class=\"name\">Injective</span>.<span class=\"name\">of_comp_iff'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">γ</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hg : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Bijective\">Function.Bijective</a> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">(<span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">g</span>)</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L119-L121","name":"Function.Surjective.bijective₂_of_injective","line":119,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Surjective.bijective₂_of_injective","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Surjective.bijective₂_of_injective\"><span class=\"name\">Function</span>.<span class=\"name\">Surjective</span>.<span class=\"name\">bijective₂_of_injective</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">γ</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hg : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(I : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">(<span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">g</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Bijective\">Function.Bijective</a> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Bijective\">Function.Bijective</a> <span class=\"fn\">g</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L113-L117","name":"Function.Injective.of_comp_right","line":113,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Injective.of_comp_right","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Injective.of_comp_right\"><span class=\"name\">Function</span>.<span class=\"name\">Injective</span>.<span class=\"name\">of_comp_right</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">γ</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(I : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">(<span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">g</span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hg : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L108-L111","name":"Function.Injective.of_comp_iff","line":108,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Injective.of_comp_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Injective.of_comp_iff\"><span class=\"name\">Function</span>.<span class=\"name\">Injective</span>.<span class=\"name\">of_comp_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">γ</span> → <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">(<span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">g</span>)</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">g</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L105-L106","name":"Function.Injective.of_comp","line":105,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Injective.of_comp","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Injective.of_comp\"><span class=\"name\">Function</span>.<span class=\"name\">Injective</span>.<span class=\"name\">of_comp</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">γ</span> → <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(I : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">(<span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">g</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">g</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L100-L103","name":"Function.Injective.decidableEq","line":100,"kind":"def","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Injective.decidableEq","doc":"If the co-domain `β` of an injective function `f : α → β` has decidable equality, then\nthe domain `α` also has decidable equality. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Injective.decidableEq\"><span class=\"name\">Function</span>.<span class=\"name\">Injective</span>.<span class=\"name\">decidableEq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(I : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L97-L98","name":"Function.not_injective_iff","line":97,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.not_injective_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.not_injective_iff\"><span class=\"name\">Function</span>.<span class=\"name\">not_injective_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">∃ (<span class=\"fn\">a</span> : <span class=\"fn\">α</span>), <span class=\"fn\">∃ (<span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">b</span></span></span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\">b</span></span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L94-L95","name":"Function.Injective.ne_iff'","line":94,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Injective.ne_iff'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Injective.ne_iff'\"><span class=\"name\">Function</span>.<span class=\"name\">Injective</span>.<span class=\"name\">ne_iff'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{x y : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{z : <span class=\"fn\">β</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">y</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">z</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\">z</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\">y</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L91-L92","name":"Function.Injective.ne_iff","line":91,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Injective.ne_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Injective.ne_iff\"><span class=\"name\">Function</span>.<span class=\"name\">Injective</span>.<span class=\"name\">ne_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{x y : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">y</span></span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\">y</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L88-L89","name":"Function.Injective.ne","line":88,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Injective.ne","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Injective.ne\"><span class=\"name\">Function</span>.<span class=\"name\">Injective</span>.<span class=\"name\">ne</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{a₁ a₂ : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">a₁</span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\">a₂</span></span> → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">a₁</span></span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">a₂</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L85-L86","name":"Function.Injective.eq_iff'","line":85,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Injective.eq_iff'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Injective.eq_iff'\"><span class=\"name\">Function</span>.<span class=\"name\">Injective</span>.<span class=\"name\">eq_iff'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(I : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{a b : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <span class=\"fn\">β</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L81-L83","name":"Function.Injective.beq_eq","line":81,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Injective.beq_eq","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Injective.beq_eq\"><span class=\"name\">Function</span>.<span class=\"name\">Injective</span>.<span class=\"name\">beq_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_4}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> u_5}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Core.html#LawfulBEq\">LawfulBEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Core.html#LawfulBEq\">LawfulBEq</a> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(I : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{a b : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#BEq.beq\">==</a> <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">b</span></span>)</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">(<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#BEq.beq\">==</a> <span class=\"fn\">b</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L78-L79","name":"Function.Injective.eq_iff","line":78,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Injective.eq_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Injective.eq_iff\"><span class=\"name\">Function</span>.<span class=\"name\">Injective</span>.<span class=\"name\">eq_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(I : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{a b : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">b</span></span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L76-L76","name":"Function.Bijective.surjective","line":76,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Bijective.surjective","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Bijective.surjective\"><span class=\"name\">Function</span>.<span class=\"name\">Bijective</span>.<span class=\"name\">surjective</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Bijective\">Function.Bijective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L75-L75","name":"Function.Bijective.injective","line":75,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.Bijective.injective","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.Bijective.injective\"><span class=\"name\">Function</span>.<span class=\"name\">Bijective</span>.<span class=\"name\">injective</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Bijective\">Function.Bijective</a> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L73-L73","name":"Function.swap_ge","line":73,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.swap_ge","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.swap_ge\"><span class=\"name\">Function</span>.<span class=\"name\">swap_ge</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_4}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Defs/PartialOrder.html#Preorder\">Preorder</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Logic/Function/Defs.html#Function.swap\">Function.swap</a> <span class=\"fn\">fun (<span class=\"fn\">x1</span> <span class=\"fn\">x2</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x1</span> <a href=\"./Init/Prelude.html#GE.ge\">≥</a> <span class=\"fn\">x2</span></span></span>)</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">fun (<span class=\"fn\">x1</span> <span class=\"fn\">x2</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x1</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x2</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L72-L72","name":"Function.swap_gt","line":72,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.swap_gt","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.swap_gt\"><span class=\"name\">Function</span>.<span class=\"name\">swap_gt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_4}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Defs/PartialOrder.html#Preorder\">Preorder</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Logic/Function/Defs.html#Function.swap\">Function.swap</a> <span class=\"fn\">fun (<span class=\"fn\">x1</span> <span class=\"fn\">x2</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x1</span> <a href=\"./Init/Prelude.html#GT.gt\">&gt;</a> <span class=\"fn\">x2</span></span></span>)</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">fun (<span class=\"fn\">x1</span> <span class=\"fn\">x2</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x1</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">x2</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L71-L71","name":"Function.swap_le","line":71,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.swap_le","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.swap_le\"><span class=\"name\">Function</span>.<span class=\"name\">swap_le</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_4}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Defs/PartialOrder.html#Preorder\">Preorder</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Logic/Function/Defs.html#Function.swap\">Function.swap</a> <span class=\"fn\">fun (<span class=\"fn\">x1</span> <span class=\"fn\">x2</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x1</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x2</span></span></span>)</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">fun (<span class=\"fn\">x1</span> <span class=\"fn\">x2</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x1</span> <a href=\"./Init/Prelude.html#GE.ge\">≥</a> <span class=\"fn\">x2</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L70-L70","name":"Function.swap_lt","line":70,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.swap_lt","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.swap_lt\"><span class=\"name\">Function</span>.<span class=\"name\">swap_lt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_4}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Defs/PartialOrder.html#Preorder\">Preorder</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Logic/Function/Defs.html#Function.swap\">Function.swap</a> <span class=\"fn\">fun (<span class=\"fn\">x1</span> <span class=\"fn\">x2</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x1</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">x2</span></span></span>)</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">fun (<span class=\"fn\">x1</span> <span class=\"fn\">x2</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">x1</span> <a href=\"./Init/Prelude.html#GT.gt\">&gt;</a> <span class=\"fn\">x2</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L64-L68","name":"Function.funext_iff_of_subsingleton","line":64,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.funext_iff_of_subsingleton","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.funext_iff_of_subsingleton\"><span class=\"name\">Function</span>.<span class=\"name\">funext_iff_of_subsingleton</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Core.html#Subsingleton\">Subsingleton</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x y : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">g</span> <span class=\"fn\">y</span></span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">g</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L61-L62","name":"Function.ne_iff","line":61,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.ne_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.ne_iff\"><span class=\"name\">Function</span>.<span class=\"name\">ne_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Sort</a> u_4</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f₁ f₂ : <span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a</span></span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f₁</span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\">f₂</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">∃ (<span class=\"fn\">a</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f₁</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\"><span class=\"fn\">f₂</span> <span class=\"fn\">a</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L51-L59","name":"Function.hfunext","line":51,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.hfunext","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.hfunext\"><span class=\"name\">Function</span>.<span class=\"name\">hfunext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α α' : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Sort</a> v</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β' : <span class=\"fn\"><span class=\"fn\">α'</span> → <a href=\"./foundational_types.html\">Sort</a> v</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">a</span></span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f' : <span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α'</span>) → <span class=\"fn\"><span class=\"fn\">β'</span> <span class=\"fn\">a</span></span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hα : <span class=\"fn\"><span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">α'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">a</span> : <span class=\"fn\">α</span>) (<span class=\"fn\">a'</span> : <span class=\"fn\">α'</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#HEq\">HEq</a> <span class=\"fn\">a</span> <span class=\"fn\">a'</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#HEq\">HEq</a> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">a</span>)</span> <span class=\"fn\">(<span class=\"fn\">f'</span> <span class=\"fn\">a'</span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#HEq\">HEq</a> <span class=\"fn\">f</span> <span class=\"fn\">f'</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L48-L49","name":"Function.onFun_apply","line":48,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.onFun_apply","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.onFun_apply\"><span class=\"name\">Function</span>.<span class=\"name\">onFun_apply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{γ : <a href=\"./foundational_types.html\">Sort</a> u_3}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">β</span> → <span class=\"fn\">γ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a b : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\">f</span> <a href=\"./Mathlib/Logic/Function/Defs.html#Function.onFun\">on</a> <span class=\"fn\">g</span>)</span> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">(<span class=\"fn\">g</span> <span class=\"fn\">a</span>)</span> <span class=\"fn\">(<span class=\"fn\">g</span> <span class=\"fn\">b</span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L42-L44","name":"Function.const_inj","line":42,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.const_inj","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.const_inj\"><span class=\"name\">Function</span>.<span class=\"name\">const_inj</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{y₁ y₂ : <span class=\"fn\">β</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Function.const\">Function.const</a> <span class=\"fn\">α</span> <span class=\"fn\">y₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Function.const\">Function.const</a> <span class=\"fn\">α</span> <span class=\"fn\">y₂</span></span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\">y₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y₂</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L38-L40","name":"Function.const_injective","line":38,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.const_injective","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.const_injective\"><span class=\"name\">Function</span>.<span class=\"name\">const_injective</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Defs.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Function.const\">Function.const</a> <span class=\"fn\">α</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L35-L36","name":"Function.const_def","line":35,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.const_def","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.const_def\"><span class=\"name\">Function</span>.<span class=\"name\">const_def</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{y : <span class=\"fn\">β</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(fun (<span class=\"fn\">x</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\">y</span>)</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Function.const\">Function.const</a> <span class=\"fn\">α</span> <span class=\"fn\">y</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L32-L33","name":"Function.eval_apply","line":32,"kind":"theorem","docLink":"./Mathlib/Logic/Function/Basic.html#Function.eval_apply","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.eval_apply\"><span class=\"name\">Function</span>.<span class=\"name\">eval_apply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Sort</a> u_4</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">x</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Function/Basic.html#Function.eval\">Function.eval</a> <span class=\"fn\">x</span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">x</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Function/Basic.lean#L28-L30","name":"Function.eval","line":28,"kind":"def","docLink":"./Mathlib/Logic/Function/Basic.html#Function.eval","doc":"Evaluate a function at an argument. Useful if you want to talk about the partially applied\n`Function.eval x : (∀ x, β x) → β x`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Logic/Function/Basic.html#Function.eval\"><span class=\"name\">Function</span>.<span class=\"name\">eval</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Sort</a> u_4</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">x</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">x</span></span></div></div>"}]}