{"name":"Mathlib.Tactic.Abel","instances":[{"typeNames":["Mathlib.Tactic.Abel.NormalExpr"],"name":"Mathlib.Tactic.Abel.instInhabitedNormalExpr","className":"Inhabited"},{"typeNames":["Mathlib.Tactic.Abel.NormalExpr","Lean.Expr"],"name":"Mathlib.Tactic.Abel.instCoeNormalExprExpr","className":"Coe"}],"imports":["Init","Mathlib.Tactic.NormNum.Basic","Mathlib.Tactic.TryThis","Mathlib.Util.AtomM"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L563-L564","name":"Mathlib.Tactic.Abel.convAbel!","line":563,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.convAbel!","doc":"The tactic `abel` evaluates expressions in abelian groups.\nThis is the conv tactic version, which rewrites a target which is an abel equality to `True`.\n\nSee also the `abel` tactic.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.convAbel!\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">convAbel!</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L561-L562","name":"Mathlib.Tactic.Abel.abelConv","line":561,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelConv","doc":"The tactic `abel` evaluates expressions in abelian groups.\nThis is the conv tactic version, which rewrites a target which is an abel equality to `True`.\n\nSee also the `abel` tactic.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelConv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abelConv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L552-L553","name":"Mathlib.Tactic.Abel.tacticAbel!","line":552,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.tacticAbel!","doc":"Tactic for evaluating expressions in abelian groups.\n\n* `abel!` will use a more aggressive reducibility setting to determine equality of atoms.\n* `abel1` fails if the target is not an equality.\n\nFor example:\n```\nexample [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by abel\nexample [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by abel\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.tacticAbel!\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">tacticAbel!</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L550-L551","name":"Mathlib.Tactic.Abel.abel","line":550,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel","doc":"Tactic for evaluating expressions in abelian groups.\n\n* `abel!` will use a more aggressive reducibility setting to determine equality of atoms.\n* `abel1` fails if the target is not an equality.\n\nFor example:\n```\nexample [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by abel\nexample [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by abel\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abel</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L536-L536","name":"Mathlib.Tactic.Abel.convAbel_nf!_","line":536,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.convAbel_nf!_","doc":"Simplification tactic for expressions in the language of abelian groups,\nwhich rewrites all group expressions into a normal form.\n* `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n* `abel_nf (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel_nf` works as both a tactic and a conv tactic.\n  In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.convAbel_nf!_\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">convAbel_nf!_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L528-L534","name":"Mathlib.Tactic.Abel.elabAbelNFConv","line":528,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.elabAbelNFConv","doc":"Elaborator for the `abel_nf` tactic. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.elabAbelNFConv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">elabAbelNFConv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.Tactic\">Lean.Elab.Tactic.Tactic</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L526-L526","name":"Mathlib.Tactic.Abel.abelNFConv","line":526,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFConv","doc":"Simplification tactic for expressions in the language of abelian groups,\nwhich rewrites all group expressions into a normal form.\n* `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n* `abel_nf (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel_nf` works as both a tactic and a conv tactic.\n  In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFConv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abelNFConv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L523-L524","name":"Mathlib.Tactic.Abel.tacticAbel_nf!__","line":523,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.tacticAbel_nf!__","doc":"Simplification tactic for expressions in the language of abelian groups,\nwhich rewrites all group expressions into a normal form.\n* `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n* `abel_nf (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel_nf` works as both a tactic and a conv tactic.\n  In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.tacticAbel_nf!__\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">tacticAbel_nf!__</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L505-L521","name":"Mathlib.Tactic.Abel.abelNF","line":505,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNF","doc":"Simplification tactic for expressions in the language of abelian groups,\nwhich rewrites all group expressions into a normal form.\n* `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n* `abel_nf (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel_nf` works as both a tactic and a conv tactic.\n  In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNF\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abelNF</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L502-L503","name":"Mathlib.Tactic.Abel.abel!_term","line":502,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel!_term","doc":"Unsupported legacy syntax from mathlib3, which allowed passing additional terms to `abel!`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel!_term\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abel!_term</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L500-L501","name":"Mathlib.Tactic.Abel.abel_term","line":500,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel_term","doc":"Unsupported legacy syntax from mathlib3, which allowed passing additional terms to `abel`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel_term\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abel_term</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L489-L498","name":"Mathlib.Tactic.Abel.abelNFLocalDecl","line":489,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFLocalDecl","doc":"Use `abel_nf` to rewrite hypothesis `h`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFLocalDecl\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abelNFLocalDecl</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Init/System/IO.html#IO.Ref\">IO.Ref</a> <a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.State\">Mathlib.Tactic.AtomM.State</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\">Mathlib.Tactic.Abel.AbelNF.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fvarId : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L477-L487","name":"Mathlib.Tactic.Abel.abelNFTarget","line":477,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFTarget","doc":"Use `abel_nf` to rewrite the main goal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFTarget\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abelNFTarget</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Init/System/IO.html#IO.Ref\">IO.Ref</a> <a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.State\">Mathlib.Tactic.AtomM.State</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\">Mathlib.Tactic.Abel.AbelNF.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L473-L473","name":"Mathlib.Tactic.Abel.abelNFCore.evalAtom","line":473,"kind":"opaque","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFCore.evalAtom","doc":"The `evalAtom` implementation passed to `eval` calls `go` if `cfg.recursive` is true,\nand does nothing otherwise. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFCore.evalAtom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abelNFCore</span>.<span class=\"name\">evalAtom</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Init/System/IO.html#IO.Ref\">IO.Ref</a> <a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.State\">Mathlib.Tactic.AtomM.State</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\">Mathlib.Tactic.Abel.AbelNF.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ctx : <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Context\">Lean.Meta.Simp.Context</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(simp : <span class=\"fn\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.SimpM\">Lean.Meta.SimpM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L457-L470","name":"Mathlib.Tactic.Abel.abelNFCore.go","line":457,"kind":"opaque","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFCore.go","doc":"The recursive case of `abelNF`.\n* `root`: true when the function is called directly from `abelNFCore`\n  and false when called by `evalAtom` in recursive mode.\n* `parent`: The input expression to simplify. In `pre` we make use of both `parent` and `e`\n  to determine if we are at the top level in order to prevent a loop\n  `go -> eval -> evalAtom -> go` which makes no progress.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFCore.go\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abelNFCore</span>.<span class=\"name\">go</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Init/System/IO.html#IO.Ref\">IO.Ref</a> <a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.State\">Mathlib.Tactic.AtomM.State</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\">Mathlib.Tactic.Abel.AbelNF.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ctx : <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Context\">Lean.Meta.Simp.Context</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(simp : <span class=\"fn\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.SimpM\">Lean.Meta.SimpM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(root : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(parent : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L429-L474","name":"Mathlib.Tactic.Abel.abelNFCore","line":429,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFCore","doc":"The core of `abel_nf`, which rewrites the expression `e` into `abel` normal form.\n\n* `s`: a reference to the mutable state of `abel`, for persisting across calls.\n  This ensures that atom ordering is used consistently.\n* `cfg`: the configuration options\n* `e`: the expression to rewrite\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abelNFCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Init/System/IO.html#IO.Ref\">IO.Ref</a> <a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.State\">Mathlib.Tactic.AtomM.State</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\">Mathlib.Tactic.Abel.AbelNF.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L426-L427","name":"Mathlib.Tactic.Abel.elabAbelNFConfig","line":426,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.elabAbelNFConfig","doc":"Function elaborating `AbelNF.Config`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.elabAbelNFConfig\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">elabAbelNFConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> → <span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\">Mathlib.Tactic.Abel.AbelNF.Config</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L424-L424","name":"Mathlib.Tactic.Abel.AbelNF.Config.mode","line":424,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.mode","doc":"The normalization style. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.mode\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">AbelNF</span>.<span class=\"name\">Config</span>.<span class=\"name\">mode</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\">Mathlib.Tactic.Abel.AbelNF.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode\">Mathlib.Tactic.Abel.AbelMode</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L422-L422","name":"Mathlib.Tactic.Abel.AbelNF.Config.recursive","line":422,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.recursive","doc":"if true, atoms inside ring expressions will be reduced recursively "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.recursive\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">AbelNF</span>.<span class=\"name\">Config</span>.<span class=\"name\">recursive</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\">Mathlib.Tactic.Abel.AbelNF.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L420-L420","name":"Mathlib.Tactic.Abel.AbelNF.Config.red","line":420,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.red","doc":"the reducibility setting to use when comparing atoms for defeq "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.red\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">AbelNF</span>.<span class=\"name\">Config</span>.<span class=\"name\">red</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\">Mathlib.Tactic.Abel.AbelNF.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode\">Lean.Meta.TransparencyMode</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L418-L418","name":"Mathlib.Tactic.Abel.AbelNF.Config.mk","line":418,"kind":"ctor","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">AbelNF</span>.<span class=\"name\">Config</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(red : <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode\">Lean.Meta.TransparencyMode</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(recursive : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(mode : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode\">Mathlib.Tactic.Abel.AbelMode</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\">Mathlib.Tactic.Abel.AbelNF.Config</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L417-L424","name":"Mathlib.Tactic.Abel.AbelNF.Config","line":417,"kind":"structure","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config","doc":"Configuration for `abel_nf`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">AbelNF</span>.<span class=\"name\">Config</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L414-L415","name":"Mathlib.Tactic.Abel.AbelMode.raw","line":414,"kind":"ctor","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode.raw","doc":"Raw form: the representation `abel` uses internally. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode.raw\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">AbelMode</span>.<span class=\"name\">raw</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode\">Mathlib.Tactic.Abel.AbelMode</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L412-L413","name":"Mathlib.Tactic.Abel.AbelMode.term","line":412,"kind":"ctor","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode.term","doc":"The default form "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode.term\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">AbelMode</span>.<span class=\"name\">term</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode\">Mathlib.Tactic.Abel.AbelMode</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L410-L415","name":"Mathlib.Tactic.Abel.AbelMode","line":410,"kind":"inductive","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode","doc":"The normalization style for `abel_nf`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">AbelMode</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L405-L408","name":"Mathlib.Tactic.Abel.NormalExpr.isAtom","line":405,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.isAtom","doc":"True if this represents an atomic expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.isAtom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">NormalExpr</span>.<span class=\"name\">isAtom</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L402-L403","name":"Mathlib.Tactic.Abel.termg_eq","line":402,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg_eq","doc":"A type synonym used by `abel` to represent `n • x + a` in an additive commutative group. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">termg_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">Mathlib.Tactic.Abel.termg</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">n</span> <a href=\"./Mathlib/Algebra/Group/Operations.html#HSMul.hSMul\">•</a> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L401-L401","name":"Mathlib.Tactic.Abel.term_eq","line":401,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_eq","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">Mathlib.Tactic.Abel.term</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">n</span> <a href=\"./Mathlib/Algebra/Group/Operations.html#HSMul.hSMul\">•</a> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L399-L399","name":"Mathlib.Tactic.Abel.abel1!","line":399,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1!","doc":"Tactic for solving equations in the language of\n*additive*, commutative monoids and groups.\nThis version of `abel` fails if the target is not an equality\nthat is provable by the axioms of commutative monoids/groups.\n\n`abel1!` will use a more aggressive reducibility setting to identify atoms.\nThis can prove goals that `abel` cannot, but is more expensive.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1!\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abel1!</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L369-L377","name":"Mathlib.Tactic.Abel.abel1","line":369,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1","doc":"Tactic for solving equations in the language of\n*additive*, commutative monoids and groups.\nThis version of `abel` fails if the target is not an equality\nthat is provable by the axioms of commutative monoids/groups.\n\n`abel1!` will use a more aggressive reducibility setting to identify atoms.\nThis can prove goals that `abel` cannot, but is more expensive.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">abel1</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L323-L367","name":"Mathlib.Tactic.Abel.eval","line":323,"kind":"opaque","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.eval","doc":"Evaluate an expression into its `abel` normal form, by recursing into subexpressions. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.eval\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">eval</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">Mathlib.Tactic.Abel.M</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L293-L321","name":"Mathlib.Tactic.Abel.evalSMul'","line":293,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalSMul'","doc":"Normalize a term `orig` of the form `smul e₁ e₂` or `smulg e₁ e₂`.\nNormalized terms use `smul` for monoids and `smulg` for groups,\nso there are actually four cases to handle:\n* Using `smul` in a monoid just simplifies the pieces using `subst_into_smul`\n* Using `smulg` in a group just simplifies the pieces using `subst_into_smulg`\n* Using `smul a b` in a group requires converting `a` from a nat to an int and\n  then simplifying `smulg ↑a b` using `subst_into_smul_upcast`\n* Using `smulg` in a monoid is impossible (or at least out of scope),\n  because you need a group argument to write a `smulg` term "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalSMul'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">evalSMul'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(eval : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">Mathlib.Tactic.Abel.M</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(is_smulg : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(orig e₁ e₂ : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">Mathlib.Tactic.Abel.M</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L289-L291","name":"Mathlib.Tactic.Abel.subst_into_negg","line":289,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_negg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_negg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">subst_into_negg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(a ta t : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(pra : <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">ta</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prt : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">ta</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L285-L287","name":"Mathlib.Tactic.Abel.subst_into_addg","line":285,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_addg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_addg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">subst_into_addg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(l r tl tr t : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prl : <span class=\"fn\"><span class=\"fn\">l</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tl</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prr : <span class=\"fn\"><span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tr</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prt : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">tl</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">tr</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">l</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">r</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L281-L283","name":"Mathlib.Tactic.Abel.subst_into_add","line":281,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_add","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_add\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">subst_into_add</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(l r tl tr t : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prl : <span class=\"fn\"><span class=\"fn\">l</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tl</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prr : <span class=\"fn\"><span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tr</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prt : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">tl</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">tr</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">l</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">r</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L276-L279","name":"Mathlib.Tactic.Abel.subst_into_smul_upcast","line":276,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smul_upcast","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smul_upcast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">subst_into_smul_upcast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(l : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(r : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tl : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(zl : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tr t : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prl₁ : <span class=\"fn\"><span class=\"fn\">l</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tl</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prl₂ : <span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">tl</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">zl</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prr : <span class=\"fn\"><span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tr</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prt : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg\">Mathlib.Tactic.Abel.smulg</a> <span class=\"fn\">zl</span> <span class=\"fn\">tr</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul\">Mathlib.Tactic.Abel.smul</a> <span class=\"fn\">l</span> <span class=\"fn\">r</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L272-L274","name":"Mathlib.Tactic.Abel.subst_into_smulg","line":272,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smulg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smulg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">subst_into_smulg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(l : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(r : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tl : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tr t : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prl : <span class=\"fn\"><span class=\"fn\">l</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tl</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prr : <span class=\"fn\"><span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tr</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prt : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg\">Mathlib.Tactic.Abel.smulg</a> <span class=\"fn\">tl</span> <span class=\"fn\">tr</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg\">Mathlib.Tactic.Abel.smulg</a> <span class=\"fn\">l</span> <span class=\"fn\">r</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L268-L270","name":"Mathlib.Tactic.Abel.subst_into_smul","line":268,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smul","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">subst_into_smul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(l : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(r : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tl : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tr t : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prl : <span class=\"fn\"><span class=\"fn\">l</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tl</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prr : <span class=\"fn\"><span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">tr</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prt : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul\">Mathlib.Tactic.Abel.smul</a> <span class=\"fn\">tl</span> <span class=\"fn\">tr</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul\">Mathlib.Tactic.Abel.smul</a> <span class=\"fn\">l</span> <span class=\"fn\">r</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L265-L266","name":"Mathlib.Tactic.Abel.unfold_zsmul","line":265,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_zsmul","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_zsmul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">unfold_zsmul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x y : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg\">Mathlib.Tactic.Abel.smulg</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">n</span> <a href=\"./Mathlib/Algebra/Group/Operations.html#HSMul.hSMul\">•</a> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L262-L263","name":"Mathlib.Tactic.Abel.unfold_smulg","line":262,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_smulg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_smulg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">unfold_smulg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x y : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg\">Mathlib.Tactic.Abel.smulg</a> <span class=\"fn\">(<a href=\"./Init/Data/Int/Basic.html#Int.ofNat\">Int.ofNat</a> <span class=\"fn\">n</span>)</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">n</span></span> <a href=\"./Mathlib/Algebra/Group/Operations.html#HSMul.hSMul\">•</a> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L259-L260","name":"Mathlib.Tactic.Abel.unfold_smul","line":259,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_smul","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_smul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">unfold_smul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x y : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul\">Mathlib.Tactic.Abel.smul</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">n</span> <a href=\"./Mathlib/Algebra/Group/Operations.html#HSMul.hSMul\">•</a> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L256-L257","name":"Mathlib.Tactic.Abel.unfold_sub","line":256,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_sub","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_sub\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">unfold_sub</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#SubtractionMonoid\">SubtractionMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(a b c : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">b</span></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L247-L254","name":"Mathlib.Tactic.Abel.evalAtom","line":247,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalAtom","doc":"Interpret an expression as an atom for `abel`'s normal form. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalAtom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">evalAtom</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">Mathlib.Tactic.Abel.M</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L244-L245","name":"Mathlib.Tactic.Abel.term_atom_pfg","line":244,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atom_pfg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atom_pfg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_atom_pfg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x x' : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">x'</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">Mathlib.Tactic.Abel.termg</a> <span class=\"fn\">1</span> <span class=\"fn\">x'</span> <span class=\"fn\">0</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L242-L243","name":"Mathlib.Tactic.Abel.term_atom_pf","line":242,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atom_pf","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atom_pf\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_atom_pf</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x x' : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">x'</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">Mathlib.Tactic.Abel.term</a> <span class=\"fn\">1</span> <span class=\"fn\">x'</span> <span class=\"fn\">0</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L241-L241","name":"Mathlib.Tactic.Abel.term_atomg","line":241,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atomg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atomg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_atomg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">Mathlib.Tactic.Abel.termg</a> <span class=\"fn\">1</span> <span class=\"fn\">x</span> <span class=\"fn\">0</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L240-L240","name":"Mathlib.Tactic.Abel.term_atom","line":240,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atom","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_atom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">Mathlib.Tactic.Abel.term</a> <span class=\"fn\">1</span> <span class=\"fn\">x</span> <span class=\"fn\">0</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L229-L238","name":"Mathlib.Tactic.Abel.evalSMul","line":229,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalSMul","doc":"Auxiliary function for `evalSMul'`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalSMul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">evalSMul</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">Mathlib.Tactic.Abel.M</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L224-L227","name":"Mathlib.Tactic.Abel.term_smulg","line":224,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_smulg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_smulg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_smulg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(c n : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(n' : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a' : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h₁ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">c</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">n'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h₂ : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg\">Mathlib.Tactic.Abel.smulg</a> <span class=\"fn\">c</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg\">Mathlib.Tactic.Abel.smulg</a> <span class=\"fn\">c</span> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">Mathlib.Tactic.Abel.termg</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">Mathlib.Tactic.Abel.termg</a> <span class=\"fn\">n'</span> <span class=\"fn\">x</span> <span class=\"fn\">a'</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L219-L222","name":"Mathlib.Tactic.Abel.term_smul","line":219,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_smul","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_smul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_smul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(c n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(n' : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a' : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h₁ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">c</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">n'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h₂ : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul\">Mathlib.Tactic.Abel.smul</a> <span class=\"fn\">c</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul\">Mathlib.Tactic.Abel.smul</a> <span class=\"fn\">c</span> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">Mathlib.Tactic.Abel.term</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">Mathlib.Tactic.Abel.term</a> <span class=\"fn\">n'</span> <span class=\"fn\">x</span> <span class=\"fn\">a'</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L216-L217","name":"Mathlib.Tactic.Abel.zero_smulg","line":216,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_smulg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_smulg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">zero_smulg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg\">Mathlib.Tactic.Abel.smulg</a> <span class=\"fn\">c</span> <span class=\"fn\">0</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L213-L214","name":"Mathlib.Tactic.Abel.zero_smul","line":213,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_smul","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_smul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">zero_smul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul\">Mathlib.Tactic.Abel.smul</a> <span class=\"fn\">c</span> <span class=\"fn\">0</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L210-L211","name":"Mathlib.Tactic.Abel.smulg","line":210,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg","doc":"A synonym for `•`, used internally in `abel`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">smulg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">α</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L208-L209","name":"Mathlib.Tactic.Abel.smul","line":208,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul","doc":"A synonym for `•`, used internally in `abel`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">smul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">α</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L195-L206","name":"Mathlib.Tactic.Abel.evalNeg","line":195,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalNeg","doc":"Interpret a negated expression in `abel`'s normal form.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalNeg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">evalNeg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">Mathlib.Tactic.Abel.M</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L191-L193","name":"Mathlib.Tactic.Abel.term_neg","line":191,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_neg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_neg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_neg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(n' : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a' : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h₁ : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">n'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h₂ : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">Mathlib.Tactic.Abel.termg</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">Mathlib.Tactic.Abel.termg</a> <span class=\"fn\">n'</span> <span class=\"fn\">x</span> <span class=\"fn\">a'</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L163-L189","name":"Mathlib.Tactic.Abel.evalAdd","line":163,"kind":"opaque","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalAdd","doc":"Interpret the sum of two expressions in `abel`'s normal form.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalAdd\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">evalAdd</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a> →\n  <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">Mathlib.Tactic.Abel.M</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L160-L161","name":"Mathlib.Tactic.Abel.zero_termg","line":160,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_termg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_termg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">zero_termg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">Mathlib.Tactic.Abel.termg</a> <span class=\"fn\">0</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L157-L158","name":"Mathlib.Tactic.Abel.zero_term","line":157,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_term","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_term\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">zero_term</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">Mathlib.Tactic.Abel.term</a> <span class=\"fn\">0</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L151-L155","name":"Mathlib.Tactic.Abel.term_add_termg","line":151,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_termg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_termg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_add_termg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(n₁ : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x a₁ : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(n₂ : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a₂ : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(n' : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a' : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h₁ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">n₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">n₂</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">n'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h₂ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a₂</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">Mathlib.Tactic.Abel.termg</a> <span class=\"fn\">n₁</span> <span class=\"fn\">x</span> <span class=\"fn\">a₁</span></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">Mathlib.Tactic.Abel.termg</a> <span class=\"fn\">n₂</span> <span class=\"fn\">x</span> <span class=\"fn\">a₂</span></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">Mathlib.Tactic.Abel.termg</a> <span class=\"fn\">n'</span> <span class=\"fn\">x</span> <span class=\"fn\">a'</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L147-L149","name":"Mathlib.Tactic.Abel.term_add_term","line":147,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_term","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_term\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_add_term</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(n₁ : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x a₁ : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(n₂ : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a₂ : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(n' : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a' : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h₁ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">n₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">n₂</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">n'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h₂ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a₂</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">Mathlib.Tactic.Abel.term</a> <span class=\"fn\">n₁</span> <span class=\"fn\">x</span> <span class=\"fn\">a₁</span></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">Mathlib.Tactic.Abel.term</a> <span class=\"fn\">n₂</span> <span class=\"fn\">x</span> <span class=\"fn\">a₂</span></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">Mathlib.Tactic.Abel.term</a> <span class=\"fn\">n'</span> <span class=\"fn\">x</span> <span class=\"fn\">a'</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L143-L145","name":"Mathlib.Tactic.Abel.term_add_constg","line":143,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_constg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_constg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_add_constg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x a k a' : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">Mathlib.Tactic.Abel.termg</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">Mathlib.Tactic.Abel.termg</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a'</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L139-L141","name":"Mathlib.Tactic.Abel.term_add_const","line":139,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_const","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_const\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term_add_const</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x a k a' : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">Mathlib.Tactic.Abel.term</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">Mathlib.Tactic.Abel.term</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a'</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L135-L137","name":"Mathlib.Tactic.Abel.const_add_termg","line":135,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.const_add_termg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.const_add_termg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">const_add_termg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x a a' : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">Mathlib.Tactic.Abel.termg</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\">Mathlib.Tactic.Abel.termg</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a'</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L131-L133","name":"Mathlib.Tactic.Abel.const_add_term","line":131,"kind":"theorem","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.const_add_term","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.const_add_term\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">const_add_term</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x a a' : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">Mathlib.Tactic.Abel.term</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\">Mathlib.Tactic.Abel.term</a> <span class=\"fn\">n</span> <span class=\"fn\">x</span> <span class=\"fn\">a'</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L126-L127","name":"Mathlib.Tactic.Abel.NormalExpr.zero'","line":126,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.zero'","doc":"Construct the normal form representing zero. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.zero'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">NormalExpr</span>.<span class=\"name\">zero'</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">Mathlib.Tactic.Abel.M</a> <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L122-L124","name":"Mathlib.Tactic.Abel.NormalExpr.term'","line":122,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.term'","doc":"Construct the normal form representing a single term. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.term'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">NormalExpr</span>.<span class=\"name\">term'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(n : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">Mathlib.Tactic.Abel.M</a> <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L120-L120","name":"Mathlib.Tactic.Abel.instCoeNormalExprExpr","line":120,"kind":"instance","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.instCoeNormalExprExpr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.instCoeNormalExprExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">instCoeNormalExprExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#Coe\">Coe</a> <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L115-L118","name":"Mathlib.Tactic.Abel.NormalExpr.e","line":115,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.e","doc":"Extract the expression from a normal form. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.e\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">NormalExpr</span>.<span class=\"name\">e</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L113-L113","name":"Mathlib.Tactic.Abel.instInhabitedNormalExpr","line":113,"kind":"instance","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.instInhabitedNormalExpr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.instInhabitedNormalExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">instInhabitedNormalExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L112-L112","name":"Mathlib.Tactic.Abel.NormalExpr.nterm","line":112,"kind":"ctor","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.nterm","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.nterm\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">NormalExpr</span>.<span class=\"name\">nterm</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(n : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L111-L111","name":"Mathlib.Tactic.Abel.NormalExpr.zero","line":111,"kind":"ctor","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.zero","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.zero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">NormalExpr</span>.<span class=\"name\">zero</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\">Mathlib.Tactic.Abel.NormalExpr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L105-L113","name":"Mathlib.Tactic.Abel.NormalExpr","line":105,"kind":"inductive","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr","doc":"A normal form for `abel`.\nExpressions are represented as a list of terms of the form `e = n • x`,\nwhere `n : ℤ` and `x` is an arbitrary element of the additive commutative monoid or group.\nWe explicitly track the `Expr` forms of `e` and `n`, even though they could be reconstructed,\nfor efficiency. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">NormalExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L101-L103","name":"Mathlib.Tactic.Abel.intToExpr","line":101,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.intToExpr","doc":"Interpret an integer as a coefficient to a term. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.intToExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">intToExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">Mathlib.Tactic.Abel.M</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L98-L99","name":"Mathlib.Tactic.Abel.mkTerm","line":98,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.mkTerm","doc":"Evaluate a term with coefficient `n`, atom `x` and successor terms `a`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.mkTerm\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">mkTerm</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(n x a : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">Mathlib.Tactic.Abel.M</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L95-L96","name":"Mathlib.Tactic.Abel.termg","line":95,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg","doc":"A type synonym used by `abel` to represent `n • x + a` in an additive commutative group. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">termg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommGroup\">AddCommGroup</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">α</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L93-L94","name":"Mathlib.Tactic.Abel.term","line":93,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term","doc":"A type synonym used by `abel` to represent `n • x + a` in an additive commutative monoid. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">term</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddCommMonoid\">AddCommMonoid</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">α</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L85-L91","name":"Mathlib.Tactic.Abel.iapp","line":85,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.iapp","doc":"Apply the function `n : ∀ {α} [AddComm{Monoid,Group} α]` to the given list of arguments.\n\nWill use the `AddComm{Monoid,Group}` instance that has been cached in the context.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.iapp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">iapp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(xs : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\">Mathlib.Tactic.Abel.M</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L76-L83","name":"Mathlib.Tactic.Abel.addG","line":76,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.addG","doc":"Add the letter \"g\" to the end of the name, e.g. turning `term` into `termg`.\n\nThis is used to choose between declarations taking `AddCommMonoid` and those\ntaking `AddCommGroup` instances.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.addG\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">addG</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L67-L74","name":"Mathlib.Tactic.Abel.Context.mkApp","line":67,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.mkApp","doc":"Apply the function `n : ∀ {α} [inst α], _` to the implicit parameters in the\ncontext, and the given list of arguments.\n\nCompared to `context.app`, this takes the name of the typeclass, rather than an\ninferred typeclass instance.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.mkApp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">Context</span>.<span class=\"name\">mkApp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\">Mathlib.Tactic.Abel.Context</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(n inst : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(l : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L62-L65","name":"Mathlib.Tactic.Abel.Context.app","line":62,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.app","doc":"Apply the function `n : ∀ {α} [inst : AddWhatever α], _` to the\nimplicit parameters in the context, and the given list of arguments. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.app\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">Context</span>.<span class=\"name\">app</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\">Mathlib.Tactic.Abel.Context</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(inst : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L57-L60","name":"Mathlib.Tactic.Abel.M","line":57,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M","doc":"The monad for `Abel` contains, in addition to the `AtomM` state,\nsome information about the current type we are working over, so that we can consistently\nuse group lemmas or monoid lemmas as appropriate. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">M</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(α : <a href=\"./foundational_types.html\">Type</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L45-L55","name":"Mathlib.Tactic.Abel.mkContext","line":45,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.mkContext","doc":"Populate a `context` object for evaluating `e`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.mkContext\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">mkContext</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\">Mathlib.Tactic.Abel.Context</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L43-L43","name":"Mathlib.Tactic.Abel.Context.inst","line":43,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.inst","doc":"The `AddCommGroup α` or `AddCommMonoid α` expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.inst\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">Context</span>.<span class=\"name\">inst</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\">Mathlib.Tactic.Abel.Context</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L41-L41","name":"Mathlib.Tactic.Abel.Context.isGroup","line":41,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.isGroup","doc":"Specify whether we are in an additive commutative group or an additive commutative monoid. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.isGroup\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">Context</span>.<span class=\"name\">isGroup</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\">Mathlib.Tactic.Abel.Context</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L39-L39","name":"Mathlib.Tactic.Abel.Context.α0","line":39,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.α0","doc":"The expression representing `0 : α`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.α0\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">Context</span>.<span class=\"name\">α0</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\">Mathlib.Tactic.Abel.Context</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L37-L37","name":"Mathlib.Tactic.Abel.Context.univ","line":37,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.univ","doc":"The universe level for `α`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.univ\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">Context</span>.<span class=\"name\">univ</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\">Mathlib.Tactic.Abel.Context</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L35-L35","name":"Mathlib.Tactic.Abel.Context.α","line":35,"kind":"def","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.α","doc":"The type of the ambient additive commutative group or monoid. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.α\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">Context</span>.<span class=\"name\">α</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\">Mathlib.Tactic.Abel.Context</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L33-L33","name":"Mathlib.Tactic.Abel.Context.mk","line":33,"kind":"ctor","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">Context</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(α : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(univ : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(α0 : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(isGroup : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(inst : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\">Mathlib.Tactic.Abel.Context</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Abel.lean#L28-L43","name":"Mathlib.Tactic.Abel.Context","line":28,"kind":"structure","docLink":"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context","doc":"The `Context` for a call to `abel`.\n\nStores a few options for this call, and caches some common subexpressions\nsuch as typeclass instances and `0 : α`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Abel</span>.<span class=\"name\">Context</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"}]}