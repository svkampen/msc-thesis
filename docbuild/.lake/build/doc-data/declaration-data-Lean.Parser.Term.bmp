{"name":"Lean.Parser.Term","instances":[{"typeNames":["Lean.TSyntax","Lean.TSyntax"],"name":"Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean","className":"Coe"},{"typeNames":["Lean.TSyntax","Lean.TSyntax"],"name":"Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean_1","className":"Coe"}],"imports":["Lean.Parser.Attr","Lean.Parser.Level"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L972-L973","name":"Lean.Parser.Tactic.quotSeq","line":972,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.quotSeq","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.quotSeq\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">quotSeq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L970-L971","name":"Lean.Parser.Tactic.quot","line":970,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.quot","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.quot\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">quot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L965-L966","name":"Lean.Parser.Term.letExpr","line":965,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letExpr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letExpr\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L962-L963","name":"Lean.Parser.Term.matchExpr","line":962,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchExpr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.matchExpr\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">matchExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L958-L961","name":"Lean.Parser.Term.matchExprAlts","line":958,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchExprAlts","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.matchExprAlts\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">matchExprAlts</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(rhsParser : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L957-L957","name":"Lean.Parser.Term.matchExprElseAlt","line":957,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchExprElseAlt","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.matchExprElseAlt\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">matchExprElseAlt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(rhsParser : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L956-L956","name":"Lean.Parser.Term.matchExprAlt","line":956,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchExprAlt","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.matchExprAlt\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">matchExprAlt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(rhsParser : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L955-L955","name":"Lean.Parser.Term.matchExprPat","line":955,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchExprPat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.matchExprPat\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">matchExprPat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L945-L949","name":"Lean.Parser.Term.showTermElabImpl","line":945,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.showTermElabImpl","doc":"Implementation of the `show_term` term elaborator.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.showTermElabImpl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">showTermElabImpl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L942-L943","name":"Lean.Parser.Term.dotIdent","line":942,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.dotIdent","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.dotIdent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">dotIdent</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L939-L940","name":"Lean.Parser.Term.dynamicQuot","line":939,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.dynamicQuot","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.dynamicQuot\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">dynamicQuot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L936-L937","name":"Lean.Parser.Term.stateRefT","line":936,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.stateRefT","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.stateRefT\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">stateRefT</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L933-L933","name":"Lean.Parser.Term.macroLastArg","line":933,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.macroLastArg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.macroLastArg\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">macroLastArg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L932-L932","name":"Lean.Parser.Term.macroDollarArg","line":932,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.macroDollarArg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.macroDollarArg\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">macroDollarArg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L931-L931","name":"Lean.Parser.Term.macroArg","line":931,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.macroArg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.macroArg\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">macroArg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L927-L929","name":"Lean.Parser.Term.assert","line":927,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.assert","doc":"`assert! cond` panics if `cond` evaluates to `false`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.assert\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">assert</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L920-L926","name":"Lean.Parser.Term.dbgTrace","line":920,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.dbgTrace","doc":"`dbg_trace e; body` evaluates to `body` and prints `e` (which can be an\ninterpolated string literal) to stderr. It should only be used for debugging.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.dbgTrace\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">dbgTrace</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L917-L919","name":"Lean.Parser.Term.unreachable","line":917,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.unreachable","doc":"A shorthand for `panic! \"unreachable code has been reached\"`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.unreachable\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">unreachable</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L907-L916","name":"Lean.Parser.Term.panic","line":907,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.panic","doc":"`panic! msg` formally evaluates to `@Inhabited.default α` if the expected type\n`α` implements `Inhabited`.\nAt runtime, `msg` and the file position are printed to stderr unless the C\nfunction `lean_set_panic_messages(false)` has been executed before. If the C\nfunction `lean_set_exit_on_panic(true)` has been executed before, the process is\nthen aborted.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.panic\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">panic</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L905-L905","name":"Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean_1","line":905,"kind":"instance","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean_1","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean_1\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean_1</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#Coe\">Coe</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Term.bracketedBinderF</span>)</span> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Term.bracketedBinder</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L904-L904","name":"Lean.Parser.Term.bracketedBinderF","line":904,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinderF","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinderF\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">bracketedBinderF</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L889-L902","name":"Lean.Parser.Term.subst","line":889,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.subst","doc":"`h ▸ e` is a macro built on top of `Eq.rec` and `Eq.symm` definitions.\nGiven `h : a = b` and `e : p a`, the term `h ▸ e` has type `p b`.\nYou can also view `h ▸ e` as a \"type casting\" operation\nwhere you change the type of `e` by using `h`.\n\nThe macro tries both orientations of `h`. If the context provides an\nexpected type, it rewrites the expected type, else it rewrites the type of e`.\n\nSee the Chapter \"Quantifiers and Equality\" in the manual\n\"Theorem Proving in Lean\" for additional information.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.subst\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">subst</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">Lean.Parser.TrailingParser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L886-L887","name":"Lean.Parser.Term.pipeCompletion","line":886,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.pipeCompletion","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.pipeCompletion\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">pipeCompletion</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">Lean.Parser.TrailingParser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L880-L885","name":"Lean.Parser.Term.pipeProj","line":880,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.pipeProj","doc":"`e |>.x` is a shorthand for `(e).x`.\nIt is especially useful for avoiding parentheses with repeated applications.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.pipeProj\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">pipeProj</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">Lean.Parser.TrailingParser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L873-L878","name":"Lean.Parser.Term.namedPattern","line":873,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.namedPattern","doc":"`x@e` or `x@h:e` matches the pattern `e` and binds its value to the identifier `x`.\nIf present, the identifier `h` is bound to a proof of `x = e`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.namedPattern\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">namedPattern</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">Lean.Parser.TrailingParser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L868-L872","name":"Lean.Parser.Term.explicitUniv","line":868,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.explicitUniv","doc":"`x.{u, ...}` explicitly specifies the universes `u, ...` of the constant `x`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.explicitUniv\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">explicitUniv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">Lean.Parser.TrailingParser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L864-L866","name":"Lean.Parser.Term.isIdent","line":864,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.isIdent","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.isIdent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">isIdent</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(stx : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L853-L862","name":"Lean.Parser.Term.identProjKind","line":853,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.identProjKind","doc":"Syntax kind for syntax nodes representing the field of a projection in the `InfoTree`.\nSpecifically, the `InfoTree` node for a projection `s.f` contains a child `InfoTree` node\nwith syntax ``(Syntax.node .none identProjKind #[`f])``.\n\nThis is necessary because projection syntax cannot always be detected purely syntactically\n(`s.f` may refer to either the identifier `s.f` or a projection `s.f` depending on\nthe available context).\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.identProjKind\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">identProjKind</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L850-L851","name":"Lean.Parser.Term.arrow","line":850,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.arrow","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.arrow\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">arrow</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">Lean.Parser.TrailingParser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L848-L849","name":"Lean.Parser.Term.completion","line":848,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.completion","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.completion\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">completion</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">Lean.Parser.TrailingParser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L834-L847","name":"Lean.Parser.Term.proj","line":834,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.proj","doc":"The *extended field notation* `e.f` is roughly short for `T.f e` where `T` is the type of `e`.\nMore precisely,\n* if `e` is of a function type, `e.f` is translated to `Function.f (p := e)`\n  where `p` is the first explicit parameter of function type\n* if `e` is of a named type `T ...` and there is a declaration `T.f` (possibly from `export`),\n  `e.f` is translated to `T.f (p := e)` where `p` is the first explicit parameter of type `T ...`\n* otherwise, if `e` is of a structure type,\n  the above is repeated for every base type of the structure.\n\nThe field index notation `e.i`, where `i` is a positive number,\nis short for accessing the `i`-th field (1-indexed) of `e` if it is of a structure type. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.proj\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">proj</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">Lean.Parser.TrailingParser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L832-L832","name":"Lean.Parser.Term.app","line":832,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.app\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">app</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">Lean.Parser.TrailingParser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L825-L828","name":"Lean.Parser.Term.argument","line":825,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.argument","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.argument\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">argument</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L822-L824","name":"Lean.Parser.Term.ellipsis","line":822,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.ellipsis","doc":"In a function application, `..` notation inserts zero or more `_` placeholders. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.ellipsis\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">ellipsis</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L820-L821","name":"Lean.Parser.Term.namedArgument","line":820,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.namedArgument","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.namedArgument\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">namedArgument</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L813-L818","name":"Lean.Parser.Term.noErrorIfUnused","line":813,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.noErrorIfUnused","doc":"Helper parser for marking `match`-alternatives that should not trigger errors if unused.\nWe use them to implement `macro_rules` and `elab_rules`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.noErrorIfUnused\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">noErrorIfUnused</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L810-L811","name":"Lean.Parser.Term.defaultOrOfNonempty","line":810,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.defaultOrOfNonempty","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.defaultOrOfNonempty\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">defaultOrOfNonempty</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L807-L808","name":"Lean.Parser.Term.waitIfContainsMVar","line":807,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfContainsMVar","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfContainsMVar\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">waitIfContainsMVar</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L805-L806","name":"Lean.Parser.Term.waitIfTypeContainsMVar","line":805,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfTypeContainsMVar","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfTypeContainsMVar\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">waitIfTypeContainsMVar</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L803-L804","name":"Lean.Parser.Term.waitIfTypeMVar","line":803,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfTypeMVar","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfTypeMVar\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">waitIfTypeMVar</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L801-L802","name":"Lean.Parser.Term.letMVar","line":801,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letMVar","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letMVar\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letMVar</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L794-L799","name":"Lean.Parser.Term.clear","line":794,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.clear","doc":"`clear% x; e` elaborates `x` after clearing the free variable `x` from the local context.\nIf `x` cannot be cleared (due to dependencies), it will keep `x` without failing.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.clear\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">clear</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L791-L792","name":"Lean.Parser.Term.noImplicitLambda","line":791,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.noImplicitLambda","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.noImplicitLambda\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">noImplicitLambda</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L789-L790","name":"Lean.Parser.Term.ensureExpectedType","line":789,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.ensureExpectedType","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.ensureExpectedType\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">ensureExpectedType</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L787-L788","name":"Lean.Parser.Term.ensureTypeOf","line":787,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.ensureTypeOf","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.ensureTypeOf\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">ensureTypeOf</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L785-L786","name":"Lean.Parser.Term.typeOf","line":785,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.typeOf","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.typeOf\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">typeOf</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L777-L784","name":"Lean.Parser.Term.withDeclName","line":777,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.withDeclName","doc":"* `with_decl_name% id e` elaborates `e` in a context while changing the effective\n  declaration name to `id`.\n* `with_decl_name% ?id e` does the same, but resolves `id` as a new definition name\n  (appending the current namespaces).\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.withDeclName\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">withDeclName</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L774-L775","name":"Lean.Parser.Term.declName","line":774,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.declName","doc":"A macro which evaluates to the name of the currently elaborating declaration. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.declName\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">declName</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L771-L772","name":"Lean.Parser.Term.forInMacro'","line":771,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.forInMacro'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.forInMacro'\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">forInMacro'</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L769-L770","name":"Lean.Parser.Term.forInMacro","line":769,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.forInMacro","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.forInMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">forInMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L765-L767","name":"Lean.Parser.Term.unop","line":765,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.unop","doc":"`unop% f a` elaborates `f a` as a unary operation using the type propagation protocol in `Lean.Elab.Extra`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.unop\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">unop</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L761-L764","name":"Lean.Parser.Term.rightact","line":761,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.rightact","doc":"`rightact% f a b` elaborates `f a b` as a right action using the type propagation protocol in `Lean.Elab.Extra`.\nIn particular, it is like a unary operation with a fixed parameter `b`, where only the left argument `a` participates in the operator coercion elaborator. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.rightact\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">rightact</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L757-L760","name":"Lean.Parser.Term.leftact","line":757,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.leftact","doc":"`leftact% f a b` elaborates `f a b` as a left action using the type propagation protocol in `Lean.Elab.Extra`.\nIn particular, it is like a unary operation with a fixed parameter `a`, where only the right argument `b` participates in the operator coercion elaborator. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.leftact\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">leftact</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L754-L756","name":"Lean.Parser.Term.binop_lazy","line":754,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binop_lazy","doc":"`binop_lazy%` is similar to `binop% f a b`, but it wraps `b` as a function from `Unit`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binop_lazy\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binop_lazy</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L751-L753","name":"Lean.Parser.Term.binop","line":751,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binop","doc":"`binop% f a b` elaborates `f a b` as a binary operation using the type propagation protocol in `Lean.Elab.Extra`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binop\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binop</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L748-L750","name":"Lean.Parser.Term.binrel_no_prop","line":748,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binrel_no_prop","doc":"`binrel_no_prop% r a b` is similar to `binrel% r a b`, but it coerces `Prop` arguments into `Bool`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binrel_no_prop\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binrel_no_prop</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L745-L747","name":"Lean.Parser.Term.binrel","line":745,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binrel","doc":"`binrel% r a b` elaborates `r a b` as a binary relation using the type propagation protocol in `Lean.Elab.Extra`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binrel\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binrel</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L732-L743","name":"Lean.Parser.Term.unsafe","line":732,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.unsafe","doc":"`unsafe t : α` is an expression constructor which allows using unsafe declarations inside the\nbody of `t : α`, by creating an auxiliary definition containing `t` and using `implementedBy` to\nwrap it in a safe interface. It is required that `α` is nonempty for this to be sound,\nbut even beyond that, an `unsafe` block should be carefully inspected for memory safety because\nthe compiler is unable to guarantee the safety of the operation.\n\nFor example, the `evalExpr` function is unsafe, because the compiler cannot guarantee that when\nyou call ```evalExpr Foo ``Foo e``` that the type `Foo` corresponds to the name `Foo`, but in a\nparticular use case, we can ensure this, so `unsafe (evalExpr Foo ``Foo e)` is a correct usage.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.unsafe\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">unsafe</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L729-L730","name":"Lean.Parser.Term.noindex","line":729,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.noindex","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.noindex\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">noindex</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L725-L727","name":"Lean.Parser.Term.matchAltsWhereDecls","line":725,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchAltsWhereDecls","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.matchAltsWhereDecls\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">matchAltsWhereDecls</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L721-L723","name":"Lean.Parser.Term.whereDecls","line":721,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.whereDecls","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.whereDecls\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">whereDecls</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L716-L719","name":"Lean.Parser.Term.letrec","line":716,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letrec","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letrec\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letrec</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L712-L715","name":"Lean.Parser.Term.letRecDecls","line":712,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letRecDecls","doc":"`letRecDecls` matches `letRecDecl,+`, a comma-separated list of let-rec declarations (see `letRecDecl`). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letRecDecls\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letRecDecls</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L708-L711","name":"Lean.Parser.Term.letRecDecl","line":708,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letRecDecl","doc":"`letRecDecl` matches the body of a let-rec declaration: a doc comment, attributes, and then\na let declaration without the `let` keyword, such as `/-- foo -/ @[simp] bar := 1`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letRecDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letRecDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L699-L703","name":"Lean.Parser.Termination.suffix","line":699,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Termination.suffix","doc":"Termination hints are `termination_by` and `decreasing_by`, in that order.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Termination.suffix\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Termination</span>.<span class=\"name\">suffix</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L687-L697","name":"Lean.Parser.Termination.decreasingBy","line":687,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Termination.decreasingBy","doc":"Manually prove that the termination argument (as specified with `termination_by` or inferred)\ndecreases at each recursive call.\n\nBy default, the tactic `decreasing_tactic` is used.\n\nForces the use of well-founded recursion and is hence incompatible with\n`termination_by structural`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Termination.decreasingBy\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Termination</span>.<span class=\"name\">decreasingBy</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L683-L685","name":"Lean.Parser.Termination.terminationBy?","line":683,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Termination.terminationBy?","doc":"Specify a termination argument for recursive functions.\n```\ntermination_by a - b\n```\nindicates that termination of the currently defined recursive function follows\nbecause the difference between the arguments `a` and `b` decreases.\n\nIf the function takes further argument after the colon, you can name them as follows:\n```\ndef example (a : Nat) : Nat → Nat → Nat :=\ntermination_by b c => a - b\n```\n\nBy default, a `termination_by` clause will cause the function to be constructed using well-founded\nrecursion. The syntax `termination_by structural a` (or `termination_by structural _ c => c`)\nindicates the function is expected to be structural recursive on the argument. In this case\nthe body of the `termination_by` clause must be one of the function's parameters.\n\nIf omitted, a termination argument will be inferred. If written as `termination_by?`,\nthe inferrred termination argument will be suggested.\n\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Termination.terminationBy?\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Termination</span>.<span class=\"name\">terminationBy?</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L654-L681","name":"Lean.Parser.Termination.terminationBy","line":654,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Termination.terminationBy","doc":"Specify a termination argument for recursive functions.\n```\ntermination_by a - b\n```\nindicates that termination of the currently defined recursive function follows\nbecause the difference between the arguments `a` and `b` decreases.\n\nIf the function takes further argument after the colon, you can name them as follows:\n```\ndef example (a : Nat) : Nat → Nat → Nat :=\ntermination_by b c => a - b\n```\n\nBy default, a `termination_by` clause will cause the function to be constructed using well-founded\nrecursion. The syntax `termination_by structural a` (or `termination_by structural _ c => c`)\nindicates the function is expected to be structural recursive on the argument. In this case\nthe body of the `termination_by` clause must be one of the function's parameters.\n\nIf omitted, a termination argument will be inferred. If written as `termination_by?`,\nthe inferrred termination argument will be suggested.\n\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Termination.terminationBy\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Termination</span>.<span class=\"name\">terminationBy</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L643-L644","name":"Lean.Parser.Term.attributes","line":643,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.attributes","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.attributes\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">attributes</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L641-L641","name":"Lean.Parser.Term.attrInstance","line":641,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.attrInstance","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.attrInstance\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">attrInstance</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L639-L640","name":"Lean.Parser.Term.attrKind","line":639,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.attrKind","doc":"`attrKind` matches `(\"scoped\" <|> \"local\")?`, used before an attribute like `@[local simp]`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.attrKind\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">attrKind</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L638-L638","name":"Lean.Parser.Term.local","line":638,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.local","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.local\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">local</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L637-L637","name":"Lean.Parser.Term.scoped","line":637,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.scoped","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.scoped\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">scoped</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L633-L635","name":"Lean.Parser.Term.letI","line":633,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letI","doc":"`letI` behaves like `let`, but inlines the value instead of producing a `let_fun` term. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letI\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letI</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L630-L632","name":"Lean.Parser.Term.haveI","line":630,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.haveI","doc":"`haveI` behaves like `have`, but inlines the value instead of producing a `let_fun` term. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.haveI\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">haveI</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L628-L629","name":"Lean.Parser.Term.have","line":628,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.have","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.have\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">have</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L623-L627","name":"Lean.Parser.Term.haveDecl","line":623,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.haveDecl","doc":"`haveDecl` matches the body of a have declaration: `have := e`, `have f x1 x2 := e`,\n`have pat := e` (where `pat` is an arbitrary term) or `have f | pat1 => e1 | pat2 => e2 ...`\n(a pattern matching declaration), except for the `have` keyword itself. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.haveDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">haveDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L621-L622","name":"Lean.Parser.Term.haveEqnsDecl","line":621,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.haveEqnsDecl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.haveEqnsDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">haveEqnsDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L619-L620","name":"Lean.Parser.Term.haveIdDecl","line":619,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.haveIdDecl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.haveIdDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">haveIdDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L617-L618","name":"Lean.Parser.Term.haveIdLhs","line":617,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.haveIdLhs","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.haveIdLhs\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">haveIdLhs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L614-L615","name":"Lean.Parser.Term.haveId","line":614,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.haveId","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.haveId\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">haveId</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L607-L612","name":"Lean.Parser.Term.let_tmp","line":607,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.let_tmp","doc":"`let`-declaration that is only included in the elaborated term if variable is still there.\nIt is often used when building macros.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.let_tmp\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">let_tmp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L602-L606","name":"Lean.Parser.Term.let_delayed","line":602,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.let_delayed","doc":"`let_delayed x := v; b` is similar to `let x := v; b`, but `b` is elaborated before `v`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.let_delayed\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">let_delayed</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L595-L601","name":"Lean.Parser.Term.let_fun","line":595,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.let_fun","doc":"`let_fun x := v; b` is syntax sugar for `(fun x => b) v`.\nIt is very similar to `let x := v; b`, but they are not equivalent.\nIn `let_fun`, the value `v` has been abstracted away and cannot be accessed in `b`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.let_fun\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">let_fun</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L572-L594","name":"Lean.Parser.Term.let","line":572,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.let","doc":"`let` is used to declare a local definition. Example:\n```\nlet x := 1\nlet y := x + 1\nx + y\n```\nSince functions are first class citizens in Lean, you can use `let` to declare\nlocal functions too.\n```\nlet double := fun x => 2*x\ndouble (double 3)\n```\nFor recursive definitions, you should use `let rec`.\nYou can also perform pattern matching using `let`. For example,\nassume `p` has type `Nat × Nat`, then you can write\n```\nlet (x, y) := p\nx + y\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.let\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">let</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L563-L571","name":"Lean.Parser.Term.letDecl","line":563,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letDecl","doc":"`letDecl` matches the body of a let declaration `let f x1 x2 := e`,\n`let pat := e` (where `pat` is an arbitrary term) or `let f | pat1 => e1 | pat2 => e2 ...`\n(a pattern matching declaration), except for the `let` keyword itself.\n`let rec` declarations are not handled here. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L561-L562","name":"Lean.Parser.Term.letEqnsDecl","line":561,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letEqnsDecl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letEqnsDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letEqnsDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L543-L544","name":"Lean.Parser.Term.letPatDecl","line":543,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letPatDecl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letPatDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letPatDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L541-L542","name":"Lean.Parser.Term.letIdDecl","line":541,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letIdDecl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letIdDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letIdDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L537-L540","name":"Lean.Parser.Term.letIdLhs","line":537,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letIdLhs","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letIdLhs\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letIdLhs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L533-L535","name":"Lean.Parser.Term.letIdBinder","line":533,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letIdBinder","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letIdBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letIdBinder</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L524-L531","name":"Lean.Parser.Term.doubleQuotedName","line":524,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.doubleQuotedName","doc":"A resolved name literal. Evaluates to the full name of the given constant if\nexistent in the current context, or else fails.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.doubleQuotedName\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">doubleQuotedName</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L522-L523","name":"Lean.Parser.Term.quotedName","line":522,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.quotedName","doc":"A literal of type `Name`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.quotedName\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">quotedName</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L511-L521","name":"Lean.Parser.Term.borrowed","line":511,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.borrowed","doc":"Indicates that an argument to a function marked `@[extern]` is borrowed.\n\nBeing borrowed only affects the ABI and runtime behavior of the function when compiled or interpreted. From the perspective of Lean's type system, this annotation has no effect. It similarly has no effect on functions not marked `@[extern]`.\n\nWhen a function argument is borrowed, the function does not consume the value. This means that the function will not decrement the value's reference count or deallocate it, and the caller is responsible for doing so.\n\nPlease see https://lean-lang.org/lean4/doc/dev/ffi.html#borrowing for a complete description.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.borrowed\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">borrowed</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L508-L509","name":"Lean.Parser.Term.trailing_parser","line":508,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.trailing_parser","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.trailing_parser\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">trailing_parser</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L506-L507","name":"Lean.Parser.Term.leading_parser","line":506,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.leading_parser","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.leading_parser\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">leading_parser</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L503-L505","name":"Lean.Parser.Term.withAnonymousAntiquot","line":503,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.withAnonymousAntiquot","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.withAnonymousAntiquot\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">withAnonymousAntiquot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L502-L502","name":"Lean.Parser.Term.optExprPrecedence","line":502,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optExprPrecedence","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.optExprPrecedence\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">optExprPrecedence</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L499-L500","name":"Lean.Parser.Term.fun","line":499,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.fun","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.fun\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">fun</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L497-L498","name":"Lean.Parser.Term.basicFun","line":497,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.basicFun","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.basicFun\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">basicFun</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L492-L494","name":"Lean.Parser.Term.funBinder","line":492,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.funBinder","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.funBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">funBinder</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L487-L491","name":"Lean.Parser.Term.funStrictImplicitBinder","line":487,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.funStrictImplicitBinder","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.funStrictImplicitBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">funStrictImplicitBinder</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L485-L486","name":"Lean.Parser.Term.funImplicitBinder","line":485,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.funImplicitBinder","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.funImplicitBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">funImplicitBinder</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L483-L483","name":"Lean.Parser.Term.nofun","line":483,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.nofun","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.nofun\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">nofun</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L476-L481","name":"Lean.Parser.Term.nomatch","line":476,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.nomatch","doc":"Empty match/ex falso. `nomatch e` is of arbitrary type `α : Sort u` if\nLean can show that an empty set of patterns is exhaustive given `e`'s type,\ne.g. because it has no constructors.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.nomatch\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">nomatch</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L440-L475","name":"Lean.Parser.Term.match","line":440,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.match","doc":"Pattern matching. `match e, ... with | p, ... => f | ...` matches each given\nterm `e` against each pattern `p` of a match alternative. When all patterns\nof an alternative match, the `match` term evaluates to the value of the\ncorresponding right-hand side `f` with the pattern variables bound to the\nrespective matched values.\nIf used as `match h : e, ... with | p, ... => f | ...`, `h : e = p` is available\nwithin `f`.\n\nWhen not constructing a proof, `match` does not automatically substitute variables\nmatched on in dependent variables' types. Use `match (generalizing := true) ...` to\nenforce this.\n\nSyntax quotations can also be used in a pattern match.\nThis matches a `Syntax` value against quotations, pattern variables, or `_`.\n\nQuoted identifiers only match identical identifiers - custom matching such as by the preresolved\nnames only should be done explicitly.\n\n`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.\nFor users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they\nshould participate in matching.\nFor example, in\n```lean\nsyntax \"c\" (\"foo\" <|> \"bar\") ...\n```\n`foo` and `bar` are indistinguishable during matching, but in\n```lean\nsyntax foo := \"foo\"\nsyntax \"c\" (foo <|> \"bar\") ...\n```\nthey are not.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.match\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">match</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L436-L438","name":"Lean.Parser.Term.motive","line":436,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.motive","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.motive\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">motive</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L432-L434","name":"Lean.Parser.Term.generalizingParam","line":432,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.generalizingParam","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.generalizingParam\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">generalizingParam</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L431-L431","name":"Lean.Parser.Term.falseVal","line":431,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.falseVal","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.falseVal\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">falseVal</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L430-L430","name":"Lean.Parser.Term.trueVal","line":430,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.trueVal","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.trueVal\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">trueVal</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L425-L428","name":"Lean.Parser.Term.matchDiscr","line":425,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchDiscr","doc":"`matchDiscr` matches a \"match discriminant\", either `h : tm` or `tm`, used in `match` as\n`match h1 : e1, e2, h3 : e3 with ...`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.matchDiscr\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">matchDiscr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L422-L423","name":"Lean.Parser.Term.matchAlts","line":422,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchAlts","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.matchAlts\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">matchAlts</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(rhsParser : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a> := <span class=\"fn\">Lean.Parser.termParser</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L419-L420","name":"Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean","line":419,"kind":"instance","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#Coe\">Coe</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Term.matchAltExpr</span>)</span> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Term.matchAlt</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L414-L417","name":"Lean.Parser.Term.matchAltExpr","line":414,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchAltExpr","doc":"Useful for syntax quotations. Note that generic patterns such as `` `(matchAltExpr| | ... => $rhs) `` should also\nwork with other `rhsParser`s (of arity 1). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.matchAltExpr\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">matchAltExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L408-L413","name":"Lean.Parser.Term.matchAlt","line":408,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchAlt","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.matchAlt\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">matchAlt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(rhsParser : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a> := <span class=\"fn\">Lean.Parser.termParser</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L402-L406","name":"Lean.Parser.Term.forall","line":402,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.forall","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.forall\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">forall</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L399-L400","name":"Lean.Parser.Term.depArrow","line":399,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.depArrow","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.depArrow\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">depArrow</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L373-L382","name":"Lean.Parser.Term.bracketedBinder","line":373,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinder","doc":"A `bracketedBinder` matches any kind of binder group that uses some kind of brackets:\n* An explicit binder like `(x y : A)`\n* An implicit binder like `{x y : A}`\n* A strict implicit binder, `⦃y z : A⦄` or its ASCII alternative `{{y z : A}}`\n* An instance binder `[A]` or `[x : A]` (multiple variables are not allowed here)\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">bracketedBinder</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(requireType : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L364-L372","name":"Lean.Parser.Term.instBinder","line":364,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.instBinder","doc":"Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.instBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">instBinder</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L348-L363","name":"Lean.Parser.Term.strictImplicitBinder","line":348,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitBinder","doc":"Strict-implicit binder, like `⦃x y : A⦄` or `⦃x y⦄`.\nIn contrast to `{ ... }` implicit binders, strict-implicit binders do not automatically insert\na `_` placeholder until at least one subsequent explicit parameter is specified.\nDo *not* use strict-implicit binders unless there is a subsequent explicit parameter.\nAssuming this rule is followed, for fully applied expressions implicit and strict-implicit binders have the same behavior.\n\nExample: If `h : ∀ ⦃x : A⦄, x ∈ s → p x` and `hs : y ∈ s`,\nthen `h` by itself elaborates to itself without inserting `_` for the `x : A` parameter,\nand `h hs` has type `p y`.\nIn contrast, if `h' : ∀ {x : A}, x ∈ s → p x`, then `h` by itself elaborates to have type `?m ∈ s → p ?m`\nwith `?m` a fresh metavariable.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">strictImplicitBinder</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(requireType : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L347-L347","name":"Lean.Parser.Term.strictImplicitRightBracket","line":347,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitRightBracket","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitRightBracket\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">strictImplicitRightBracket</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L346-L346","name":"Lean.Parser.Term.strictImplicitLeftBracket","line":346,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitLeftBracket","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitLeftBracket\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">strictImplicitLeftBracket</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L335-L345","name":"Lean.Parser.Term.implicitBinder","line":335,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.implicitBinder","doc":"Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.implicitBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">implicitBinder</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(requireType : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L329-L334","name":"Lean.Parser.Term.explicitBinder","line":329,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.explicitBinder","doc":"Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.explicitBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">explicitBinder</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(requireType : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L320-L327","name":"Lean.Parser.Term.binderDefault.parenthesizer","line":320,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binderDefault.parenthesizer","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binderDefault.parenthesizer\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binderDefault</span>.<span class=\"name\">parenthesizer</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Parenthesizer.html#Lean.PrettyPrinter.Parenthesizer\">Lean.PrettyPrinter.Parenthesizer</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L316-L317","name":"Lean.Parser.Term.binderDefault","line":316,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binderDefault","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binderDefault\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binderDefault</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L314-L315","name":"Lean.Parser.Term.binderTactic","line":314,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binderTactic","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binderTactic\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binderTactic</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L312-L313","name":"Lean.Parser.Term.binderType","line":312,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binderType","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binderType\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binderType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(requireType : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L306-L311","name":"Lean.Parser.Term.inaccessible","line":306,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.inaccessible","doc":"`.(e)` marks an \"inaccessible pattern\", which does not influence evaluation of the pattern match, but may be necessary for type-checking.\nIn contrast to regular patterns, `e` may be an arbitrary term of the appropriate type.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.inaccessible\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">inaccessible</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L300-L305","name":"Lean.Parser.Term.explicit","line":300,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.explicit","doc":"`@x` disables automatic insertion of implicit parameters of the constant `x`.\n`@e` for any term `e` also disables the insertion of implicit lambdas at this position.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.explicit\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">explicit</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L299-L299","name":"Lean.Parser.Term.optType","line":299,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optType","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.optType\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">optType</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L298-L298","name":"Lean.Parser.Term.typeSpec","line":298,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.typeSpec","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.typeSpec\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">typeSpec</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L284-L297","name":"Lean.Parser.Term.structInst","line":284,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInst","doc":"Structure instance. `{ x := e, ... }` assigns `e` to field `x`, which may be\ninherited. If `e` is itself a variable called `x`, it can be elided:\n`fun y => { x := 1, y }`.\nA *structure update* of an existing value can be given via `with`:\n`{ point with x := 1 }`.\nThe structure type can be specified if not inferable:\n`{ x := 1, y := 2 : Point }`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.structInst\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">structInst</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L282-L283","name":"Lean.Parser.Term.optEllipsis","line":282,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optEllipsis","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.optEllipsis\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">optEllipsis</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L279-L281","name":"Lean.Parser.Term.structInstFieldAbbrev","line":279,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInstFieldAbbrev","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.structInstFieldAbbrev\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">structInstFieldAbbrev</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L277-L278","name":"Lean.Parser.Term.structInstField","line":277,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInstField","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.structInstField\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">structInstField</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L274-L276","name":"Lean.Parser.Term.structInstLVal","line":274,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInstLVal","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.structInstLVal\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">structInstLVal</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L272-L273","name":"Lean.Parser.Term.structInstArrayRef","line":272,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInstArrayRef","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.structInstArrayRef\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">structInstArrayRef</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L271-L271","name":"Lean.Parser.Term.show","line":271,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.show","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.show\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">show</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L269-L270","name":"Lean.Parser.Term.suffices","line":269,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.suffices","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.suffices\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">suffices</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L265-L268","name":"Lean.Parser.Term.sufficesDecl","line":265,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.sufficesDecl","doc":"A `sufficesDecl` represents everything that comes after the `suffices` keyword:\nan optional `x :`, then a term `ty`, then `from val` or `by tac`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.sufficesDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">sufficesDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L264-L264","name":"Lean.Parser.Term.showRhs","line":264,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.showRhs","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.showRhs\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">showRhs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L262-L263","name":"Lean.Parser.Term.fromTerm","line":262,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.fromTerm","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.fromTerm\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">fromTerm</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L260-L261","name":"Lean.Parser.Term.optIdent","line":260,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optIdent","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.optIdent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">optIdent</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L251-L259","name":"Lean.Parser.Term.anonymousCtor","line":251,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.anonymousCtor","doc":"The *anonymous constructor* `⟨e, ...⟩` is equivalent to `c e ...` if the\nexpected type is an inductive type with a single constructor `c`.\nIf more terms are given than `c` has parameters, the remaining arguments\nare turned into a new anonymous constructor application. For example,\n`⟨a, b, c⟩ : α × (β × γ)` is equivalent to `⟨a, ⟨b, c⟩⟩`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.anonymousCtor\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">anonymousCtor</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L240-L250","name":"Lean.Parser.Term.paren","line":240,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.paren","doc":"Parentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.paren\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">paren</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L236-L238","name":"Lean.Parser.Term.tuple","line":236,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.tuple","doc":"Tuple notation; `()` is short for `Unit.unit`, `(a, b, c)` for `Prod.mk a (Prod.mk b c)`, etc. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.tuple\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">tuple</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L227-L234","name":"Lean.Parser.Term.typeAscription","line":227,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.typeAscription","doc":"Type ascription notation: `(0 : Int)` instructs Lean to process `0` as a value of type `Int`.\nAn empty type ascription `(e :)` elaborates `e` without the expected type.\nThis is occasionally useful when Lean's heuristics for filling arguments from the expected type\ndo not yield the right result.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.typeAscription\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">typeAscription</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L221-L226","name":"Lean.Parser.Term.cdot","line":221,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.cdot","doc":"A placeholder for an implicit lambda abstraction's variable. The lambda abstraction is scoped to the surrounding parentheses.\nFor example, `(· + ·)` is equivalent to `fun x y => x + y`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.cdot\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">cdot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L218-L220","name":"Lean.Parser.Term.sorry","line":218,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.sorry","doc":"A temporary placeholder for a missing proof or value. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.sorry\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">sorry</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L217-L217","name":"Lean.Parser.Term.binderIdent","line":217,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binderIdent","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binderIdent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binderIdent</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L207-L216","name":"Lean.Parser.Term.omission","line":207,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.omission","doc":"The `⋯` term denotes a term that was omitted by the pretty printer.\nThe presence of `⋯` in pretty printer output is controlled by the `pp.deepTerms` and `pp.proofs` options,\nand these options can be further adjusted using `pp.deepTerms.threshold` and `pp.proofs.threshold`.\n\nIt is only meant to be used for pretty printing.\nHowever, in case it is copied and pasted from the Infoview, `⋯` logs a warning and elaborates like `_`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.omission\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">omission</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L161-L206","name":"Lean.Parser.Term.syntheticHole","line":161,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.syntheticHole","doc":"A *synthetic hole* (or *synthetic placeholder*), which stands for an unknown term that should be synthesized using tactics.\n- `?_` creates a fresh metavariable with an auto-generated name.\n- `?m` either refers to a pre-existing metavariable named `m` or creates a fresh metavariable with that name.\n\nIn particular, the synthetic hole syntax creates \"synthetic opaque metavariables\",\nthe same kind of metavariable used to represent goals in the tactic state.\n\nSynthetic holes are similar to holes in that `_` also creates metavariables,\nbut synthetic opaque metavariables have some different properties:\n- In tactics such as `refine`, only synthetic holes yield new goals.\n- During elaboration, unification will not solve for synthetic opaque metavariables, they are \"opaque\".\n  This is to prevent counterintuitive behavior such as disappearing goals.\n- When synthetic holes appear under binders, they capture local variables using a more complicated mechanism known as delayed assignment.\n\n## Delayed assigned metavariables\n\nThis section gives an overview of some technical details of synthetic holes, which you should feel free to skip.\nUnderstanding delayed assignments is mainly useful for those who are working on tactics and other metaprogramming.\nIt is included here until there is a suitable place for it in the reference manual.\n\nWhen a synthetic hole appears under a binding construct, such as for example `fun (x : α) (y : β) => ?s`,\nthe system creates a *delayed assignment*. This consists of\n1. A metavariable `?m` of type `(x : α) → (y : β) → γ x y` whose local context is the local context outside the `fun`,\n  where `γ x y` is the type of `?s`. Recall that `x` and `y` appear in the local context of `?s`.\n2. A delayed assigment record associating `?m` to `?s` and the variables `#[x, y]` in the local context of `?s`\n\nThen, this function elaborates as `fun (x : α) (y : β) => ?m x y`, where one should understand `x` and `y` here\nas being De Bruijn indexes, since Lean uses the locally nameless encoding of lambda calculus.\n\nOnce `?s` is fully solved for, in the sense that after metavariable instantiation it is a metavariable-free term `e`,\nthen we can make the assignment `?m := fun (x' : α) (y' : β) => e[x := x', y := y']`.\n(Implementation note: Lean only instantiates full applications `?m x' y'` of delayed assigned metavariables, to skip forming this function.)\nThis delayed assignment mechanism is essential to the operation of basic tactics like `intro`,\nand a good mental model is that it is a way to \"apply\" the metavariable `?s` by substituting values in for some of its local variables.\nWhile it would be easier to immediately assign `?s := ?m x y`,\ndelayed assigment preserves `?s` as an unsolved-for metavariable with a local context that still contains `x` and `y`,\nwhich is exactly what tactics like `intro` need.\n\nBy default, delayed assigned metavariables pretty print with what they are delayed assigned to.\nThe delayed assigned metavariables themselves can be pretty printed using `set_option pp.mvars.delayed true`.\n\nFor more information, see the \"Gruesome details\" module docstrings in `Lean.MetavarContext`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.syntheticHole\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">syntheticHole</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L143-L160","name":"Lean.Parser.Term.hole","line":143,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.hole","doc":"A *hole* (or *placeholder term*), which stands for an unknown term that is expected to be inferred based on context.\nFor example, in `@id _ Nat.zero`, the `_` must be the type of `Nat.zero`, which is `Nat`.\n\nThe way this works is that holes create fresh metavariables.\nThe elaborator is allowed to assign terms to metavariables while it is checking definitional equalities.\nThis is often known as *unification*.\n\nNormally, all holes must be solved for. However, there are a few contexts where this is not necessary:\n* In `match` patterns, holes are catch-all patterns.\n* In some tactics, such as `refine'` and `apply`, unsolved-for placeholders become new goals.\n\nRelated concept: implicit parameters are automatically filled in with holes during the elaboration process.\n\nSee also `?m` syntax (synthetic holes).\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.hole\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">hole</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L140-L142","name":"Lean.Parser.Term.prop","line":140,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.prop","doc":"The universe of propositions. `Prop ≡ Sort 0`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.prop\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">prop</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L137-L139","name":"Lean.Parser.Term.sort","line":137,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.sort","doc":"A specific universe in Lean's infinite hierarchy of universes. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.sort\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">sort</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L134-L136","name":"Lean.Parser.Term.type","line":134,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.type","doc":"A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.type\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">type</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L132-L133","name":"Lean.Parser.Term.char","line":132,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.char","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.char\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">char</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L130-L131","name":"Lean.Parser.Term.str","line":130,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.str","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.str\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">str</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L128-L129","name":"Lean.Parser.Term.scientific","line":128,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.scientific","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.scientific\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">scientific</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L126-L127","name":"Lean.Parser.Term.num","line":126,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.num","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.num\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">num</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L124-L125","name":"Lean.Parser.Term.ident","line":124,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.ident","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.ident\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">ident</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L120-L121","name":"Lean.Parser.Term.optSemicolon","line":120,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optSemicolon","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.optSemicolon\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">optSemicolon</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L116-L117","name":"Lean.Parser.Term.byTactic'","line":116,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.byTactic'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.byTactic'\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">byTactic'</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L106-L108","name":"Lean.Parser.Term.byTactic","line":106,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.byTactic","doc":"`by tac` constructs a term of the expected type by running the tactic(s) `tac`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.byTactic\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">byTactic</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L99-L99","name":"Lean.Parser.semicolonOrLinebreak","line":99,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.semicolonOrLinebreak","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.semicolonOrLinebreak\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">semicolonOrLinebreak</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L98-L98","name":"Lean.Parser.darrow","line":98,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.darrow","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.darrow\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">darrow</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L93-L94","name":"Lean.Parser.Tactic.seq1","line":93,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.seq1","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.seq1\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">seq1</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L86-L90","name":"Lean.Parser.Tactic.tacticSeqIndentGt","line":86,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeqIndentGt","doc":"Same as [`tacticSeq`] but requires delimiter-free tactic sequence to have strict indentation.\nThe strict indentation requirement only apply to *nested* `by`s, as top-level `by`s do not have a\nposition set. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeqIndentGt\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticSeqIndentGt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L81-L84","name":"Lean.Parser.Tactic.tacticSeq","line":81,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeq","doc":"A sequence of tactics in brackets, or a delimiter-free indented sequence of tactics.\nDelimiter-free indentation is determined by the *first* tactic of the sequence. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeq\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticSeq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L76-L79","name":"Lean.Parser.Tactic.tacticSeqBracketed","line":76,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeqBracketed","doc":"The syntax `{ tacs }` is an alternative syntax for `· tacs`.\nIt runs the tactics in sequence, and fails if the goal is not solved. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeqBracketed\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticSeqBracketed</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L74-L75","name":"Lean.Parser.Tactic.tacticSeq1Indented","line":74,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeq1Indented","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeq1Indented\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticSeq1Indented</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L57-L68","name":"Lean.Parser.Tactic.sepBy1IndentSemicolon","line":57,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.sepBy1IndentSemicolon","doc":"`sepBy1IndentSemicolon(p)` parses a (nonempty) sequence of `p` optionally followed by `;`,\nsimilar to `many1Indent(p \";\"?)`, except that if two occurrences of `p` occur on the same line,\nthe `;` is mandatory. This is used by tactic parsing, so that\n```\nexample := by\n  skip\n  skip\n```\nis legal, but `by skip skip` is not - it must be written as `by skip; skip`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.sepBy1IndentSemicolon\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">sepBy1IndentSemicolon</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L44-L55","name":"Lean.Parser.Tactic.sepByIndentSemicolon","line":44,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.sepByIndentSemicolon","doc":"`sepByIndentSemicolon(p)` parses a sequence of `p` optionally followed by `;`,\nsimilar to `manyIndent(p \";\"?)`, except that if two occurrences of `p` occur on the same line,\nthe `;` is mandatory. This is used by tactic parsing, so that\n```\nexample := by\n  skip\n  skip\n```\nis legal, but `by skip skip` is not - it must be written as `by skip; skip`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.sepByIndentSemicolon\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">sepByIndentSemicolon</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L39-L40","name":"Lean.Parser.convParser","line":39,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.convParser","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.convParser\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">convParser</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(rbp : <a href=\"./Init/Prelude.html#Nat\">Nat</a> := <span class=\"fn\">0</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L36-L37","name":"Lean.Parser.tacticParser","line":36,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.tacticParser","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.tacticParser\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">tacticParser</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(rbp : <a href=\"./Init/Prelude.html#Nat\">Nat</a> := <span class=\"fn\">0</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L22-L29","name":"Lean.Parser.Command.docComment","line":22,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.docComment","doc":"A `docComment` parses a \"documentation comment\" like `/-- foo -/`. This is not treated like\na regular comment (that is, as whitespace); it is parsed and forms part of the syntax tree structure.\n\nA `docComment` node contains a `/--` atom and then the remainder of the comment, `foo -/` in this\nexample. Use `TSyntax.getDocString` to extract the body text from a doc string syntax node. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Command.docComment\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">docComment</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L19-L20","name":"Lean.Parser.Command.commentBody.formatter","line":19,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody.formatter","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">commentBody</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">Lean.PrettyPrinter.Formatter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L17-L18","name":"Lean.Parser.Command.commentBody.parenthesizer","line":17,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody.parenthesizer","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody.parenthesizer\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">commentBody</span>.<span class=\"name\">parenthesizer</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Parenthesizer.html#Lean.PrettyPrinter.Parenthesizer\">Lean.PrettyPrinter.Parenthesizer</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Parser/Term.lean#L14-L15","name":"Lean.Parser.Command.commentBody","line":14,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">commentBody</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"}]}