{"name":"Lean.Meta.Tactic.Grind.Cases","instances":[],"imports":["Lean.Meta.Tactic.Cases"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Meta/Tactic/Grind/Cases.lean#L59-L60","name":"Lean.Meta.Grind.cases.throwInductiveExpected","line":59,"kind":"def","docLink":"./Lean/Meta/Tactic/Grind/Cases.html#Lean.Meta.Grind.cases.throwInductiveExpected","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/Cases.html#Lean.Meta.Grind.cases.throwInductiveExpected\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">cases</span>.<span class=\"name\">throwInductiveExpected</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(mvarId : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fvarId : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(type : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/Lean/Meta/Tactic/Grind/Cases.lean#L10-L60","name":"Lean.Meta.Grind.cases","line":10,"kind":"def","docLink":"./Lean/Meta/Tactic/Grind/Cases.html#Lean.Meta.Grind.cases","doc":"The `grind` tactic includes an auxiliary `cases` tactic that is not intended for direct use by users.\nThis method implements it.\nThis tactic is automatically applied when introducing local declarations with a type tagged with `[grind_cases]`.\nIt differs from the user-facing Lean `cases` tactic in the following ways:\n\n- It avoids unnecessary `revert` and `intro` operations.\n\n- It does not introduce new local declarations for each minor premise. Instead, the `grind` tactic preprocessor is responsible for introducing them.\n\n- It assumes that the major premise (i.e., the parameter `fvarId`) is the latest local declaration in the current goal.\n\n- If the major premise type is an indexed family, auxiliary declarations and (heterogeneous) equalities are introduced.\n  However, these equalities are not resolved using `unifyEqs`. Instead, the `grind` tactic employs union-find and\n  congruence closure to process these auxiliary equalities. This approach avoids applying substitution to propositions\n  that have already been internalized by `grind`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/Cases.html#Lean.Meta.Grind.cases\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">cases</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(mvarId : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fvarId : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span></div></div>"}]}