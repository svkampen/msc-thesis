{"name":"Mathlib.Tactic.CC.Addition","instances":[],"imports":["Init","Mathlib.Logic.Basic","Mathlib.Data.Option.Defs","Mathlib.Lean.Expr.Basic","Mathlib.Tactic.Relation.Rfl","Mathlib.Tactic.Relation.Symm","Mathlib.Tactic.CC.Datatypes","Mathlib.Tactic.CC.Lemmas","Batteries.Data.RBMap.Alter"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L2056-L2099","name":"Mathlib.Tactic.CC.CCM.add","line":2056,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.add","doc":"Add `proof : type` to the congruence closure. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.add\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">add</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(type proof : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L2050-L2054","name":"Mathlib.Tactic.CC.CCM.addEqvCore","line":2050,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addEqvCore","doc":"Add `H : lhs = rhs` or `H : HEq lhs rhs` to the congruence closure. Don't forget to internalize\n`lhs` and `rhs` beforehand. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addEqvCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">addEqvCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(lhs rhs H : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(heqProof : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L2045-L2048","name":"Mathlib.Tactic.CC.CCM.internalize","line":2045,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.internalize","doc":"Internalize `e` so that the congruence closure can deal with the given expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.internalize\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">internalize</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L2034-L2043","name":"Mathlib.Tactic.CC.CCM.processTodo","line":2034,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.processTodo","doc":"Process the tasks in the `todo` field. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.processTodo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">processTodo</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1904-L2032","name":"Mathlib.Tactic.CC.CCM.addEqvStep.go","line":1904,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addEqvStep.go","doc":"The auxiliary definition for `addEqvStep` to flip the input. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addEqvStep.go\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">addEqvStep</span>.<span class=\"name\">go</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e₁ e₂ : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(n₁ n₂ r₁ r₂ : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Mathlib.Tactic.CC.Entry</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(flipped : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(H : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">Mathlib.Tactic.CC.EntryExpr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(heqProof : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1871-L2032","name":"Mathlib.Tactic.CC.CCM.addEqvStep","line":1871,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addEqvStep","doc":"Performs one step in the process when the new equation is added.\n\nHere, `H` contains the proof that `e₁ = e₂` (if `heqProof` is false)\nor `HEq e₁ e₂` (if `heqProof` is true). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addEqvStep\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">addEqvStep</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e₁ e₂ : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(H : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">Mathlib.Tactic.CC.EntryExpr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(heqProof : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1858-L1869","name":"Mathlib.Tactic.CC.CCM.propagateDown","line":1858,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateDown","doc":"Propagate equality from `e` to subexpressions of `e`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateDown\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateDown</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1850-L1856","name":"Mathlib.Tactic.CC.CCM.propagateExistsDown","line":1850,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateExistsDown","doc":"Propagate equality from `¬∃ x, p x` to `∀ x, ¬p x`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateExistsDown\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateExistsDown</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1844-L1848","name":"Mathlib.Tactic.CC.CCM.propagateEqDown","line":1844,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateEqDown","doc":"Propagate equality from `(a = b) = True` to `a = b`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateEqDown\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateEqDown</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1833-L1842","name":"Mathlib.Tactic.CC.CCM.propagateNotDown","line":1833,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateNotDown","doc":"Propagate equality from `¬a` to `a`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateNotDown\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateNotDown</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1825-L1831","name":"Mathlib.Tactic.CC.CCM.propagateOrDown","line":1825,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateOrDown","doc":"Propagate equality from `a ∨ b = False` to `a = False` and `b = False`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateOrDown\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateOrDown</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1817-L1823","name":"Mathlib.Tactic.CC.CCM.propagateAndDown","line":1817,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateAndDown","doc":"Propagate equality from `a ∧ b = True` to `a = True` and `b = True`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateAndDown\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateAndDown</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1805-L1815","name":"Mathlib.Tactic.CC.CCM.propagateValueInconsistency","line":1805,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateValueInconsistency","doc":"Derive contradiction if we can get equality between different values. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateValueInconsistency\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateValueInconsistency</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e₁ e₂ : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1783-L1796","name":"Mathlib.Tactic.CC.CCM.propagateConstructorEq.go","line":1783,"kind":"opaque","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateConstructorEq.go","doc":"Given an injective theorem `val : type`, whose `type` is the form of\n`a₁ = a₂ ∧ HEq b₁ b₂ ∧ ..`, destruct `val` and push equality proofs to the todo list. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateConstructorEq.go\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateConstructorEq</span>.<span class=\"name\">go</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(type val : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1757-L1803","name":"Mathlib.Tactic.CC.CCM.propagateConstructorEq","line":1757,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateConstructorEq","doc":"Given a new equality `e₁ = e₂`, where `e₁` and `e₂` are constructor applications.\nImplement the following implications:\n```lean\nc a₁ ... aₙ = c b₁ ... bₙ => a₁ = b₁, ..., aₙ = bₙ\n\nc₁ ... = c₂ ... => False\n```\nwhere `c`, `c₁` and `c₂` are constructors "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateConstructorEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateConstructorEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e₁ e₂ : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1733-L1755","name":"Mathlib.Tactic.CC.CCM.propagateProjectionConstructor","line":1733,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateProjectionConstructor","doc":"Given `c` a constructor application, if `p` is a projection application (not `.proj _ _ _`, but\n`.app (.const projName _) _`) such that major premise is\nequal to `c`, then propagate new equality.\n\nExample: if `p` is of the form `b.fst`, `c` is of the form `(x, y)`, and `b = c`, we add the\nequality `(x, y).fst = x` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateProjectionConstructor\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateProjectionConstructor</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p c : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1707-L1731","name":"Mathlib.Tactic.CC.CCM.propagateBetaToEqc","line":1707,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateBetaToEqc","doc":"For each `fnRoot` in `fnRoots` traverse its parents, and look for a parent prefix that is\nin the same equivalence class of the given lambdas.\n\nremark All expressions in lambdas are in the same equivalence class "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateBetaToEqc\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateBetaToEqc</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(fnRoots lambdas : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(newLambdaApps : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <span class=\"fn\">#[]</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1703-L1705","name":"Mathlib.Tactic.CC.CCM.checkInvariant","line":1703,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.checkInvariant","doc":"Check for integrity of the `CCStructure`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.checkInvariant\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">checkInvariant</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1690-L1701","name":"Mathlib.Tactic.CC.CCM.reinsertParents","line":1690,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.reinsertParents","doc":"Reinsert parents of `e` to the congruence table and the symm congruence table.\n\nTogether with `removeParents`, this allows modifying parents of an expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.reinsertParents\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">reinsertParents</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1673-L1688","name":"Mathlib.Tactic.CC.CCM.collectFnRoots","line":1673,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.collectFnRoots","doc":"Traverse the `root`'s equivalence class, and for each function application,\ncollect the function's equivalence class root. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.collectFnRoots\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">collectFnRoots</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(root : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fnRoots : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <span class=\"fn\">#[]</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1648-L1671","name":"Mathlib.Tactic.CC.CCM.invertTrans","line":1648,"kind":"opaque","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.invertTrans","doc":"The fields `target` and `proof` in `e`'s entry are encoding a transitivity proof\nLet `e.rootTarget` and `e.rootProof` denote these fields.\n```lean\ne = e.rootTarget            := e.rootProof\n_ = e.rootTarget.rootTarget := e.rootTarget.rootProof\n ...\n_ = e.root                  := ...\n```\nThe transitivity proof eventually reaches the root of the equivalence class.\nThis method \"inverts\" the proof. That is, the `target` goes from `e.root` to e after\nwe execute it.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.invertTrans\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">invertTrans</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(newFlipped : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(newTarget : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <span class=\"fn\">none</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(newProof : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">Mathlib.Tactic.CC.EntryExpr</a></span> := <span class=\"fn\">none</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1612-L1646","name":"Mathlib.Tactic.CC.CCM.removeParents","line":1612,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.removeParents","doc":"Remove parents of `e` from the congruence table and the symm congruence table, and append\nparents to propagate equality, to `parentsToPropagate`.\nReturns the new value of `parentsToPropagate`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.removeParents\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">removeParents</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(parentsToPropagate : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <span class=\"fn\">#[]</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1607-L1610","name":"Mathlib.Tactic.CC.CCM.mayPropagate","line":1607,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mayPropagate","doc":"Can we propagate equality from subexpressions of `e` to `e`? "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mayPropagate\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">mayPropagate</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1598-L1604","name":"Mathlib.Tactic.CC.CCM.mkEntry","line":1598,"kind":"opaque","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkEntry","doc":"Add an new entry for `e` to the congruence closure. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkEntry\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">mkEntry</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(interpreted : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1571-L1596","name":"Mathlib.Tactic.CC.CCM.processSubsingletonElem","line":1571,"kind":"opaque","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.processSubsingletonElem","doc":"If `e` is a subsingleton element, push the equality proof between `e` and its canonical form\nto the todo list or register `e` as the canonical form of itself. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.processSubsingletonElem\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">processSubsingletonElem</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1504-L1569","name":"Mathlib.Tactic.CC.CCM.applySimpleEqvs","line":1504,"kind":"opaque","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.applySimpleEqvs","doc":"This method is invoked during internalization and eagerly apply basic equivalences for term `e`\nExamples:\n- If `e := cast H e'`, then it merges the equivalence classes of `cast H e'` and `e'`\n\nIn principle, we could mark theorems such as `cast_eq` as simplification rules, but this created\nproblems with the builtin support for cast-introduction in the ematching module in Lean 3.\nTODO: check if this is now possible in Lean 4.\n\nEagerly merging the equivalence classes is also more efficient. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.applySimpleEqvs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">applySimpleEqvs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1486-L1502","name":"Mathlib.Tactic.CC.CCM.propagateUp","line":1486,"kind":"opaque","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateUp","doc":"Propagate equality from subexpressions of `e` to `e`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateUp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateUp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1445-L1484","name":"Mathlib.Tactic.CC.CCM.propagateEqUp","line":1445,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateEqUp","doc":"Propagate equality from `a` and `b` to *disprove* `a = b`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateEqUp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateEqUp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1432-L1443","name":"Mathlib.Tactic.CC.CCM.propagateIteUp","line":1432,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateIteUp","doc":"Propagate equality from `p`, `a` and `b` to `if p then a else b`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateIteUp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateIteUp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1397-L1430","name":"Mathlib.Tactic.CC.CCM.propagateImpUp","line":1397,"kind":"opaque","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateImpUp","doc":"Propagate equality from `a` and `b` to `a → b`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateImpUp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateImpUp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1383-L1395","name":"Mathlib.Tactic.CC.CCM.propagateNotUp","line":1383,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateNotUp","doc":"Propagate equality from `a` to `¬a`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateNotUp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateNotUp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1361-L1380","name":"Mathlib.Tactic.CC.CCM.propagateOrUp","line":1361,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateOrUp","doc":"Propagate equality from `a` and `b` to `a ∨ b`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateOrUp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateOrUp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1339-L1358","name":"Mathlib.Tactic.CC.CCM.propagateAndUp","line":1339,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateAndUp","doc":"Propagate equality from `a` and `b` to `a ∧ b`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateAndUp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateAndUp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1326-L1337","name":"Mathlib.Tactic.CC.CCM.propagateIffUp","line":1326,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateIffUp","doc":"Propagate equality from `a` and `b` to `a ↔ b`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateIffUp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateIffUp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1280-L1324","name":"Mathlib.Tactic.CC.CCM.internalizeCore","line":1280,"kind":"opaque","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.internalizeCore","doc":"Internalize `e` so that the congruence closure can deal with the given expression. Don't forget\nto process the tasks in the `todo` field later. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.internalizeCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">internalizeCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(parent? : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1215-L1278","name":"Mathlib.Tactic.CC.CCM.internalizeAppLit","line":1215,"kind":"opaque","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.internalizeAppLit","doc":"The specialized `internalizeCore` for applications or literals. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.internalizeAppLit\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">internalizeAppLit</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1188-L1212","name":"Mathlib.Tactic.CC.CCM.internalizeAC","line":1188,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.internalizeAC","doc":"Internalize `e` so that the AC module can deal with the given expression.\n\nIf the expression does not contain an AC operator, or the parent expression\nis already processed by `internalizeAC`, this operation does nothing. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.internalizeAC\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">internalizeAC</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(parent? : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1175-L1185","name":"Mathlib.Tactic.CC.CCM.convertAC","line":1175,"kind":"opaque","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.convertAC","doc":"Given `e := op₁ (op₂ a₁ a₂) (op₃ a₃ a₄)` where `opₙ`s are canonicalized to `op`, internalize\n`aₙ`s as AC variables and return `(op (op a₁ a₂) (op a₃ a₄), args ++ #[a₁, a₂, a₃, a₄])`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.convertAC\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">convertAC</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(op e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(args : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <span class=\"fn\">#[]</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1165-L1173","name":"Mathlib.Tactic.CC.CCM.internalizeACVar","line":1165,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.internalizeACVar","doc":"If `e` isn't an AC variable, set `e` as an new AC variable. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.internalizeACVar\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">internalizeACVar</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1154-L1163","name":"Mathlib.Tactic.CC.CCM.setACVar","line":1154,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.setACVar","doc":"If the root expression of `e` is AC variable, add equality to AC module. If not, register the\nAC variable to the root entry. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.setACVar\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">setACVar</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1146-L1152","name":"Mathlib.Tactic.CC.CCM.addACEq","line":1146,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addACEq","doc":"Given AC variables `e₁` and `e₂` which are in the same equivalence class, add the proof of\n`e₁ = e₂` to the AC module. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addACEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">addACEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e₁ e₂ : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1093-L1144","name":"Mathlib.Tactic.CC.CCM.processAC","line":1093,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.processAC","doc":"Process the tasks in the `acTodo` field. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.processAC\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">processAC</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1053-L1090","name":"Mathlib.Tactic.CC.CCM.superposeAC","line":1053,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.superposeAC","doc":"Given `tsEqa : ts = a`, for each equality `trEqb : tr = b` in `acR` where\nthe intersection `t` of `ts` and `tr` is nonempty, let `ts = t*s` and `tr := t*r`, add a new\nequality `r*a = s*b`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.superposeAC\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">superposeAC</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ts a : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tsEqa : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1028-L1050","name":"Mathlib.Tactic.CC.CCM.collapseAC","line":1028,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.collapseAC","doc":"Try to simplify the left hand sides of equalities in `acR` by `H : lhs = rhs`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.collapseAC\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">collapseAC</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(lhs rhs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(H : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L1004-L1025","name":"Mathlib.Tactic.CC.CCM.composeAC","line":1004,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.composeAC","doc":"Try to simplify the right hand sides of equalities in `acR` by `H : lhs = rhs`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.composeAC\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">composeAC</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(lhs rhs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(H : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L997-L1001","name":"Mathlib.Tactic.CC.CCM.eraseRRHSOccs","line":997,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.eraseRRHSOccs","doc":"Erase `lhs` to the occurrences of arguments of `e` on the right hand side of\nan equality in `acR`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.eraseRRHSOccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">eraseRRHSOccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e lhs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L991-L995","name":"Mathlib.Tactic.CC.CCM.insertRRHSOccs","line":991,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.insertRRHSOccs","doc":"Insert `lhs` to the occurrences of arguments of `e` on the right hand side of\nan equality in `acR`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.insertRRHSOccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">insertRRHSOccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e lhs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L984-L989","name":"Mathlib.Tactic.CC.CCM.eraseRBHSOccs","line":984,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.eraseRBHSOccs","doc":"Erase `lhs` to the occurrences on an equality in `acR` corresponding to the equality\n`lhs := rhs`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.eraseRBHSOccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">eraseRBHSOccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(lhs rhs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L977-L982","name":"Mathlib.Tactic.CC.CCM.insertRBHSOccs","line":977,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.insertRBHSOccs","doc":"Insert `lhs` to the occurrences on an equality in `acR` corresponding to the equality\n`lhs := rhs`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.insertRBHSOccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">insertRBHSOccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(lhs rhs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L972-L975","name":"Mathlib.Tactic.CC.CCM.eraseROccs","line":972,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.eraseROccs","doc":"Erase `lhs` to the occurrences of arguments of `e` on an equality in `acR`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.eraseROccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">eraseROccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e lhs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(inLHS : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L967-L970","name":"Mathlib.Tactic.CC.CCM.insertROccs","line":967,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.insertROccs","doc":"Insert `lhs` to the occurrences of arguments of `e` on an equality in `acR`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.insertROccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">insertROccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e lhs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(inLHS : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L957-L965","name":"Mathlib.Tactic.CC.CCM.insertEraseROccs","line":957,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.insertEraseROccs","doc":"Insert or erase `lhs` to the occurrences of arguments of `e` on an equality in `acR`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.insertEraseROccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">insertEraseROccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e lhs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(inLHS isInsert : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L948-L955","name":"Mathlib.Tactic.CC.CCM.insertEraseROcc","line":948,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.insertEraseROcc","doc":"Insert or erase `lhs` to the occurrences of `arg` on an equality in `acR`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.insertEraseROcc\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">insertEraseROcc</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(arg : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(lhs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(inLHS isInsert : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L938-L946","name":"Mathlib.Tactic.CC.CCM.simplifyAC","line":938,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.simplifyAC","doc":"If `e` can be simplified by the AC module, return the simplified term and the proof term of the\nequality. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.simplifyAC\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">simplifyAC</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a>)</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L916-L936","name":"Mathlib.Tactic.CC.CCM.simplifyACStep","line":916,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.simplifyACStep","doc":"The single step of `simplifyAC`.\n\nSimplifies an expression `e` by either simplifying one argument to the AC operator, or the whole\nexpression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.simplifyACStep\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">simplifyACStep</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a>)</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L900-L914","name":"Mathlib.Tactic.CC.CCM.simplifyACCore","line":900,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.simplifyACCore","doc":"Given `e := lhs * r` and `H : lhs = rhs`, return `rhs * r` and the proof of `e = rhs * r`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.simplifyACCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">simplifyACCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e lhs rhs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(H : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L873-L898","name":"Mathlib.Tactic.CC.CCM.mkACSuperposeProof","line":873,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkACSuperposeProof","doc":"Given `ra := a*r` `sb := b*s` `ts := t*s` `tr := t*r` `tsEqa : t*s = a` `trEqb : t*r = b`,\nreturn a proof for `ra = sb`.\n\nWe use `a*b` to denote an AC application. That is, `(a*b)*(c*a)` is the term `a*a*b*c`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkACSuperposeProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">mkACSuperposeProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ra sb a b r s ts tr : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tsEqa trEqb : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L849-L871","name":"Mathlib.Tactic.CC.CCM.mkACSimpProof","line":849,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkACSimpProof","doc":"Given `tr := t*r` `sr := s*r` `tEqs : t = s`, return a proof for `tr = sr`\n\nWe use `a*b` to denote an AC application. That is, `(a*b)*(c*a)` is the term `a*a*b*c`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkACSimpProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">mkACSimpProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(tr t s r sr : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tEqs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L841-L847","name":"Mathlib.Tactic.CC.CCM.mkACProof","line":841,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkACProof","doc":"Return the proof of `e₁ = e₂` using `ac_rfl` tactic. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkACProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">mkACProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e₁ e₂ : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L836-L839","name":"Mathlib.Tactic.CC.CCM.dbgTraceACState","line":836,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.dbgTraceACState","doc":"Trace the state of AC module. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.dbgTraceACState\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">dbgTraceACState</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L828-L833","name":"Mathlib.Tactic.CC.CCM.dbgTraceACEq","line":828,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.dbgTraceACEq","doc":"Given `lhs`, `rhs`, and `header := \"my header:\"`, Trace `my header: lhs = rhs`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.dbgTraceACEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">dbgTraceACEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(header : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(lhs rhs : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">Mathlib.Tactic.CC.ACApps</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L799-L825","name":"Mathlib.Tactic.CC.CCM.isAC","line":799,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.isAC","doc":"If `e` is of the form `op e₁ e₂` where `op` is an associative and commutative binary operator,\nreturn the canonical form of `op`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.isAC\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">isAC</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L788-L797","name":"Mathlib.Tactic.CC.CCM.mkNeOfNeOfEq","line":788,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkNeOfNeOfEq","doc":"Given `aNeB₁ : a ≠ b₁`, `b₁` and `b`, return a proof of `a ≠ b` if `b` and `b₁` are in the\nsame equivalence class. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkNeOfNeOfEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">mkNeOfNeOfEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(aNeB₁ b₁ b : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L777-L786","name":"Mathlib.Tactic.CC.CCM.mkNeOfEqOfNe","line":777,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkNeOfEqOfNe","doc":"Given `a`, `a₁` and `a₁NeB : a₁ ≠ b`, return a proof of `a ≠ b` if `a` and `a₁` are in the\nsame equivalence class. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkNeOfEqOfNe\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">mkNeOfEqOfNe</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(a a₁ a₁NeB : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L764-L775","name":"Mathlib.Tactic.CC.CCM.propagateBeta","line":764,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateBeta","doc":"Remove `fn` and expressions whose type isn't def-eq to `fn`'s type out from `lambdas`,\nreturn the remaining lambdas applied to the reversed arguments. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateBeta\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateBeta</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(fn : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(revArgs lambdas : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(newLambdaApps : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <span class=\"fn\">#[]</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L747-L762","name":"Mathlib.Tactic.CC.CCM.getEqcLambdas","line":747,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getEqcLambdas","doc":"Get all lambda expressions in the equivalence class of `e` and append to `r`.\n\n`e` must be the root of its equivalence class. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getEqcLambdas\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">getEqcLambdas</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(r : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <span class=\"fn\">#[]</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L733-L745","name":"Mathlib.Tactic.CC.CCM.checkNewSubsingletonEq","line":733,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.checkNewSubsingletonEq","doc":"Given the equivalent expressions `oldRoot` and `newRoot` the root of `oldRoot` is\n`newRoot`, if `oldRoot` has root representative of subsingletons, try to push the equality proof\nbetween their root representatives to the todo list, or update the root representative to\n`newRoot`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.checkNewSubsingletonEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">checkNewSubsingletonEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(oldRoot newRoot : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L715-L731","name":"Mathlib.Tactic.CC.CCM.pushSubsingletonEq","line":715,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.pushSubsingletonEq","doc":"Given subsingleton elements `a` and `b` which are not necessarily of the same type, if the\ntypes of `a` and `b` are equivalent, add the (heterogeneous) equality proof between `a` and `b` to\nthe todo list. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.pushSubsingletonEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">pushSubsingletonEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(a b : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L684-L713","name":"Mathlib.Tactic.CC.CCM.addSymmCongruenceTable","line":684,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addSymmCongruenceTable","doc":"If the symm congruence table (`symmCongruences` field) has congruent expression to `e`, add the\nequality to the todo list. If not, add `e` to the symm congruence table. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addSymmCongruenceTable\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">addSymmCongruenceTable</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L660-L682","name":"Mathlib.Tactic.CC.CCM.addCongruenceTable","line":660,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addCongruenceTable","doc":"If the congruence table (`congruences` field) has congruent expression to `e`, add the\nequality to the todo list. If not, add `e` to the congruence table. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addCongruenceTable\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">addCongruenceTable</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L649-L658","name":"Mathlib.Tactic.CC.CCM.checkEqTrue","line":649,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.checkEqTrue","doc":"Given `e := R lhs rhs`, if `R` is a reflexive relation and `lhs` is equivalent to `rhs`, add\nequality `e = True`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.checkEqTrue\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">checkEqTrue</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L637-L647","name":"Mathlib.Tactic.CC.CCM.compareSymm","line":637,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.compareSymm","doc":"Given ``k₁ := (R₁ lhs₁ rhs₁, `R₁)`` and ``k₂ := (R₂ lhs₂ rhs₂, `R₂)``, return `true` if\n`R₁ lhs₁ rhs₁` is equivalent to `R₂ lhs₂ rhs₂` modulo the symmetry of `R₁` and `R₂`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.compareSymm\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">compareSymm</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(k₁ k₂ : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L625-L635","name":"Mathlib.Tactic.CC.CCM.compareSymmAux","line":625,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.compareSymmAux","doc":"Auxiliary function for comparing `lhs₁ ~ rhs₁` and `lhs₂ ~ rhs₂`,\nwhen `~` is symmetric/commutative.\nIt returns `true` (equal) for `a ~ b` `b ~ a`"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.compareSymmAux\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">compareSymmAux</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(lhs₁ rhs₁ lhs₂ rhs₂ : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L616-L623","name":"Mathlib.Tactic.CC.CCM.getInconsistencyProof","line":616,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getInconsistencyProof","doc":"Build a proof of `False` if the context is inconsistent.\nReturns `none` if `False` is not known to be true. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getInconsistencyProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">getInconsistencyProof</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L610-L614","name":"Mathlib.Tactic.CC.CCM.getPropEqProof","line":610,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getPropEqProof","doc":"Build a proof for `a = b`. Fails if `a` and `b` are not known to be equal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getPropEqProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">getPropEqProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(a b : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L604-L608","name":"Mathlib.Tactic.CC.CCM.getEqFalseProof","line":604,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getEqFalseProof","doc":"Build a proof for `e = False`. Fails if `e` is not known to be false. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getEqFalseProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">getEqFalseProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L598-L602","name":"Mathlib.Tactic.CC.CCM.getEqTrueProof","line":598,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getEqTrueProof","doc":"Build a proof for `e = True`. Fails if `e` is not known to be true. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getEqTrueProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">getEqTrueProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L591-L595","name":"Mathlib.Tactic.CC.CCM.getHEqProof","line":591,"kind":"opaque","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getHEqProof","doc":"Build a proof for `HEq e₁ e₂`.\nThe result is `none` if `e₁` and `e₂` are not in the same equivalence class. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getHEqProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">getHEqProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e₁ e₂ : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L585-L589","name":"Mathlib.Tactic.CC.CCM.getEqProof","line":585,"kind":"opaque","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getEqProof","doc":"Build a proof for `e₁ = e₂`.\nThe result is `none` if `e₁` and `e₂` are not in the same equivalence class. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getEqProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">getEqProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e₁ e₂ : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L512-L583","name":"Mathlib.Tactic.CC.CCM.getEqProofCore","line":512,"kind":"opaque","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getEqProofCore","doc":"If `asHEq` is `true`, then build a proof for `HEq e₁ e₂`.\nOtherwise, build a proof for `e₁ = e₂`.\nThe result is `none` if `e₁` and `e₂` are not in the same equivalence class. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getEqProofCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">getEqProofCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e₁ e₂ : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(asHEq : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L476-L510","name":"Mathlib.Tactic.CC.CCM.mkProof","line":476,"kind":"opaque","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkProof","doc":"Use the format of `H` to try and construct a proof or `lhs = rhs`:\n* If `H = .congr`, then use congruence.\n* If `H = .eqTrue`, try to prove `lhs = True` or `rhs = True`,\n  if they have the format `R a b`, by proving `a = b`.\n* Otherwise, return the (delayed) proof encoded by `H` itself. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">mkProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(lhs rhs : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(H : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">Mathlib.Tactic.CC.EntryExpr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(heqProofs : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L458-L474","name":"Mathlib.Tactic.CC.CCM.mkDelayedProof","line":458,"kind":"opaque","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkDelayedProof","doc":"Turn a delayed proof into an actual proof term. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkDelayedProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">mkDelayedProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(H : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L448-L456","name":"Mathlib.Tactic.CC.CCM.mkCongrProof","line":448,"kind":"opaque","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkCongrProof","doc":"Use congruence on arguments to prove `e₁ = e₂`.\n\nSpecial case: if `e₁` and `e₂` have the form `R lhs₁ rhs₁` and `R lhs₂ rhs₂` such that\n`R` is symmetric and `lhs₁ = rhs₂`, then use those facts instead. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkCongrProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">mkCongrProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e₁ e₂ : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(heqProofs : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L413-L446","name":"Mathlib.Tactic.CC.CCM.mkSymmCongrProof","line":413,"kind":"opaque","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkSymmCongrProof","doc":"If `e₁ : R lhs₁ rhs₁`, `e₂ : R lhs₂ rhs₂` and `lhs₁ = rhs₂`, where `R` is a symmetric relation,\nprove `R lhs₁ rhs₁` is equivalent to `R lhs₂ rhs₂`.\n\n * if `lhs₁` is known to equal `lhs₂`, return `none`\n * if `lhs₁` is not known to equal `rhs₂`, fail. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkSymmCongrProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">mkSymmCongrProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e₁ e₂ : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(heqProofs : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L334-L411","name":"Mathlib.Tactic.CC.CCM.mkCongrProofCore","line":334,"kind":"opaque","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkCongrProofCore","doc":"Use congruence on arguments to prove `lhs = rhs`.\n\nThat is, tries to prove that `lhsFn lhsArgs[0] ... lhsArgs[n-1] = lhsFn rhsArgs[0] ... rhsArgs[n-1]`\nby showing that `lhsArgs[i] = rhsArgs[i]` for all `i`.\n\nFails if the head function of `lhs` is not that of `rhs`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkCongrProofCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">mkCongrProofCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(lhs rhs : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(heqProofs : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L325-L331","name":"Mathlib.Tactic.CC.CCM.mkTransOpt","line":325,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkTransOpt","doc":"Apply transitivity to `H₁?` and `H₂`, which are both `Eq` or `HEq` depending on `heqProofs`.\n\nIf `H₁?` is `none`, return `H₂` instead. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkTransOpt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">mkTransOpt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(H₁? : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(H₂ : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(heqProofs : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L321-L323","name":"Mathlib.Tactic.CC.CCM.mkTrans","line":321,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkTrans","doc":"Apply transitivity to `H₁` and `H₂`, which are both `Eq` or `HEq` depending on `heqProofs`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkTrans\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">mkTrans</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(H₁ H₂ : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(heqProofs : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L316-L319","name":"Mathlib.Tactic.CC.CCM.isEqFalse","line":316,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.isEqFalse","doc":"Is the proposition `e` known to be false? "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.isEqFalse\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">isEqFalse</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L311-L314","name":"Mathlib.Tactic.CC.CCM.isEqTrue","line":311,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.isEqTrue","doc":"Is the proposition `e` known to be true? "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.isEqTrue\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">isEqTrue</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L301-L309","name":"Mathlib.Tactic.CC.CCM.isNotEqv","line":301,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.isNotEqv","doc":"Is `e₁ ≠ e₂` known to be true?\n\nNote that this is stronger than `not (isEqv e₁ e₂)`:\nonly if we can prove they are distinct this returns `true`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.isNotEqv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">isNotEqv</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e₁ e₂ : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L295-L299","name":"Mathlib.Tactic.CC.CCM.isEqv","line":295,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.isEqv","doc":"Are `e₁` and `e₂` known to be in the same equivalence class? "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.isEqv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">isEqv</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e₁ e₂ : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L285-L293","name":"Mathlib.Tactic.CC.CCM.flipProof","line":285,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.flipProof","doc":"Apply symmetry to `H`, which is an `Eq` or a `HEq`.\n\n* If `heqProofs` is true, ensure the result is a `HEq` (otherwise it is assumed to be `Eq`).\n* If `flipped` is true, apply `symm`, otherwise keep the same direction. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.flipProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">flipProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(H : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">Mathlib.Tactic.CC.EntryExpr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(flipped heqProofs : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">Mathlib.Tactic.CC.EntryExpr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L270-L283","name":"Mathlib.Tactic.CC.CCM.flipDelayedProofCore","line":270,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.flipDelayedProofCore","doc":"In a delayed way, apply symmetry to `H`, which is an `Eq` or a `HEq`.\n\n* If `heqProofs` is true, ensure the result is a `HEq` (otherwise it is assumed to be `Eq`).\n* If `flipped` is true, apply `symm`, otherwise keep the same direction. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.flipDelayedProofCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">flipDelayedProofCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(H : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(flipped heqProofs : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">Mathlib.Tactic.CC.DelayedExpr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L255-L268","name":"Mathlib.Tactic.CC.CCM.flipProofCore","line":255,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.flipProofCore","doc":"Apply symmetry to `H`, which is an `Eq` or a `HEq`.\n\n* If `heqProofs` is true, ensure the result is a `HEq` (otherwise it is assumed to be `Eq`).\n* If `flipped` is true, apply `symm`, otherwise keep the same direction. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.flipProofCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">flipProofCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(H : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(flipped heqProofs : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L249-L253","name":"Mathlib.Tactic.CC.CCM.hasHEqProofs","line":249,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.hasHEqProofs","doc":"Does the congruence class with root `root` have any `HEq` proofs? "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.hasHEqProofs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">hasHEqProofs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(root : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L236-L247","name":"Mathlib.Tactic.CC.CCM.updateMT","line":236,"kind":"opaque","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.updateMT","doc":"Update the modification time of the congruence class of `e`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.updateMT\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">updateMT</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L231-L234","name":"Mathlib.Tactic.CC.CCM.setFO","line":231,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.setFO","doc":"Treat the entry associated with `e` as a first-order function. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.setFO\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">setFO</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L215-L229","name":"Mathlib.Tactic.CC.CCM.propagateInstImplicit","line":215,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateInstImplicit","doc":"Record the instance `e` and add it to the set of known defeq instances. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateInstImplicit\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateInstImplicit</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L209-L213","name":"Mathlib.Tactic.CC.CCM.mkCCCongrTheorem","line":209,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkCCCongrTheorem","doc":"Try to find a congruence theorem for the expression `e` with support for `HEq`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkCCCongrTheorem\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">mkCCCongrTheorem</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem\">Mathlib.Tactic.CC.CCCongrTheorem</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L188-L207","name":"Mathlib.Tactic.CC.CCM.mkCCHCongrTheorem","line":188,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkCCHCongrTheorem","doc":"Try to find a congruence theorem for an application of `fn` with `nargs` arguments, with support\nfor `HEq`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkCCHCongrTheorem\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">mkCCHCongrTheorem</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(fn : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(nargs : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheorem\">Mathlib.Tactic.CC.CCCongrTheorem</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L182-L186","name":"Mathlib.Tactic.CC.CCM.mkSymmCongruencesKey","line":182,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkSymmCongruencesKey","doc":"Return the `SymmCongruencesKey` associated with the equality `lhs = rhs`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkSymmCongruencesKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">mkSymmCongruencesKey</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(lhs rhs : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey\">Mathlib.Tactic.CC.SymmCongruencesKey</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L172-L180","name":"Mathlib.Tactic.CC.CCM.mkCongruencesKey","line":172,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkCongruencesKey","doc":"Return the `CongruencesKey` associated with an expression of the form `f a`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkCongruencesKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">mkCongruencesKey</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CongruencesKey\">Mathlib.Tactic.CC.CongruencesKey</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L122-L170","name":"Mathlib.Tactic.CC.CCM.isCongruent","line":122,"kind":"opaque","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.isCongruent","doc":"Return true iff the given function application are congruent\n\n`e₁` should have the form `f a` and `e₂` the form `g b`.\n\nSee paper: Congruence Closure for Intensional Type Theory. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.isCongruent\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">isCongruent</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e₁ e₂ : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L113-L120","name":"Mathlib.Tactic.CC.CCM.addOccurrence","line":113,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addOccurrence","doc":"Update the `child` so its parent becomes `parent`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addOccurrence\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">addOccurrence</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(parent child : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(symmTable : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L109-L111","name":"Mathlib.Tactic.CC.CCM.isCgRoot","line":109,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.isCgRoot","doc":"Is `e` the root of its congruence class? "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.isCgRoot\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">isCgRoot</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L105-L107","name":"Mathlib.Tactic.CC.CCM.getRoot","line":105,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getRoot","doc":"Return the root expression of the expression's congruence class. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getRoot\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">getRoot</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L100-L103","name":"Mathlib.Tactic.CC.CCM.pushReflEq","line":100,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.pushReflEq","doc":"Add `rfl : lhs = rhs` to the todo list. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.pushReflEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">pushReflEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(lhs rhs : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L95-L98","name":"Mathlib.Tactic.CC.CCM.pushHEq","line":95,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.pushHEq","doc":"Add the heterogeneous equality proof `H : HEq lhs rhs` to the end of the todo list. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.pushHEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">pushHEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(lhs rhs : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(H : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">Mathlib.Tactic.CC.EntryExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L90-L93","name":"Mathlib.Tactic.CC.CCM.pushEq","line":90,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.pushEq","doc":"Add the equality proof `H : lhs = rhs` to the end of the todo list. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.pushEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">pushEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(lhs rhs : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(H : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">Mathlib.Tactic.CC.EntryExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L84-L88","name":"Mathlib.Tactic.CC.CCM.pushTodo","line":84,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.pushTodo","doc":"Add a new entry to the end of the todo list.\n\nSee also `pushEq`, `pushHEq` and `pushReflEq`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.pushTodo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">pushTodo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(lhs rhs : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(H : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">Mathlib.Tactic.CC.EntryExpr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(heqProof : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L75-L82","name":"Mathlib.Tactic.CC.CCM.normalize","line":75,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.normalize","doc":"Use the normalizer to normalize `e`.\n\nIf no normalizer was configured, returns `e` itself. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.normalize\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">normalize</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L71-L73","name":"Mathlib.Tactic.CC.CCM.getEntry","line":71,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getEntry","doc":"Look up an entry associated with the given expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getEntry\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">getEntry</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.Entry\">Mathlib.Tactic.CC.Entry</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L66-L69","name":"Mathlib.Tactic.CC.CCM.getCache","line":66,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getCache","doc":"Read the `cache` field of the state. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getCache\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">getCache</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremCache\">Mathlib.Tactic.CC.CCCongrTheoremCache</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L61-L64","name":"Mathlib.Tactic.CC.CCM.getACTodo","line":61,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getACTodo","doc":"Read the `acTodo` field of the state. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getACTodo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">getACTodo</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACTodoEntry\">Mathlib.Tactic.CC.ACTodoEntry</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L56-L59","name":"Mathlib.Tactic.CC.CCM.getTodo","line":56,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getTodo","doc":"Read the `todo` field of the state. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getTodo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">getTodo</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.TodoEntry\">Mathlib.Tactic.CC.TodoEntry</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L51-L54","name":"Mathlib.Tactic.CC.CCM.modifyCache","line":51,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.modifyCache","doc":"Update the `cache` field of the state. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.modifyCache\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">modifyCache</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremCache\">Mathlib.Tactic.CC.CCCongrTheoremCache</a> → <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCCongrTheoremCache\">Mathlib.Tactic.CC.CCCongrTheoremCache</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L46-L49","name":"Mathlib.Tactic.CC.CCM.modifyACTodo","line":46,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.modifyACTodo","doc":"Update the `acTodo` field of the state. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.modifyACTodo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">modifyACTodo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACTodoEntry\">Mathlib.Tactic.CC.ACTodoEntry</a></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACTodoEntry\">Mathlib.Tactic.CC.ACTodoEntry</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L41-L44","name":"Mathlib.Tactic.CC.CCM.modifyTodo","line":41,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.modifyTodo","doc":"Update the `todo` field of the state. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.modifyTodo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">modifyTodo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.TodoEntry\">Mathlib.Tactic.CC.TodoEntry</a></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.TodoEntry\">Mathlib.Tactic.CC.TodoEntry</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L37-L39","name":"Mathlib.Tactic.CC.CCM.run","line":37,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.run","doc":"Run a computation in the `CCM` monad. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.run\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">run</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\">Mathlib.Tactic.CC.CCM</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure\">Mathlib.Tactic.CC.CCStructure</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCStructure\">Mathlib.Tactic.CC.CCStructure</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/CC/Addition.lean#L32-L33","name":"Mathlib.Tactic.CC.CCM","line":32,"kind":"def","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM","doc":"The monad for the `cc` tactic stores the current state of the tactic. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(α : <a href=\"./foundational_types.html\">Type</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"}]}