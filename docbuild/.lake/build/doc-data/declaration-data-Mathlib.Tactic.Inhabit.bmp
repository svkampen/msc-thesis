{"name":"Mathlib.Tactic.Inhabit","instances":[],"imports":["Init","Lean.Elab.Tactic.ElabTerm","Mathlib.Tactic.TypeStar"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Inhabit.lean#L34-L51","name":"Lean.Elab.Tactic.evalInhabit","line":34,"kind":"def","docLink":"./Mathlib/Tactic/Inhabit.html#Lean.Elab.Tactic.evalInhabit","doc":"`evalInhabit` takes in the MVarId of the main goal, runs the core portion of the inhabit tactic,\nand returns the resulting MVarId "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Inhabit.html#Lean.Elab.Tactic.evalInhabit\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">evalInhabit</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(goal : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h_name : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Meta.html#Lean.Syntax.Ident\">Lean.Ident</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(term : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Inhabit.lean#L27-L32","name":"Lean.Elab.Tactic.inhabit","line":27,"kind":"def","docLink":"./Mathlib/Tactic/Inhabit.html#Lean.Elab.Tactic.inhabit","doc":"`inhabit α` tries to derive a `Nonempty α` instance and\nthen uses it to make an `Inhabited α` instance.\nIf the target is a `Prop`, this is done constructively. Otherwise, it uses `Classical.choice`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Inhabit.html#Lean.Elab.Tactic.inhabit\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">inhabit</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Inhabit.lean#L22-L25","name":"Lean.Elab.Tactic.nonempty_prop_to_inhabited","line":22,"kind":"def","docLink":"./Mathlib/Tactic/Inhabit.html#Lean.Elab.Tactic.nonempty_prop_to_inhabited","doc":"Derives `Inhabited α` from `Nonempty α` without `Classical.choice`\nassuming `α` is of type `Prop`"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Inhabit.html#Lean.Elab.Tactic.nonempty_prop_to_inhabited\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">nonempty_prop_to_inhabited</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(α : <a href=\"./foundational_types.html\">Prop</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(α_nonempty : <span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Inhabit.lean#L18-L20","name":"Lean.Elab.Tactic.nonempty_to_inhabited","line":18,"kind":"def","docLink":"./Mathlib/Tactic/Inhabit.html#Lean.Elab.Tactic.nonempty_to_inhabited","doc":"Derives `Inhabited α` from `Nonempty α` with `Classical.choice`"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Inhabit.html#Lean.Elab.Tactic.nonempty_to_inhabited\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">nonempty_to_inhabited</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(α : <a href=\"./foundational_types.html\">Sort</a> u_1)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">α</span></span></span></div></div>"}]}