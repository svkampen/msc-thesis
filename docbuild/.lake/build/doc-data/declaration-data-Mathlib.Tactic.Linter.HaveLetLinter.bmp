{"name":"Mathlib.Tactic.Linter.HaveLetLinter","instances":[],"imports":["Init","Mathlib.Init","Lean.Elab.Command","Lean.Server.InfoUtils"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Linter/HaveLetLinter.lean#L116-L129","name":"Mathlib.Linter.haveLet.haveLetLinter","line":116,"kind":"def","docLink":"./Mathlib/Tactic/Linter/HaveLetLinter.html#Mathlib.Linter.haveLet.haveLetLinter","doc":"The main implementation of the `have` vs `let` linter. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linter/HaveLetLinter.html#Mathlib.Linter.haveLet.haveLetLinter\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Linter</span>.<span class=\"name\">haveLet</span>.<span class=\"name\">haveLetLinter</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Command.html#Lean.Elab.Command.Linter\">Lean.Linter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Linter/HaveLetLinter.lean#L85-L114","name":"Mathlib.Linter.haveLet.nonPropHaves","line":85,"kind":"def","docLink":"./Mathlib/Tactic/Linter/HaveLetLinter.html#Mathlib.Linter.haveLet.nonPropHaves","doc":"returns the `have` syntax whose corresponding hypothesis does not have Type `Prop` and\nalso a `Format`ted version of the corresponding Type. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linter/HaveLetLinter.html#Mathlib.Linter.haveLet.nonPropHaves\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Linter</span>.<span class=\"name\">haveLet</span>.<span class=\"name\">nonPropHaves</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/InfoTree/Types.html#Lean.Elab.InfoTree\">Lean.Elab.InfoTree</a> → <span class=\"fn\"><a href=\"./Lean/Elab/Command.html#Lean.Elab.Command.CommandElabM\">Lean.Elab.Command.CommandElabM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Data/Format/Basic.html#Std.Format\">Lean.Format</a>)</span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Linter/HaveLetLinter.lean#L69-L83","name":"Mathlib.Linter.haveLet.areProp_toFormat","line":69,"kind":"def","docLink":"./Mathlib/Tactic/Linter/HaveLetLinter.html#Mathlib.Linter.haveLet.areProp_toFormat","doc":"given a `ContextInfo`, a `LocalContext` and an `Array` of `Expr`essions `es`,\n`areProp_toFormat` creates a `MetaM` context, and returns an array of pairs consisting of\n* a `Bool`ean, answering the question of whether the Type of `e` is a `Prop` or not, and\n* the pretty-printed `Format` of `e`\nfor each `Expr`ession `e` in `es`.\nConcretely, `areProp_toFormat` runs `inferType` in `CommandElabM`.\nThis is the kind of monadic lift that `nonPropHaves` uses to decide whether the Type of a `have`\nis in `Prop` or not.\nThe output `Format` is just so that the linter displays a better message. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linter/HaveLetLinter.html#Mathlib.Linter.haveLet.areProp_toFormat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Linter</span>.<span class=\"name\">haveLet</span>.<span class=\"name\">areProp_toFormat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ctx : <a href=\"./Lean/Elab/InfoTree/Types.html#Lean.Elab.ContextInfo\">Lean.Elab.ContextInfo</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(lc : <a href=\"./Lean/LocalContext.html#Lean.LocalContext\">Lean.LocalContext</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(es : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Command.html#Lean.Elab.Command.CommandElabM\">Lean.Elab.Command.CommandElabM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Data/Format/Basic.html#Std.Format\">Lean.Format</a>)</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Linter/HaveLetLinter.lean#L63-L67","name":"Mathlib.Linter.haveLet.InfoTree.foldInfoM","line":63,"kind":"def","docLink":"./Mathlib/Tactic/Linter/HaveLetLinter.html#Mathlib.Linter.haveLet.InfoTree.foldInfoM","doc":"a monadic version of `Lean.Elab.InfoTree.foldInfo`.\nUsed to infer types inside a `CommandElabM`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linter/HaveLetLinter.html#Mathlib.Linter.haveLet.InfoTree.foldInfoM\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Linter</span>.<span class=\"name\">haveLet</span>.<span class=\"name\">InfoTree</span>.<span class=\"name\">foldInfoM</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{m : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> u_1 → <a href=\"./foundational_types.html\">Type</a> u_2</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><a href=\"./Lean/Elab/InfoTree/Types.html#Lean.Elab.ContextInfo\">Lean.Elab.ContextInfo</a> → <span class=\"fn\"><a href=\"./Lean/Elab/InfoTree/Types.html#Lean.Elab.Info\">Lean.Elab.Info</a> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">α</span></span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(init : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/InfoTree/Types.html#Lean.Elab.InfoTree\">Lean.Elab.InfoTree</a> → <span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Linter/HaveLetLinter.lean#L51-L55","name":"Mathlib.Linter.haveLet.isHave?","line":51,"kind":"def","docLink":"./Mathlib/Tactic/Linter/HaveLetLinter.html#Mathlib.Linter.haveLet.isHave?","doc":"find the `have` syntax. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linter/HaveLetLinter.html#Mathlib.Linter.haveLet.isHave?\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Linter</span>.<span class=\"name\">haveLet</span>.<span class=\"name\">isHave?</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Linter/HaveLetLinter.lean#L32-L47","name":"Mathlib.Linter.linter.haveLet","line":32,"kind":"opaque","docLink":"./Mathlib/Tactic/Linter/HaveLetLinter.html#Mathlib.Linter.linter.haveLet","doc":"The `have` vs `let` linter emits a warning on `have`s introducing a hypothesis whose\nType is not `Prop`.\nThere are three settings:\n* `0` -- inactive;\n* `1` -- active only on noisy declarations;\n* `2` or more -- always active.\n\nThe default value is `1`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linter/HaveLetLinter.html#Mathlib.Linter.linter.haveLet\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Linter</span>.<span class=\"name\">linter</span>.<span class=\"name\">haveLet</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/Options.html#Lean.Option\">Lean.Option</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span></div></div>"}]}