{"name":"Mathlib.CategoryTheory.DiscreteCategory","instances":[{"typeNames":["Eq"],"name":"CategoryTheory.instDecidableEqDiscrete","className":"Decidable"},{"typeNames":["CategoryTheory.Discrete"],"name":"CategoryTheory.discreteCategory","className":"CategoryTheory.Category"},{"typeNames":["CategoryTheory.Discrete"],"name":"CategoryTheory.Discrete.instInhabited","className":"Inhabited"},{"typeNames":["CategoryTheory.Discrete"],"name":"CategoryTheory.Discrete.instSubsingleton","className":"Subsingleton"},{"typeNames":["Quiver.Hom"],"name":"CategoryTheory.Discrete.instSubsingletonDiscreteHom","className":"Subsingleton"},{"typeNames":["CategoryTheory.Discrete"],"name":"CategoryTheory.Discrete.instUnique","className":"Unique"},{"typeNames":[],"name":"CategoryTheory.Discrete.instIsIso","className":"CategoryTheory.IsIso"},{"typeNames":["CategoryTheory.Discrete.natTrans"],"name":"CategoryTheory.Discrete.instIsIsoFunctorNatTrans","className":"CategoryTheory.IsIso"},{"typeNames":["CategoryTheory.Discrete"],"name":"CategoryTheory.Discrete.isDiscrete","className":"CategoryTheory.IsDiscrete"},{"typeNames":["Opposite"],"name":"CategoryTheory.instIsDiscreteOpposite","className":"CategoryTheory.IsDiscrete"}],"imports":["Init","Mathlib.CategoryTheory.EqToHom","Mathlib.CategoryTheory.Pi.Basic","Mathlib.Data.ULift"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L321-L325","name":"CategoryTheory.instIsDiscreteOpposite","line":321,"kind":"instance","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.instIsDiscreteOpposite","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.instIsDiscreteOpposite\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">instIsDiscreteOpposite</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(C : <a href=\"./foundational_types.html\">Type</a> u_1)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{u_2, u_1}</a>      <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.IsDiscrete\">CategoryTheory.IsDiscrete</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.IsDiscrete\">CategoryTheory.IsDiscrete</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L318-L319","name":"CategoryTheory.Discrete.isDiscrete","line":318,"kind":"instance","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.isDiscrete","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.isDiscrete\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">isDiscrete</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(C : <a href=\"./foundational_types.html\">Type</a> u_1)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.IsDiscrete\">CategoryTheory.IsDiscrete</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">C</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L315-L316","name":"CategoryTheory.obj_ext_of_isDiscrete","line":315,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.obj_ext_of_isDiscrete","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.obj_ext_of_isDiscrete\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">obj_ext_of_isDiscrete</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{u_2, u_1}</a>      <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.IsDiscrete\">CategoryTheory.IsDiscrete</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">Y</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L311-L311","name":"CategoryTheory.IsDiscrete.eq_of_hom","line":311,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.IsDiscrete.eq_of_hom","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.IsDiscrete.eq_of_hom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">IsDiscrete</span>.<span class=\"name\">eq_of_hom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{inst✝ : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{u_2, u_1}</a>      <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[self : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.IsDiscrete\">CategoryTheory.IsDiscrete</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X Y : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">Y</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L310-L310","name":"CategoryTheory.IsDiscrete.subsingleton","line":310,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.IsDiscrete.subsingleton","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.IsDiscrete.subsingleton\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">IsDiscrete</span>.<span class=\"name\">subsingleton</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{inst✝ : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{u_2, u_1}</a>      <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[self : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.IsDiscrete\">CategoryTheory.IsDiscrete</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(X Y : <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Core.html#Subsingleton\">Subsingleton</a> <span class=\"fn\">(<span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L309-L309","name":"CategoryTheory.IsDiscrete.mk","line":309,"kind":"ctor","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.IsDiscrete.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.IsDiscrete.mk\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">IsDiscrete</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{u_2, u_1}</a>      <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(subsingleton : <span class=\"fn\">∀ (<span class=\"fn\">X </span><span class=\"fn\">Y</span> : <span class=\"fn\">C</span>), <span class=\"fn\"><a href=\"./Init/Core.html#Subsingleton\">Subsingleton</a> <span class=\"fn\">(<span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span>)</span></span></span> := by infer_instance)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(eq_of_hom : <span class=\"fn\">∀ {<span class=\"fn\">X </span><span class=\"fn\">Y</span> : <span class=\"fn\">C</span>}, <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span>)</span> → <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">Y</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.IsDiscrete\">CategoryTheory.IsDiscrete</a> <span class=\"fn\">C</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L307-L311","name":"CategoryTheory.IsDiscrete","line":307,"kind":"class","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.IsDiscrete","doc":"A category is discrete when there is at most one morphism between two objects,\nin which case they are equal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">class</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.IsDiscrete\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">IsDiscrete</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(C : <a href=\"./foundational_types.html\">Type</a> u_1)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{u_2, u_1}</a>      <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L290-L290","name":"CategoryTheory.piEquivalenceFunctorDiscrete_counitIso","line":290,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.piEquivalenceFunctorDiscrete_counitIso","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.piEquivalenceFunctorDiscrete_counitIso\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">piEquivalenceFunctorDiscrete_counitIso</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(J : <a href=\"./foundational_types.html\">Type</a> u₂)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(C : <a href=\"./foundational_types.html\">Type</a> u₁)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₁, u₁}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.piEquivalenceFunctorDiscrete\">CategoryTheory.piEquivalenceFunctorDiscrete</a> <span class=\"fn\">J</span> <span class=\"fn\">C</span>)</span>.counitIso</span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents\">CategoryTheory.NatIso.ofComponents</a>\n    <span class=\"fn\">(fun (<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">J</span>)</span> <span class=\"fn\">C</span></span>) =&gt;\n      <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents\">CategoryTheory.NatIso.ofComponents</a>\n        <span class=\"fn\">(fun (<span class=\"fn\">x</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">J</span></span>) =&gt;\n          <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl\">CategoryTheory.Iso.refl</a>\n            <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">{ <span class=\"fn\">obj</span> := <span class=\"fn\">fun (<span class=\"fn\">F</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">J</span>)</span> <span class=\"fn\">C</span></span>) (<span class=\"fn\">j</span> : <span class=\"fn\">J</span>) =&gt; <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <span class=\"fn\">{ <span class=\"fn\">as</span> := <span class=\"fn\">j</span> }</span></span></span>,\n                          <span class=\"fn\">map</span> := <span class=\"fn\">fun {<span class=\"fn\">X </span><span class=\"fn\">Y</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">J</span>)</span> <span class=\"fn\">C</span></span>} (<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>) (<span class=\"fn\">j</span> : <span class=\"fn\">J</span>) =&gt;\n                            <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span>.app</span> <span class=\"fn\">{ <span class=\"fn\">as</span> := <span class=\"fn\">j</span> }</span></span></span>,\n                          <span class=\"fn\">map_id</span> := <span class=\"fn\">⋯</span>, <span class=\"fn\">map_comp</span> := <span class=\"fn\">⋯</span> }</span>.comp</span>\n                      <span class=\"fn\">{ <span class=\"fn\">obj</span> := <span class=\"fn\">fun (<span class=\"fn\">F</span> : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">C</span></span>) =&gt; <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">F</span></span></span>,\n                        <span class=\"fn\">map</span> := <span class=\"fn\">fun {<span class=\"fn\">X </span><span class=\"fn\">Y</span> : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">C</span></span>} (<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>) =&gt;\n                          <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natTrans\">CategoryTheory.Discrete.natTrans</a> <span class=\"fn\">fun (<span class=\"fn\">j</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">J</span></span>) =&gt; <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\"><span class=\"fn\">j</span>.as</span></span></span></span></span>,\n                        <span class=\"fn\">map_id</span> := <span class=\"fn\">⋯</span>, <span class=\"fn\">map_comp</span> := <span class=\"fn\">⋯</span> }</span>)</span>.obj</span>\n                  <span class=\"fn\">F</span>)</span>.obj</span>\n              <span class=\"fn\">x</span>)</span></span>)</span>\n        <span class=\"fn\">⋯</span></span>)</span>\n    <span class=\"fn\">⋯</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L290-L290","name":"CategoryTheory.piEquivalenceFunctorDiscrete_functor_map","line":290,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.piEquivalenceFunctorDiscrete_functor_map","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.piEquivalenceFunctorDiscrete_functor_map\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">piEquivalenceFunctorDiscrete_functor_map</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(J : <a href=\"./foundational_types.html\">Type</a> u₂)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(C : <a href=\"./foundational_types.html\">Type</a> u₁)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₁, u₁}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X✝ Y✝ : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X✝</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y✝</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.piEquivalenceFunctorDiscrete\">CategoryTheory.piEquivalenceFunctorDiscrete</a> <span class=\"fn\">J</span> <span class=\"fn\">C</span>)</span>.functor</span>.map</span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natTrans\">CategoryTheory.Discrete.natTrans</a> <span class=\"fn\">fun (<span class=\"fn\">j</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">J</span></span>) =&gt; <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\"><span class=\"fn\">j</span>.as</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L290-L290","name":"CategoryTheory.piEquivalenceFunctorDiscrete_functor_obj","line":290,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.piEquivalenceFunctorDiscrete_functor_obj","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.piEquivalenceFunctorDiscrete_functor_obj\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">piEquivalenceFunctorDiscrete_functor_obj</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(J : <a href=\"./foundational_types.html\">Type</a> u₂)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(C : <a href=\"./foundational_types.html\">Type</a> u₁)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₁, u₁}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.piEquivalenceFunctorDiscrete\">CategoryTheory.piEquivalenceFunctorDiscrete</a> <span class=\"fn\">J</span> <span class=\"fn\">C</span>)</span>.functor</span>.obj</span> <span class=\"fn\">F</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">F</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L290-L290","name":"CategoryTheory.piEquivalenceFunctorDiscrete_inverse_map","line":290,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.piEquivalenceFunctorDiscrete_inverse_map","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.piEquivalenceFunctorDiscrete_inverse_map\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">piEquivalenceFunctorDiscrete_inverse_map</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(J : <a href=\"./foundational_types.html\">Type</a> u₂)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(C : <a href=\"./foundational_types.html\">Type</a> u₁)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₁, u₁}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X✝ Y✝ : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">J</span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">X✝</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y✝</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.piEquivalenceFunctorDiscrete\">CategoryTheory.piEquivalenceFunctorDiscrete</a> <span class=\"fn\">J</span> <span class=\"fn\">C</span>)</span>.inverse</span>.map</span> <span class=\"fn\">f</span> <span class=\"fn\">j</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span>.app</span> <span class=\"fn\">{ <span class=\"fn\">as</span> := <span class=\"fn\">j</span> }</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L290-L290","name":"CategoryTheory.piEquivalenceFunctorDiscrete_inverse_obj","line":290,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.piEquivalenceFunctorDiscrete_inverse_obj","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.piEquivalenceFunctorDiscrete_inverse_obj\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">piEquivalenceFunctorDiscrete_inverse_obj</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(J : <a href=\"./foundational_types.html\">Type</a> u₂)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(C : <a href=\"./foundational_types.html\">Type</a> u₁)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₁, u₁}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">J</span>)</span> <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\">J</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.piEquivalenceFunctorDiscrete\">CategoryTheory.piEquivalenceFunctorDiscrete</a> <span class=\"fn\">J</span> <span class=\"fn\">C</span>)</span>.inverse</span>.obj</span> <span class=\"fn\">F</span> <span class=\"fn\">j</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <span class=\"fn\">{ <span class=\"fn\">as</span> := <span class=\"fn\">j</span> }</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L290-L290","name":"CategoryTheory.piEquivalenceFunctorDiscrete_unitIso","line":290,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.piEquivalenceFunctorDiscrete_unitIso","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.piEquivalenceFunctorDiscrete_unitIso\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">piEquivalenceFunctorDiscrete_unitIso</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(J : <a href=\"./foundational_types.html\">Type</a> u₂)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(C : <a href=\"./foundational_types.html\">Type</a> u₁)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₁, u₁}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.piEquivalenceFunctorDiscrete\">CategoryTheory.piEquivalenceFunctorDiscrete</a> <span class=\"fn\">J</span> <span class=\"fn\">C</span>)</span>.unitIso</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl\">CategoryTheory.Iso.refl</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id\">CategoryTheory.Functor.id</a> <span class=\"fn\">(<span class=\"fn\">J</span> → <span class=\"fn\">C</span>)</span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L289-L305","name":"CategoryTheory.piEquivalenceFunctorDiscrete","line":289,"kind":"def","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.piEquivalenceFunctorDiscrete","doc":"The equivalence of categories `(J → C) ≌ (Discrete J ⥤ C)`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.piEquivalenceFunctorDiscrete\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">piEquivalenceFunctorDiscrete</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(J : <a href=\"./foundational_types.html\">Type</a> u₂)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(C : <a href=\"./foundational_types.html\">Type</a> u₁)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₁, u₁}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">C</span></span> <a href=\"./Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence\">≌</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">J</span>)</span> <span class=\"fn\">C</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L280-L285","name":"CategoryTheory.Discrete.functor_map_id","line":280,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor_map_id","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor_map_id\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">functor_map_id</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> v₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">J</span>)</span> <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{j : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">J</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">j</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">j</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map</span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryTheory.CategoryStruct.id</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <span class=\"fn\">j</span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L270-L270","name":"CategoryTheory.Discrete.opposite_functor_obj_as","line":270,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.opposite_functor_obj_as","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.opposite_functor_obj_as\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">opposite_functor_obj_as</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(α : <a href=\"./foundational_types.html\">Type</a> u₁)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span>)</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.opposite\">CategoryTheory.Discrete.opposite</a> <span class=\"fn\">α</span>)</span>.functor</span>.obj</span> <span class=\"fn\">X</span>)</span>.as</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Data/Opposite.html#Opposite.unop\">Opposite.unop</a> <span class=\"fn\">X</span>)</span>.as</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L270-L270","name":"CategoryTheory.Discrete.opposite_inverse_obj","line":270,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.opposite_inverse_obj","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.opposite_inverse_obj\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">opposite_inverse_obj</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(α : <a href=\"./foundational_types.html\">Type</a> u₁)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a✝ : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.opposite\">CategoryTheory.Discrete.opposite</a> <span class=\"fn\">α</span>)</span>.inverse</span>.obj</span> <span class=\"fn\">a✝</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <span class=\"fn\">a✝</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L269-L276","name":"CategoryTheory.Discrete.opposite","line":269,"kind":"def","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.opposite","doc":"A discrete category is equivalent to its opposite category. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.opposite\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">opposite</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(α : <a href=\"./foundational_types.html\">Type</a> u₁)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span>)</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence\">≌</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L254-L254","name":"CategoryTheory.Discrete.equivOfEquivalence_symm_apply","line":254,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivOfEquivalence_symm_apply","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivOfEquivalence_symm_apply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">equivOfEquivalence_symm_apply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span> <a href=\"./Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence\">≌</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">β</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a✝ : <span class=\"fn\">β</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivOfEquivalence\">CategoryTheory.Discrete.equivOfEquivalence</a> <span class=\"fn\">h</span>)</span>.symm</span> <span class=\"fn\">a✝</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\">CategoryTheory.Discrete.as</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">h</span>.inverse</span>.obj</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">CategoryTheory.Discrete.mk</span></span>)</span> <span class=\"fn\">a✝</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L254-L254","name":"CategoryTheory.Discrete.equivOfEquivalence_apply","line":254,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivOfEquivalence_apply","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivOfEquivalence_apply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">equivOfEquivalence_apply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span> <a href=\"./Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence\">≌</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">β</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a✝ : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivOfEquivalence\">CategoryTheory.Discrete.equivOfEquivalence</a> <span class=\"fn\">h</span>)</span> <span class=\"fn\">a✝</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\">CategoryTheory.Discrete.as</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">h</span>.functor</span>.obj</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">CategoryTheory.Discrete.mk</span></span>)</span> <span class=\"fn\">a✝</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L253-L259","name":"CategoryTheory.Discrete.equivOfEquivalence","line":253,"kind":"def","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivOfEquivalence","doc":"We can convert an equivalence of `discrete` categories to a type-level `Equiv`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivOfEquivalence\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">equivOfEquivalence</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span> <a href=\"./Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence\">≌</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">β</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">α</span> <a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv\">≃</a> <span class=\"fn\">β</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L244-L244","name":"CategoryTheory.Discrete.equivalence_functor","line":244,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivalence_functor","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivalence_functor\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">equivalence_functor</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(e : <span class=\"fn\"><span class=\"fn\">I</span> <a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv\">≃</a> <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivalence\">CategoryTheory.Discrete.equivalence</a> <span class=\"fn\">e</span>)</span>.functor</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">(<span class=\"fn\">CategoryTheory.Discrete.mk</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">⇑<span class=\"fn\">e</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L244-L244","name":"CategoryTheory.Discrete.equivalence_inverse","line":244,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivalence_inverse","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivalence_inverse\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">equivalence_inverse</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(e : <span class=\"fn\"><span class=\"fn\">I</span> <a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv\">≃</a> <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivalence\">CategoryTheory.Discrete.equivalence</a> <span class=\"fn\">e</span>)</span>.inverse</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">(<span class=\"fn\">CategoryTheory.Discrete.mk</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">⇑<span class=\"fn\"><span class=\"fn\">e</span>.symm</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L244-L244","name":"CategoryTheory.Discrete.equivalence_counitIso","line":244,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivalence_counitIso","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivalence_counitIso\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">equivalence_counitIso</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(e : <span class=\"fn\"><span class=\"fn\">I</span> <a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv\">≃</a> <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivalence\">CategoryTheory.Discrete.equivalence</a> <span class=\"fn\">e</span>)</span>.counitIso</span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natIso\">CategoryTheory.Discrete.natIso</a> <span class=\"fn\">fun (<span class=\"fn\">j</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">J</span></span>) =&gt; <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToIso\">CategoryTheory.eqToIso</a> <span class=\"fn\">⋯</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L244-L244","name":"CategoryTheory.Discrete.equivalence_unitIso","line":244,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivalence_unitIso","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivalence_unitIso\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">equivalence_unitIso</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(e : <span class=\"fn\"><span class=\"fn\">I</span> <a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv\">≃</a> <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivalence\">CategoryTheory.Discrete.equivalence</a> <span class=\"fn\">e</span>)</span>.unitIso</span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natIso\">CategoryTheory.Discrete.natIso</a> <span class=\"fn\">fun (<span class=\"fn\">i</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>) =&gt; <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToIso\">CategoryTheory.eqToIso</a> <span class=\"fn\">⋯</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L241-L251","name":"CategoryTheory.Discrete.equivalence","line":241,"kind":"def","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivalence","doc":"We can promote a type-level `Equiv` to\nan equivalence between the corresponding `discrete` categories.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivalence\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">equivalence</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(e : <span class=\"fn\"><span class=\"fn\">I</span> <a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv\">≃</a> <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span> <a href=\"./Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence\">≌</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">J</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L235-L239","name":"CategoryTheory.Discrete.compNatIsoDiscrete","line":235,"kind":"def","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.compNatIsoDiscrete","doc":"Composing `Discrete.functor F` with another functor `G` amounts to composing `F` with `G.obj` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.compNatIsoDiscrete\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">compNatIsoDiscrete</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{D : <a href=\"./foundational_types.html\">Type</a> u₃}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₃, u₃}</a>     <span class=\"fn\">D</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(G : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">C</span> <span class=\"fn\">D</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">F</span>)</span>.comp</span> <span class=\"fn\">G</span></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">G</span>.obj</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">F</span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L229-L233","name":"CategoryTheory.Discrete.natIsoFunctor","line":229,"kind":"def","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natIsoFunctor","doc":"Every functor `F` from a discrete category is naturally isomorphic (actually, equal) to\n`Discrete.functor (F.obj)`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natIsoFunctor\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">natIsoFunctor</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">F</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">CategoryTheory.Discrete.mk</span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L225-L227","name":"CategoryTheory.Discrete.natIso_app","line":225,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natIso_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natIso_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">natIso_app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F G : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <span class=\"fn\">i</span></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.obj</span> <span class=\"fn\">i</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natIso\">CategoryTheory.Discrete.natIso</a> <span class=\"fn\">f</span>)</span>.app</span> <span class=\"fn\">i</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">i</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L220-L223","name":"CategoryTheory.Discrete.instIsIsoFunctorNatTrans","line":220,"kind":"instance","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.instIsIsoFunctorNatTrans","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.instIsIsoFunctorNatTrans\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">instIsIsoFunctorNatTrans</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F G : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <span class=\"fn\">i</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.obj</span> <span class=\"fn\">i</span></span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">∀ (<span class=\"fn\">i</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>), <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso\">CategoryTheory.IsIso</a> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">i</span>)</span></span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso\">CategoryTheory.IsIso</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natTrans\">CategoryTheory.Discrete.natTrans</a> <span class=\"fn\">f</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L211-L211","name":"CategoryTheory.Discrete.natIso_hom_app","line":211,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natIso_hom_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natIso_hom_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">natIso_hom_app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F G : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <span class=\"fn\">i</span></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.obj</span> <span class=\"fn\">i</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natIso\">CategoryTheory.Discrete.natIso</a> <span class=\"fn\">f</span>)</span>.hom</span>.app</span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">X</span>)</span>.hom</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L211-L211","name":"CategoryTheory.Discrete.natIso_inv_app","line":211,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natIso_inv_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natIso_inv_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">natIso_inv_app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F G : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <span class=\"fn\">i</span></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.obj</span> <span class=\"fn\">i</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natIso\">CategoryTheory.Discrete.natIso</a> <span class=\"fn\">f</span>)</span>.inv</span>.app</span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">X</span>)</span>.inv</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L207-L218","name":"CategoryTheory.Discrete.natIso","line":207,"kind":"def","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natIso","doc":"For functors out of a discrete category,\na natural isomorphism is just a collection of isomorphisms,\nas the naturality squares are trivial.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natIso\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">natIso</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F G : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <span class=\"fn\">i</span></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.obj</span> <span class=\"fn\">i</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">F</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\">G</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L197-L197","name":"CategoryTheory.Discrete.natTrans_app","line":197,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natTrans_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natTrans_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">natTrans_app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F G : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <span class=\"fn\">i</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.obj</span> <span class=\"fn\">i</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natTrans\">CategoryTheory.Discrete.natTrans</a> <span class=\"fn\">f</span>)</span>.app</span> <span class=\"fn\">i</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">i</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L193-L205","name":"CategoryTheory.Discrete.natTrans","line":193,"kind":"def","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natTrans","doc":"For functors out of a discrete category,\na natural transformation is just a collection of maps,\nas the naturality squares are trivial.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natTrans\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">natTrans</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F G : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <span class=\"fn\">i</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.obj</span> <span class=\"fn\">i</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">F</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">G</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L188-L188","name":"CategoryTheory.Discrete.functorComp_inv_app","line":188,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functorComp_inv_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functorComp_inv_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">functorComp_inv_app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> u₁'}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functorComp\">CategoryTheory.Discrete.functorComp</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span>)</span>.inv</span>.app</span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryTheory.CategoryStruct.id</a> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">(<span class=\"fn\">g</span> <span class=\"fn\"><span class=\"fn\">X</span>.as</span>)</span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L188-L188","name":"CategoryTheory.Discrete.functorComp_hom_app","line":188,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functorComp_hom_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functorComp_hom_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">functorComp_hom_app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> u₁'}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functorComp\">CategoryTheory.Discrete.functorComp</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span>)</span>.hom</span>.app</span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryTheory.CategoryStruct.id</a> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">(<span class=\"fn\">g</span> <span class=\"fn\"><span class=\"fn\">X</span>.as</span>)</span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L185-L191","name":"CategoryTheory.Discrete.functorComp","line":185,"kind":"def","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functorComp","doc":"The discrete functor induced by a composition of maps can be written as a\ncomposition of two discrete functors.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functorComp\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">functorComp</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> u₁'}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">(<span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">g</span>)</span></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a>   <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">(<span class=\"fn\">CategoryTheory.Discrete.mk</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">g</span>)</span>)</span>.comp</span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">f</span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L182-L183","name":"CategoryTheory.Discrete.CategoryTheory.FreeMonoidalCategory.discrete_functor_obj_eq_as","line":182,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.CategoryTheory.FreeMonoidalCategory.discrete_functor_obj_eq_as","doc":"**Alias** of `CategoryTheory.Discrete.functor_obj_eq_as`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.CategoryTheory.FreeMonoidalCategory.discrete_functor_obj_eq_as\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">CategoryTheory</span>.<span class=\"name\">FreeMonoidalCategory</span>.<span class=\"name\">discrete_functor_obj_eq_as</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">F</span>)</span>.obj</span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">F</span> <span class=\"fn\"><span class=\"fn\">X</span>.as</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L178-L181","name":"CategoryTheory.Discrete.functor_obj_eq_as","line":178,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor_obj_eq_as","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor_obj_eq_as\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">functor_obj_eq_as</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">F</span>)</span>.obj</span> <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">F</span> <span class=\"fn\"><span class=\"fn\">X</span>.as</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L175-L176","name":"CategoryTheory.Discrete.CategoryTheory.FreeMonoidalCategory.discrete_functor_map_eq_id","line":175,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.CategoryTheory.FreeMonoidalCategory.discrete_functor_map_eq_id","doc":"**Alias** of `CategoryTheory.Discrete.functor_map`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.CategoryTheory.FreeMonoidalCategory.discrete_functor_map_eq_id\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">CategoryTheory</span>.<span class=\"name\">FreeMonoidalCategory</span>.<span class=\"name\">discrete_functor_map_eq_id</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{i : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">i</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">i</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">F</span>)</span>.map</span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryTheory.CategoryStruct.id</a> <span class=\"fn\">(<span class=\"fn\">F</span> <span class=\"fn\"><span class=\"fn\">i</span>.as</span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L172-L174","name":"CategoryTheory.Discrete.functor_map","line":172,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor_map","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor_map\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">functor_map</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{i : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">i</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">i</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">F</span>)</span>.map</span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryTheory.CategoryStruct.id</a> <span class=\"fn\">(<span class=\"fn\">F</span> <span class=\"fn\"><span class=\"fn\">i</span>.as</span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L167-L170","name":"CategoryTheory.Discrete.functor_obj","line":167,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor_obj","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor_obj\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">functor_obj</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\">I</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">F</span>)</span>.obj</span> <span class=\"fn\">{ <span class=\"fn\">as</span> := <span class=\"fn\">i</span> }</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">F</span> <span class=\"fn\">i</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L159-L165","name":"CategoryTheory.Discrete.functor","line":159,"kind":"def","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor","doc":"Any function `I → C` gives a functor `Discrete I ⥤ C`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">functor</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span>)</span> <span class=\"fn\">C</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L153-L154","name":"CategoryTheory.Discrete.instIsIso","line":153,"kind":"instance","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.instIsIso","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.instIsIso\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">instIsIso</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{i j : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">i</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">j</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso\">CategoryTheory.IsIso</a> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L147-L149","name":"CategoryTheory.Discrete.id_def","line":147,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.id_def","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.id_def\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">id_def</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">{ <span class=\"fn\">down</span> := <span class=\"fn\">{ <span class=\"fn\">down</span> := <span class=\"fn\">⋯</span> }</span> }</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryTheory.CategoryStruct.id</a> <span class=\"fn\">X</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L143-L145","name":"CategoryTheory.Discrete.eqToIso'","line":143,"kind":"def","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.eqToIso'","doc":"A variant of `eqToIso` that lifts terms to the discrete category. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.eqToIso'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">eqToIso'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{a b : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">{ <span class=\"fn\">as</span> := <span class=\"fn\">a</span> }</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\">{ <span class=\"fn\">as</span> := <span class=\"fn\">b</span> }</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L139-L141","name":"CategoryTheory.Discrete.eqToHom'","line":139,"kind":"def","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.eqToHom'","doc":"A variant of `eqToHom` that lifts terms to the discrete category. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.eqToHom'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">eqToHom'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{a b : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">{ <span class=\"fn\">as</span> := <span class=\"fn\">a</span> }</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">{ <span class=\"fn\">as</span> := <span class=\"fn\">b</span> }</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L134-L137","name":"CategoryTheory.Discrete.eqToIso","line":134,"kind":"def","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.eqToIso","doc":"Promote an equation between the wrapped terms in `X Y : Discrete α` to an isomorphism `X ≅ Y`\nin the discrete category. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.eqToIso\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">eqToIso</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X Y : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">X</span>.as</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">Y</span>.as</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\">Y</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L129-L132","name":"CategoryTheory.Discrete.eqToHom","line":129,"kind":"def","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.eqToHom","doc":"Promote an equation between the wrapped terms in `X Y : Discrete α` to a morphism `X ⟶ Y`\nin the discrete category. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.eqToHom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">eqToHom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X Y : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">X</span>.as</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">Y</span>.as</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L125-L127","name":"CategoryTheory.Discrete.eq_of_hom","line":125,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.eq_of_hom","doc":"Extract the equation from a morphism in a discrete category. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.eq_of_hom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">eq_of_hom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X Y : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">X</span>.as</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">Y</span>.as</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L122-L123","name":"CategoryTheory.Discrete.instUnique","line":122,"kind":"instance","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.instUnique","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.instUnique\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">instUnique</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Logic/Unique.html#Unique\">Unique</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Unique.html#Unique\">Unique</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L103-L113","name":"CategoryTheory.Discrete.discreteCases","line":103,"kind":"def","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.discreteCases","doc":"Use:\n```\nattribute [local aesop safe tactic (rule_sets := [CategoryTheory])]\n  CategoryTheory.Discrete.discreteCases\n```\nto locally gives `aesop_cat` the ability to call `cases` on\n`Discrete` and `(_ : Discrete _) ⟶ (_ : Discrete _)` hypotheses.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.discreteCases\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">discreteCases</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L99-L100","name":"CategoryTheory.Discrete.tacticDiscrete_cases","line":99,"kind":"def","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.tacticDiscrete_cases","doc":"A simple tactic to run `cases` on any `Discrete α` hypotheses. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.tacticDiscrete_cases\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">tacticDiscrete_cases</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L94-L95","name":"CategoryTheory.Discrete.instSubsingletonDiscreteHom","line":94,"kind":"instance","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.instSubsingletonDiscreteHom","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.instSubsingletonDiscreteHom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">instSubsingletonDiscreteHom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(X Y : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Core.html#Subsingleton\">Subsingleton</a> <span class=\"fn\">(<span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L91-L92","name":"CategoryTheory.Discrete.instSubsingleton","line":91,"kind":"instance","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.instSubsingleton","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.instSubsingleton\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">instSubsingleton</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Core.html#Subsingleton\">Subsingleton</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Core.html#Subsingleton\">Subsingleton</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L88-L89","name":"CategoryTheory.Discrete.instInhabited","line":88,"kind":"instance","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.instInhabited","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.instInhabited\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">instInhabited</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L67-L82","name":"CategoryTheory.discreteCategory","line":67,"kind":"instance","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.discreteCategory","doc":"The \"Discrete\" category on a type, whose morphisms are equalities.\n\nBecause we do not allow morphisms in `Prop` (only in `Type`),\nsomewhat annoyingly we have to define `X ⟶ Y` as `ULift (PLift (X = Y))`.\n\nSee <https://stacks.math.columbia.edu/tag/001A>\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.discreteCategory\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">discreteCategory</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(α : <a href=\"./foundational_types.html\">Type</a> u₁)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory\">CategoryTheory.SmallCategory</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L64-L65","name":"CategoryTheory.instDecidableEqDiscrete","line":64,"kind":"instance","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.instDecidableEqDiscrete","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.instDecidableEqDiscrete\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">instDecidableEqDiscrete</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L57-L57","name":"CategoryTheory.discreteEquiv_symm_apply_as","line":57,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.discreteEquiv_symm_apply_as","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.discreteEquiv_symm_apply_as\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">discreteEquiv_symm_apply_as</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(as : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">CategoryTheory.discreteEquiv</span>.symm</span> <span class=\"fn\">as</span>)</span>.as</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">as</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L57-L57","name":"CategoryTheory.discreteEquiv_apply","line":57,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.discreteEquiv_apply","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.discreteEquiv_apply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">discreteEquiv_apply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(self : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">CategoryTheory.discreteEquiv</span> <span class=\"fn\">self</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">self</span>.as</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L56-L62","name":"CategoryTheory.discreteEquiv","line":56,"kind":"def","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.discreteEquiv","doc":"`Discrete α` is equivalent to the original type `α`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.discreteEquiv\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">discreteEquiv</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span> <a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv\">≃</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L52-L54","name":"CategoryTheory.Discrete.mk_as","line":52,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.mk_as","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.mk_as\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">mk_as</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">{ <span class=\"fn\">as</span> := <span class=\"fn\"><span class=\"fn\">X</span>.as</span> }</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">X</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L50-L50","name":"CategoryTheory.Discrete.as","line":50,"kind":"def","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.as","doc":"A wrapper for promoting any type to a category,\nwith the only morphisms being equalities. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.as\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">as</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(self : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">α</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L47-L47","name":"CategoryTheory.Discrete.mk","line":47,"kind":"ctor","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.mk\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(as : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L46-L46","name":"CategoryTheory.Discrete.ext","line":46,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.ext","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{x y : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(as : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">x</span>.as</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">y</span>.as</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/CategoryTheory/DiscreteCategory.lean#L43-L50","name":"CategoryTheory.Discrete","line":43,"kind":"structure","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete","doc":"A wrapper for promoting any type to a category,\nwith the only morphisms being equalities.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(α : <a href=\"./foundational_types.html\">Type</a> u₁)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u₁</div></div>"}]}