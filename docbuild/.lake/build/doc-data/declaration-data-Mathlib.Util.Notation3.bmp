{"name":"Mathlib.Util.Notation3","instances":[{"typeNames":["Mathlib.Notation3.Matcher"],"name":"Mathlib.Notation3.instMatcherInhabited","className":"Inhabited"}],"imports":["Init","Lean.Elab.BuiltinCommand","Lean.Elab.MacroArgUtil","Mathlib.Lean.Elab.Term","Mathlib.Lean.PrettyPrinter.Delaborator","Mathlib.Tactic.ScopedNS","Batteries.Linter.UnreachableTactic","Batteries.Util.ExtendedBinder","Batteries.Lean.Syntax"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L445-L615","name":"Mathlib.Notation3.notation3","line":445,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.notation3","doc":"`notation3` declares notation using Lean-3-style syntax.\n\nExamples:\n```\nnotation3 \"∀ᶠ \" (...) \" in \" f \", \" r:(scoped p => Filter.eventually p f) => r\nnotation3 \"MyList[\" (x\", \"* => foldr (a b => MyList.cons a b) MyList.nil) \"]\" => x\n```\nBy default notation is unable to mention any variables defined using `variable`, but\n`local notation3` is able to use such local variables.\n\nUse `notation3 (prettyPrint := false)` to keep the command from generating a pretty printer\nfor the notation.\n\nThis command can be used in mathlib4 but it has an uncertain future and was created primarily\nfor backward compatibility.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.notation3\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">notation3</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L436-L443","name":"Mathlib.Notation3.getPrettyPrintOpt","line":436,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.getPrettyPrintOpt","doc":"Interpret a `prettyPrintOpt`. The default value is `true`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.getPrettyPrintOpt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">getPrettyPrintOpt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(opt? : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Mathlib.Notation3.prettyPrintOpt</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L434-L434","name":"Mathlib.Notation3.prettyPrintOpt","line":434,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.prettyPrintOpt","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.prettyPrintOpt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">prettyPrintOpt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L431-L432","name":"Mathlib.Notation3.BoundValueType.foldr","line":431,"kind":"ctor","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.BoundValueType.foldr","doc":"A fold variable, use the fold state (do not reverse the array). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.BoundValueType.foldr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">BoundValueType</span>.<span class=\"name\">foldr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.BoundValueType\">Mathlib.Notation3.BoundValueType</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L429-L430","name":"Mathlib.Notation3.BoundValueType.foldl","line":429,"kind":"ctor","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.BoundValueType.foldl","doc":"A fold variable, use the fold state (but reverse the array). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.BoundValueType.foldl\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">BoundValueType</span>.<span class=\"name\">foldl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.BoundValueType\">Mathlib.Notation3.BoundValueType</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L427-L428","name":"Mathlib.Notation3.BoundValueType.normal","line":427,"kind":"ctor","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.BoundValueType.normal","doc":"A normal variable, delaborate its expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.BoundValueType.normal\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">BoundValueType</span>.<span class=\"name\">normal</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.BoundValueType\">Mathlib.Notation3.BoundValueType</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L424-L432","name":"Mathlib.Notation3.BoundValueType","line":424,"kind":"inductive","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.BoundValueType","doc":"Used when processing different kinds of variables when building the\nfinal delaborator. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.BoundValueType\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">BoundValueType</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L412-L422","name":"Mathlib.Notation3.mkNameFromSyntax","line":412,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.mkNameFromSyntax","doc":"Create a name that we can use for the `syntax` definition, using the\nalgorithm from `notation`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.mkNameFromSyntax\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">mkNameFromSyntax</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(name? : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Command.namedName</span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(syntaxArgs : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`stx</span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(attrKind : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Term.attrKind</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Command.html#Lean.Elab.Command.CommandElabM\">Lean.Elab.Command.CommandElabM</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L399-L408","name":"Mathlib.Notation3.mkFoldrMatcher","line":399,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.mkFoldrMatcher","doc":"Create a `Term` that represents a matcher for `foldr` notation.\nReminder: `( lit \",\"* => foldr (x y => scopedTerm) init)` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.mkFoldrMatcher\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">mkFoldrMatcher</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(lit x y : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(scopedTerm init : <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(boundNames : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Control/Option.html#OptionT\">OptionT</a> <a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L389-L397","name":"Mathlib.Notation3.mkFoldlMatcher","line":389,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.mkFoldlMatcher","doc":"Create a `Term` that represents a matcher for `foldl` notation.\nReminder: `( lit \",\"* => foldl (x y => scopedTerm) init)` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.mkFoldlMatcher\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">mkFoldlMatcher</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(lit x y : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(scopedTerm init : <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(boundNames : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Control/Option.html#OptionT\">OptionT</a> <a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L368-L387","name":"Mathlib.Notation3.matchFoldl","line":368,"kind":"opaque","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.matchFoldl","doc":"Matcher for expressions produced by `foldl`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.matchFoldl\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">matchFoldl</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(lit x y : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(smatcher sinit : <a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.Matcher\">Mathlib.Notation3.Matcher</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.Matcher\">Mathlib.Notation3.Matcher</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L358-L366","name":"Mathlib.Notation3.mkScopedMatcher","line":358,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.mkScopedMatcher","doc":"Create a `Term` that represents a matcher for `scoped` notation.\nFails in the `OptionT` sense if a matcher couldn't be constructed.\nAlso returns a delaborator key like in `mkExprMatcher`.\nReminder: `$lit:ident : (scoped $scopedId:ident => $scopedTerm:Term)` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.mkScopedMatcher\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">mkScopedMatcher</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(lit scopeId : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(scopedTerm : <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(boundNames : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Control/Option.html#OptionT\">OptionT</a> <a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L322-L356","name":"Mathlib.Notation3.matchScoped.go","line":322,"kind":"opaque","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.matchScoped.go","doc":"Variant of `matchScoped` after some number of `binders` have already been captured. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.matchScoped.go\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">matchScoped</span>.<span class=\"name\">go</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(lit scopeId : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(smatcher : <a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.Matcher\">Mathlib.Notation3.Matcher</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(binders : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Batteries.ExtendedBinder.extBinderParenthesized</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState\">Mathlib.Notation3.MatchState</a> → <span class=\"fn\"><a href=\"./Lean/PrettyPrinter/Delaborator/Basic.html#Lean.PrettyPrinter.Delaborator.DelabM\">Lean.PrettyPrinter.Delaborator.DelabM</a> <a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState\">Mathlib.Notation3.MatchState</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L315-L356","name":"Mathlib.Notation3.matchScoped","line":315,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.matchScoped","doc":"Matcher for processing `scoped` syntax. Assumes the expression to be matched\nagainst is in the `lit` variable.\n\nRuns `smatcher`, extracts the resulting `scopeId` variable, processes this value\n(which must be a lambda) to produce a binder, and loops. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.matchScoped\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">matchScoped</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(lit scopeId : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(smatcher : <a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.Matcher\">Mathlib.Notation3.Matcher</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.Matcher\">Mathlib.Notation3.Matcher</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L293-L313","name":"Mathlib.Notation3.mkExprMatcher","line":293,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.mkExprMatcher","doc":"Returns a `Term` that represents a `Matcher` for the given pattern `stx`.\nThe `boundNames` set determines which identifiers are variables in the pattern.\nFails in the `OptionT` sense if it comes across something it's unable to handle.\n\nAlso returns constant names that could serve as a key for a delaborator.\nFor example, if it's for a function `f`, then `app.f`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.mkExprMatcher\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">mkExprMatcher</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(stx : <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(boundNames : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Control/Option.html#OptionT\">OptionT</a> <a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L220-L291","name":"Mathlib.Notation3.exprToMatcher","line":220,"kind":"opaque","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.exprToMatcher","doc":"Given an expression, generate a matcher for it.\nThe `boundFVars` hash map records which state variables certain fvars correspond to.\nThe `localFVars` hash map records which local variable the matcher should use for an exact\nexpression match.\n\nIf it succeeds generating a matcher, returns\n1. a list of keys that should be used for the `delab` attribute\n   when defining the elaborator\n2. a `Term` that represents a `Matcher` for the given expression `e`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.exprToMatcher\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">exprToMatcher</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(boundFVars : <span class=\"fn\"><a href=\"./Std/Data/HashMap/Basic.html#Std.HashMap\">Std.HashMap</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(localFVars : <span class=\"fn\"><a href=\"./Std/Data/HashMap/Basic.html#Std.HashMap\">Std.HashMap</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Control/Option.html#OptionT\">OptionT</a> <a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L207-L218","name":"Mathlib.Notation3.setupLCtx","line":207,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.setupLCtx","doc":"Adds all the names in `boundNames` to the local context\nwith types that are fresh metavariables.\nThis is used for example when initializing `p` in `(scoped p => ...)` when elaborating `...`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.setupLCtx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">setupLCtx</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(lctx : <a href=\"./Lean/LocalContext.html#Lean.LocalContext\">Lean.LocalContext</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(boundNames : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Lean/LocalContext.html#Lean.LocalContext\">Lean.LocalContext</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Std/Data/HashMap/Basic.html#Std.HashMap\">Std.HashMap</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L200-L205","name":"Mathlib.Notation3.matchLambda","line":200,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.matchLambda","doc":"Matches lambdas. The `matchBody` takes the fvar introduced when visiting the body. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.matchLambda\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">matchLambda</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(matchDom : <a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.Matcher\">Mathlib.Notation3.Matcher</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(matchBody : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.Matcher\">Mathlib.Notation3.Matcher</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.Matcher\">Mathlib.Notation3.Matcher</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L192-L198","name":"Mathlib.Notation3.matchForall","line":192,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.matchForall","doc":"Matches pi types. The name `n` should be unique, and `matchBody` should use `n`\nas the `userName` of its fvar. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.matchForall\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">matchForall</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(matchDom : <a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.Matcher\">Mathlib.Notation3.Matcher</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(matchBody : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.Matcher\">Mathlib.Notation3.Matcher</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.Matcher\">Mathlib.Notation3.Matcher</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L185-L190","name":"Mathlib.Notation3.matchApp","line":185,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.matchApp","doc":"Matches applications. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.matchApp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">matchApp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(matchFun matchArg : <a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.Matcher\">Mathlib.Notation3.Matcher</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.Matcher\">Mathlib.Notation3.Matcher</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L180-L183","name":"Mathlib.Notation3.natLitMatcher","line":180,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.natLitMatcher","doc":"Matches raw nat lits. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.natLitMatcher\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">natLitMatcher</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.Matcher\">Mathlib.Notation3.Matcher</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L176-L178","name":"Mathlib.Notation3.matchTypeOf","line":176,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.matchTypeOf","doc":"Matcher that checks that the type of the expression is matched by `matchTy`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.matchTypeOf\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">matchTypeOf</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(matchTy : <a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.Matcher\">Mathlib.Notation3.Matcher</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.Matcher\">Mathlib.Notation3.Matcher</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L169-L174","name":"Mathlib.Notation3.matchFVar","line":169,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.matchFVar","doc":"Matcher for `Expr.fvar`.\nIt checks that the user name agrees and that the type of the expression is matched by `matchTy`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.matchFVar\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">matchFVar</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(userName : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(matchTy : <a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.Matcher\">Mathlib.Notation3.Matcher</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.Matcher\">Mathlib.Notation3.Matcher</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L164-L167","name":"Mathlib.Notation3.matchExpr","line":164,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.matchExpr","doc":"Matcher for an expression satisfying a given predicate. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.matchExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">matchExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.Matcher\">Mathlib.Notation3.Matcher</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L155-L162","name":"Mathlib.Notation3.matchVar","line":155,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.matchVar","doc":"Matcher that assigns the current `SubExpr` into the match state;\nif a value already exists, then it checks for equality. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.matchVar\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">matchVar</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.Matcher\">Mathlib.Notation3.Matcher</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L150-L153","name":"Mathlib.Notation3.MatchState.pushFold","line":150,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState.pushFold","doc":"Push a delaborated term onto a foldr/foldl array. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState.pushFold\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">MatchState</span>.<span class=\"name\">pushFold</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(s : <a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState\">Mathlib.Notation3.MatchState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(name : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState\">Mathlib.Notation3.MatchState</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L145-L148","name":"Mathlib.Notation3.MatchState.getBinders","line":145,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState.getBinders","doc":"Get the accumulated array of delaborated terms for a given foldr/foldl.\nReturns `#[]` if nothing has been pushed yet. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState.getBinders\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">MatchState</span>.<span class=\"name\">getBinders</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(s : <a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState\">Mathlib.Notation3.MatchState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Batteries.ExtendedBinder.extBinderParenthesized</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L140-L143","name":"Mathlib.Notation3.MatchState.getFoldArray","line":140,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState.getFoldArray","doc":"Get the accumulated array of delaborated terms for a given foldr/foldl.\nReturns `#[]` if nothing has been pushed yet. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState.getFoldArray\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">MatchState</span>.<span class=\"name\">getFoldArray</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(s : <a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState\">Mathlib.Notation3.MatchState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(name : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L136-L138","name":"Mathlib.Notation3.MatchState.captureSubexpr","line":136,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState.captureSubexpr","doc":"Assign a variable to the current `SubExpr`, capturing the local context. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState.captureSubexpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">MatchState</span>.<span class=\"name\">captureSubexpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(s : <a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState\">Mathlib.Notation3.MatchState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(name : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/PrettyPrinter/Delaborator/Basic.html#Lean.PrettyPrinter.Delaborator.DelabM\">Lean.PrettyPrinter.Delaborator.DelabM</a> <a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState\">Mathlib.Notation3.MatchState</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L126-L134","name":"Mathlib.Notation3.MatchState.delabVar","line":126,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState.delabVar","doc":"Delaborate the given variable's value. Fails if the variable has no value.\nIf `checkNot` is provided, then checks that the expression being delaborated is not\nthe given one (this is used to prevent infinite loops). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState.delabVar\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">MatchState</span>.<span class=\"name\">delabVar</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(s : <a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState\">Mathlib.Notation3.MatchState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(name : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(checkNot? : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <span class=\"fn\">none</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/PrettyPrinter/Delaborator/Basic.html#Lean.PrettyPrinter.Delaborator.DelabM\">Lean.PrettyPrinter.Delaborator.DelabM</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L119-L124","name":"Mathlib.Notation3.MatchState.withVar","line":119,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState.withVar","doc":"Evaluate `f` with the given variable's value as the `SubExpr` and within that subexpression's\nsaved context. Fails if the variable has no value. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState.withVar\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">MatchState</span>.<span class=\"name\">withVar</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(s : <a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState\">Mathlib.Notation3.MatchState</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(name : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(m : <span class=\"fn\"><a href=\"./Lean/PrettyPrinter/Delaborator/Basic.html#Lean.PrettyPrinter.Delaborator.DelabM\">Lean.PrettyPrinter.Delaborator.DelabM</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/PrettyPrinter/Delaborator/Basic.html#Lean.PrettyPrinter.Delaborator.DelabM\">Lean.PrettyPrinter.Delaborator.DelabM</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L113-L117","name":"Mathlib.Notation3.MatchState.empty","line":113,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState.empty","doc":"The initial state. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState.empty\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">MatchState</span>.<span class=\"name\">empty</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState\">Mathlib.Notation3.MatchState</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L111-L111","name":"Mathlib.Notation3.instMatcherInhabited","line":111,"kind":"instance","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.instMatcherInhabited","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.instMatcherInhabited\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">instMatcherInhabited</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.Matcher\">Mathlib.Notation3.Matcher</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L109-L111","name":"Mathlib.Notation3.Matcher","line":109,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.Matcher","doc":"A matcher is a delaboration function that transforms `MatchState`s. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.Matcher\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">Matcher</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L107-L107","name":"Mathlib.Notation3.MatchState.foldState","line":107,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState.foldState","doc":"The arrays of delaborated `Term`s accumulated while matching\n`foldl` and `foldr` expressions. For `foldl`, the arrays are stored in reverse order. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState.foldState\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">MatchState</span>.<span class=\"name\">foldState</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState\">Mathlib.Notation3.MatchState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Data/HashMap/Basic.html#Std.HashMap\">Std.HashMap</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L104-L104","name":"Mathlib.Notation3.MatchState.scopeState","line":104,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState.scopeState","doc":"The binders accumulated while matching a `scoped` expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState.scopeState\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">MatchState</span>.<span class=\"name\">scopeState</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState\">Mathlib.Notation3.MatchState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Batteries.ExtendedBinder.extBinderParenthesized</span>)</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L102-L102","name":"Mathlib.Notation3.MatchState.vars","line":102,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState.vars","doc":"This stores the assignments of variables to subexpressions (and their contexts)\nthat have been found so far during the course of the matching algorithm.\nWe store the contexts since we need to delaborate expressions after we leave\nscoping constructs. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState.vars\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">MatchState</span>.<span class=\"name\">vars</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState\">Mathlib.Notation3.MatchState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Data/HashMap/Basic.html#Std.HashMap\">Std.HashMap</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> <span class=\"fn\">(<a href=\"./Lean/SubExpr.html#Lean.SubExpr\">Lean.SubExpr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Lean/LocalContext.html#Lean.LocalContext\">Lean.LocalContext</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/MetavarContext.html#Lean.LocalInstances\">Lean.LocalInstances</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L97-L97","name":"Mathlib.Notation3.MatchState.mk","line":97,"kind":"ctor","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">MatchState</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(vars : <span class=\"fn\"><a href=\"./Std/Data/HashMap/Basic.html#Std.HashMap\">Std.HashMap</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> <span class=\"fn\">(<a href=\"./Lean/SubExpr.html#Lean.SubExpr\">Lean.SubExpr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Lean/LocalContext.html#Lean.LocalContext\">Lean.LocalContext</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/MetavarContext.html#Lean.LocalInstances\">Lean.LocalInstances</a></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(scopeState : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Batteries.ExtendedBinder.extBinderParenthesized</span>)</span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(foldState : <span class=\"fn\"><a href=\"./Std/Data/HashMap/Basic.html#Std.HashMap\">Std.HashMap</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState\">Mathlib.Notation3.MatchState</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L96-L107","name":"Mathlib.Notation3.MatchState","line":96,"kind":"structure","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState","doc":"The dynamic state of a `Matcher`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.MatchState\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">MatchState</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L81-L84","name":"Mathlib.Notation3.notation3Item","line":81,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.notation3Item","doc":"`notation3` argument. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.notation3Item\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">notation3Item</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L78-L80","name":"Mathlib.Notation3.identOptScoped","line":78,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.identOptScoped","doc":"`notation3` argument binding a name. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.identOptScoped\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">identOptScoped</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L75-L77","name":"Mathlib.Notation3.foldAction","line":75,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.foldAction","doc":"`notation3` argument simulating a Lean 3 fold notation. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.foldAction\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">foldAction</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L73-L74","name":"Mathlib.Notation3.bindersItem","line":73,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.bindersItem","doc":"`notation3` argument matching `extBinders`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.bindersItem\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">bindersItem</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L71-L72","name":"Mathlib.Notation3.foldKind","line":71,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.foldKind","doc":"Keywording indicating whether to use a left- or right-fold. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.foldKind\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">foldKind</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L65-L69","name":"Mathlib.Notation3.expandFoldr","line":65,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.expandFoldr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.expandFoldr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">expandFoldr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L60-L64","name":"Mathlib.Notation3.expandFoldl","line":60,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.expandFoldl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.expandFoldl\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">expandFoldl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Util/Notation3.lean#L30-L37","name":"Mathlib.Notation3.«termExpand_binders%(_=>_)_,_»","line":30,"kind":"def","docLink":"./Mathlib/Util/Notation3.html#Mathlib.Notation3.«termExpand_binders%(_=>_)_,_»","doc":"Expands binders into nested combinators.\nFor example, the familiar exists is given by:\n`expand_binders% (p => Exists p) x y : Nat, x < y`\nwhich expands to the same expression as\n`∃ x y : Nat, x < y`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Notation3.html#Mathlib.Notation3.«termExpand_binders%(_=&gt;_)_,_»\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Notation3</span>.<span class=\"name\">«termExpand_binders%(_=&gt;_)_,_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"}]}