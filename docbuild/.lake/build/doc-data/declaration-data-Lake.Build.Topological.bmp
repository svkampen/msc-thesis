{"name":"Lake.Build.Topological","instances":[],"imports":["Init","Lake.Util.Cycle","Lake.Util.Store","Lake.Util.EquipT"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/lake/Lake/Build/Topological.lean#L111-L120","name":"Lake.recFetchMemoize","line":111,"kind":"def","docLink":"./Lake/Build/Topological.html#Lake.recFetchMemoize","doc":"`recFetchAcyclic` augmented with a `MonadDStore` to\nmemoize fetch results and thus avoid computing the same result twice.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lake/Build/Topological.html#Lake.recFetchMemoize\"><span class=\"name\">Lake</span>.<span class=\"name\">recFetchMemoize</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{κ : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{m : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> u_1 → <a href=\"./foundational_types.html\">Type</a> u_2</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">κ</span> → <a href=\"./foundational_types.html\">Type</a> u_1</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <span class=\"fn\">κ</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Lake/Util/Cycle.html#Lake.MonadCycle\">Lake.MonadCycle</a> <span class=\"fn\">κ</span> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Lake/Util/Store.html#Lake.MonadDStore\">Lake.MonadDStore</a> <span class=\"fn\">κ</span> <span class=\"fn\">β</span> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(keyOf : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">κ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fetch : <span class=\"fn\"><a href=\"./Lake/Build/Topological.html#Lake.DRecFetchFn\">Lake.DRecFetchFn</a> <span class=\"fn\">α</span> <span class=\"fn\">(fun (<span class=\"fn\">a</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">(<span class=\"fn\">keyOf</span> <span class=\"fn\">a</span>)</span></span>)</span> <span class=\"fn\">m</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lake/Build/Topological.html#Lake.DFetchFn\">Lake.DFetchFn</a> <span class=\"fn\">α</span> <span class=\"fn\">(fun (<span class=\"fn\">a</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\"><span class=\"fn\">β</span> <span class=\"fn\">(<span class=\"fn\">keyOf</span> <span class=\"fn\">a</span>)</span></span>)</span> <span class=\"fn\">m</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/lake/Lake/Build/Topological.lean#L83-L102","name":"Lake.recFetchAcyclic","line":83,"kind":"def","docLink":"./Lake/Build/Topological.html#Lake.recFetchAcyclic","doc":"A `recFetch` augmented by a `MonadCycle` to guard against recursive cycles.\nIf the set of visited keys is finite, this function should provably terminate.\n\nWe use `keyOf` to the derive the unique key of a fetch from its descriptor\n`a : α`. We do this because descriptors may not be comparable and/or contain\nmore information than necessary to determine uniqueness.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lake/Build/Topological.html#Lake.recFetchAcyclic\"><span class=\"name\">Lake</span>.<span class=\"name\">recFetchAcyclic</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{κ : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{m : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> u_1 → <a href=\"./foundational_types.html\">Type</a> u_2</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Type</a> u_1</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <span class=\"fn\">κ</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Lake/Util/Cycle.html#Lake.MonadCycle\">Lake.MonadCycle</a> <span class=\"fn\">κ</span> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(keyOf : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">κ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fetch : <span class=\"fn\"><a href=\"./Lake/Build/Topological.html#Lake.DRecFetchFn\">Lake.DRecFetchFn</a> <span class=\"fn\">α</span> <span class=\"fn\">β</span> <span class=\"fn\">m</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lake/Build/Topological.html#Lake.DFetchFn\">Lake.DFetchFn</a> <span class=\"fn\">α</span> <span class=\"fn\">β</span> <span class=\"fn\">m</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/lake/Lake/Build/Topological.lean#L72-L75","name":"Lake.recFetch","line":72,"kind":"opaque","docLink":"./Lake/Build/Topological.html#Lake.recFetch","doc":"A `DFetchFn` that provides its base `DRecFetchFn` with itself. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lake/Build/Topological.html#Lake.recFetch\"><span class=\"name\">Lake</span>.<span class=\"name\">recFetch</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{m : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> u → <a href=\"./foundational_types.html\">Type</a> u_1</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Type</a> u</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">∀ (<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u), <span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">(<span class=\"fn\">m</span> <span class=\"fn\">α</span>)</span></span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(fetch : <span class=\"fn\"><a href=\"./Lake/Build/Topological.html#Lake.DRecFetchFn\">Lake.DRecFetchFn</a> <span class=\"fn\">α</span> <span class=\"fn\">β</span> <span class=\"fn\">m</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lake/Build/Topological.html#Lake.DFetchFn\">Lake.DFetchFn</a> <span class=\"fn\">α</span> <span class=\"fn\">β</span> <span class=\"fn\">m</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/lake/Lake/Build/Topological.lean#L68-L70","name":"Lake.RecFetchFn","line":68,"kind":"def","docLink":"./Lake/Build/Topological.html#Lake.RecFetchFn","doc":"A `DRecFetchFn` that is not dependently typed. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lake/Build/Topological.html#Lake.RecFetchFn\"><span class=\"name\">Lake</span>.<span class=\"name\">RecFetchFn</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(α : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(β : <a href=\"./foundational_types.html\">Type</a> v)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(m : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> v → <a href=\"./foundational_types.html\">Type</a> w</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> (max u w)</div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/lake/Lake/Build/Topological.lean#L65-L66","name":"Lake.DRecFetchFn","line":65,"kind":"def","docLink":"./Lake/Build/Topological.html#Lake.DRecFetchFn","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lake/Build/Topological.html#Lake.DRecFetchFn\"><span class=\"name\">Lake</span>.<span class=\"name\">DRecFetchFn</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(α : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(β : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Type</a> v</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(m : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> v → <a href=\"./foundational_types.html\">Type</a> w</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> (max u w u)</div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/lake/Lake/Build/Topological.lean#L52-L54","name":"Lake.FetchT","line":52,"kind":"def","docLink":"./Lake/Build/Topological.html#Lake.FetchT","doc":"A `DFetchT` that is not dependently typed. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lake/Build/Topological.html#Lake.FetchT\"><span class=\"name\">Lake</span>.<span class=\"name\">FetchT</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(α : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(β : <a href=\"./foundational_types.html\">Type</a> v)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(m : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> v → <a href=\"./foundational_types.html\">Type</a> w</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> v → <a href=\"./foundational_types.html\">Type</a> (max (max w u) w)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/lake/Lake/Build/Topological.lean#L48-L50","name":"Lake.DFetchT","line":48,"kind":"def","docLink":"./Lake/Build/Topological.html#Lake.DFetchT","doc":"A transformer that equips a monad with a `DFetchFn`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lake/Build/Topological.html#Lake.DFetchT\"><span class=\"name\">Lake</span>.<span class=\"name\">DFetchT</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(α : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(β : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Type</a> v</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(m : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> v → <a href=\"./foundational_types.html\">Type</a> w</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> v → <a href=\"./foundational_types.html\">Type</a> (max (max w u) w)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/lake/Lake/Build/Topological.lean#L39-L41","name":"Lake.FetchFn","line":39,"kind":"def","docLink":"./Lake/Build/Topological.html#Lake.FetchFn","doc":"A `DFetchFn` that is not dependently typed. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lake/Build/Topological.html#Lake.FetchFn\"><span class=\"name\">Lake</span>.<span class=\"name\">FetchFn</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(α : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(β : <a href=\"./foundational_types.html\">Type</a> v)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(m : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> v → <a href=\"./foundational_types.html\">Type</a> w</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> (max u w)</div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/410fab7284703f41660ca2454218dcca9b2ec896/src/lake/Lake/Build/Topological.lean#L28-L37","name":"Lake.DFetchFn","line":28,"kind":"def","docLink":"./Lake/Build/Topological.html#Lake.DFetchFn","doc":"A dependently typed monadic *fetch* function.\n\nThat is, a function within the monad `m` and takes an input `a : α`\ndescribing what to fetch and produces some output `b : β a` (dependently\ntyped) or `b : B` (not) describing what was fetched. All build functions are\nfetch functions, but not all fetch functions need build something.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lake/Build/Topological.html#Lake.DFetchFn\"><span class=\"name\">Lake</span>.<span class=\"name\">DFetchFn</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(α : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(β : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Type</a> v</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(m : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> v → <a href=\"./foundational_types.html\">Type</a> w</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> (max u w)</div></div>"}]}