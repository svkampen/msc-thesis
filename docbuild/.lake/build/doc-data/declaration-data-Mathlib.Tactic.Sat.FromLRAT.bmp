{"name":"Mathlib.Tactic.Sat.FromLRAT","instances":[{"typeNames":["Sat.Literal"],"name":"Sat.instToExprLiteral","className":"Lean.ToExpr"}],"imports":["Init","Mathlib.Algebra.Group.Nat.Basic","Mathlib.Tactic.ByContra"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L641-L671","name":"Mathlib.Tactic.Sat.termFrom_lrat___","line":641,"kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.termFrom_lrat___","doc":"A macro for producing SAT proofs from CNF / LRAT files.\nThese files are commonly used in the SAT community for writing proofs.\n\nThe input to the `from_lrat` term syntax is two string expressions with\nthe statement (written in CNF format) and the proof (in LRAT format).\nFor example:\n```\ndef foo := from_lrat\n  \"p cnf 2 4  1 2 0  -1 2 0  1 -2 0  -1 -2 0\"\n  \"5 -2 0 4 3 0  5 d 3 4 0  6 1 0 5 1 0  6 d 1 0  7 0 5 2 6 0\"\n```\nproduces a theorem:\n```\nfoo : ∀ (a a_1 : Prop), (¬a ∧ ¬a_1 ∨ a ∧ ¬a_1) ∨ ¬a ∧ a_1 ∨ a ∧ a_1\n```\n\n* You can use this term after `have :=` or in `def foo :=` to produce the term\n  without constraining the type.\n* You can use it when a specific type is expected, but it currently does not\n  pay any attention to the shape of the goal and always produces the same theorem,\n  so you can only use this to do alpha renaming.\n* You can use the `include_str` macro in place of the two strings\n  to load CNF / LRAT files from disk.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.termFrom_lrat___\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Sat</span>.<span class=\"name\">termFrom_lrat___</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L589-L621","name":"Mathlib.Tactic.Sat.commandLrat_proof_Example____","line":589,"kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.commandLrat_proof_Example____","doc":"A macro for producing SAT proofs from CNF / LRAT files.\nThese files are commonly used in the SAT community for writing proofs.\n\nThe input to the `lrat_proof` command is the name of the theorem to define,\nand the statement (written in CNF format) and the proof (in LRAT format).\nFor example:\n```\nlrat_proof foo\n  \"p cnf 2 4  1 2 0  -1 2 0  1 -2 0  -1 -2 0\"\n  \"5 -2 0 4 3 0  5 d 3 4 0  6 1 0 5 1 0  6 d 1 0  7 0 5 2 6 0\"\n```\nproduces a theorem:\n```\nfoo : ∀ (a a_1 : Prop), (¬a ∧ ¬a_1 ∨ a ∧ ¬a_1) ∨ ¬a ∧ a_1 ∨ a ∧ a_1\n```\n\n* You can see the theorem statement by hovering over the word `foo`.\n* You can use the `example` keyword in place of `foo` to avoid generating a theorem.\n* You can use the `include_str` macro in place of the two strings\n  to load CNF / LRAT files from disk.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.commandLrat_proof_Example____\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Sat</span>.<span class=\"name\">commandLrat_proof_Example____</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L575-L584","name":"Mathlib.Tactic.Sat.fromLRAT","line":575,"kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.fromLRAT","doc":"Main entry point. Given strings `cnf` and `lrat` with unparsed file data, and a name `name`,\nadds `theorem name : type := proof` where `type` is a propositional theorem like\n`∀ (a a_1 : Prop), (¬a ∧ ¬a_1 ∨ a ∧ ¬a_1) ∨ ¬a ∧ a_1 ∨ a ∧ a_1`.\n\nAlso creates auxiliaries named `name.ctx_1` (for the CNF formula)\nand `name.proof_1` (for the LRAT proof), with `name` itself containing the reification proof. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.fromLRAT\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Sat</span>.<span class=\"name\">fromLRAT</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cnf lrat : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(name : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L540-L573","name":"Mathlib.Tactic.Sat.fromLRATAux","line":540,"kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.fromLRATAux","doc":"Core of `fromLRAT`. Constructs the context and main proof definitions,\nbut not the reification theorem. Returns:\n\n  * `nvars`: the number of variables specified in the CNF file\n  * `ctx`: The abbreviated formula, a constant like `foo.ctx_1`\n  * `ctx'`: The definitional expansion of the formula, a tree of `Fmla.and` nodes\n  * `proof`: A proof of `ctx.proof []`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.fromLRATAux\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Sat</span>.<span class=\"name\">fromLRATAux</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cnf lrat : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(name : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L530-L534","name":"Mathlib.Tactic.Sat.Parser.parseLRAT","line":530,"kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Parser.parseLRAT","doc":"Parse an LRAT file into a list of steps. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Parser.parseLRAT\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Sat</span>.<span class=\"name\">Parser</span>.<span class=\"name\">parseLRAT</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Internal/Parsec/String.html#Std.Internal.Parsec.String.Parser\">Std.Internal.Parsec.String.Parser</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LRATStep\">Mathlib.Tactic.Sat.LRATStep</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L519-L528","name":"Mathlib.Tactic.Sat.Parser.parseDimacs","line":519,"kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Parser.parseDimacs","doc":"Parse a DIMACS format `.cnf` file.\nThis is not very robust; we assume the file has had comments stripped. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Parser.parseDimacs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Sat</span>.<span class=\"name\">Parser</span>.<span class=\"name\">parseDimacs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Internal/Parsec/String.html#Std.Internal.Parsec.String.Parser\">Std.Internal.Parsec.String.Parser</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L513-L517","name":"Mathlib.Tactic.Sat.Parser.parseNats","line":513,"kind":"opaque","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Parser.parseNats","doc":"Parse a list of natural numbers terminated by 0 "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Parser.parseNats\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Sat</span>.<span class=\"name\">Parser</span>.<span class=\"name\">parseNats</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(arr : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span> := <span class=\"fn\">#[]</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Internal/Parsec/String.html#Std.Internal.Parsec.String.Parser\">Std.Internal.Parsec.String.Parser</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L507-L511","name":"Mathlib.Tactic.Sat.Parser.parseInts","line":507,"kind":"opaque","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Parser.parseInts","doc":"Parse a list of integers terminated by 0 "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Parser.parseInts\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Sat</span>.<span class=\"name\">Parser</span>.<span class=\"name\">parseInts</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(arr : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a></span> := <span class=\"fn\">#[]</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Internal/Parsec/String.html#Std.Internal.Parsec.String.Parser\">Std.Internal.Parsec.String.Parser</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L503-L505","name":"Mathlib.Tactic.Sat.Parser.parseInt","line":503,"kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Parser.parseInt","doc":"Parse an integer "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Parser.parseInt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Sat</span>.<span class=\"name\">Parser</span>.<span class=\"name\">parseInt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Internal/Parsec/String.html#Std.Internal.Parsec.String.Parser\">Std.Internal.Parsec.String.Parser</a> <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L500-L501","name":"Mathlib.Tactic.Sat.Parser.parseNat","line":500,"kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Parser.parseNat","doc":"Parse a natural number "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Parser.parseNat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Sat</span>.<span class=\"name\">Parser</span>.<span class=\"name\">parseNat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Internal/Parsec/String.html#Std.Internal.Parsec.String.Parser\">Std.Internal.Parsec.String.Parser</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L492-L494","name":"Mathlib.Tactic.Sat.buildReify.reifyVar","line":492,"kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.reifyVar","doc":"Returns `a` and `pr : v n ↔ a` given a variable index `n`.\nThese are both lookups into the context\n`(a0 .. a(n-1) : Prop) (v) (h1 : v 0 ↔ a0) ... (hn : v (n-1) ↔ a(n-1))`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.reifyVar\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Sat</span>.<span class=\"name\">buildReify</span>.<span class=\"name\">reifyVar</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(nvars : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(v : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L480-L488","name":"Mathlib.Tactic.Sat.buildReify.reifyLiteral","line":480,"kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.reifyLiteral","doc":"Returns `a` and `pr : reify v l a` given a literal `c` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.reifyLiteral\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Sat</span>.<span class=\"name\">buildReify</span>.<span class=\"name\">reifyLiteral</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(nvars : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(l : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L470-L478","name":"Mathlib.Tactic.Sat.buildReify.reifyClause1","line":470,"kind":"opaque","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.reifyClause1","doc":"Returns `a` and `pr : reify v c a` given a nonempty clause `c` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.reifyClause1\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Sat</span>.<span class=\"name\">buildReify</span>.<span class=\"name\">reifyClause1</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(nvars : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L465-L468","name":"Mathlib.Tactic.Sat.buildReify.reifyClause","line":465,"kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.reifyClause","doc":"Returns `a` and `pr : reify v c a` given a clause `c` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.reifyClause\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Sat</span>.<span class=\"name\">buildReify</span>.<span class=\"name\">reifyClause</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(nvars : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L451-L463","name":"Mathlib.Tactic.Sat.buildReify.reifyFmla","line":451,"kind":"opaque","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.reifyFmla","doc":"Returns `a` and `pr : reify v f a` given a formula `f` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.reifyFmla\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Sat</span>.<span class=\"name\">buildReify</span>.<span class=\"name\">reifyFmla</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(nvars : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L449-L449","name":"Mathlib.Tactic.Sat.buildReify.v","line":449,"kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.v","doc":"The `v` variable under the `a1 ... an, v, h1 ... hn` context "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.v\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Sat</span>.<span class=\"name\">buildReify</span>.<span class=\"name\">v</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(nvars : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L439-L441","name":"Mathlib.Tactic.Sat.buildReify.mkPS","line":439,"kind":"opaque","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.mkPS","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.mkPS\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Sat</span>.<span class=\"name\">buildReify</span>.<span class=\"name\">mkPS</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cons : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(depth : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L409-L494","name":"Mathlib.Tactic.Sat.buildReify","line":409,"kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify","doc":"Build the type and value of the reified theorem. This rewrites all the SAT definitions\ninto standard operators on `Prop`, for example if the formula is `[[1, 2], [-1, 2], [-2]]` then\nthis produces a proof of `⊢ ∀ a b : Prop, (a ∧ b) ∨ (¬a ∧ b) ∨ ¬b`. We use the input `nvars` to\ndecide how many quantifiers to use.\n\nMost of the proof is under `2 * nvars + 1` quantifiers\n`a1 .. an : Prop, v : Valuation, h1 : v 0 ↔ a1, ... hn : v (n-1) ↔ an ⊢ ...`, and we do the index\narithmetic by hand.\n\n  1. First, we call `reifyFormula ctx'` which returns `a` and `pr : reify v ctx' a`\n  2. Then we build `fun (v : Valuation) (h1 : v 0 ↔ a1) ... (hn : v (n-1) ↔ an) ↦ pr`\n  3. We have to lower expression `a` from step 1 out of the quantifiers by lowering all variable\n     indices by `nvars+1`. This is okay because `v` and `h1..hn` do not appear in `a`.\n  4. We construct the expression `ps`, which is `a1 .. an : Prop ⊢ [a1, ..., an] : List Prop`\n  5. `refute ctx (hf : ctx.proof []) (fun v h1 .. hn ↦ pr) : a` forces some definitional unfolding\n     since `fun h1 .. hn ↦ pr` should have type `implies v (reify v ctx a) [a1, ..., an] a`,\n     which involves unfolding `implies` n times as well as `ctx ↦ ctx'`.\n  6. Finally, we `intro a1 ... an` so that we have a proof of `∀ a1 ... an, a`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Sat</span>.<span class=\"name\">buildReify</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ctx ctx' proof : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(nvars : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L386-L407","name":"Mathlib.Tactic.Sat.buildProof","line":386,"kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildProof","doc":"Build the main proof of `⊢ ctx.proof []` using the LRAT proof trace.\n\n* `arr`: The input CNF\n* `ctx`: The abbreviated formula, a constant like `foo.ctx_1`\n* `ctx'`: The definitional expansion of the formula, a tree of `Fmla.and` nodes\n* `steps`: The input LRAT proof trace\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Sat</span>.<span class=\"name\">buildProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(arr : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ctx ctx' : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(steps : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LRATStep\">Mathlib.Tactic.Sat.LRATStep</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L383-L384","name":"Mathlib.Tactic.Sat.LRATStep.del","line":383,"kind":"ctor","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LRATStep.del","doc":"A (multiple) deletion step, which deletes all the listed clause IDs from the context "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LRATStep.del\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Sat</span>.<span class=\"name\">LRATStep</span>.<span class=\"name\">del</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ids : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LRATStep\">Mathlib.Tactic.Sat.LRATStep</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L381-L382","name":"Mathlib.Tactic.Sat.LRATStep.add","line":381,"kind":"ctor","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LRATStep.add","doc":"An addition step, with the clause ID, the clause literal list, and the proof trace "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LRATStep.add\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Sat</span>.<span class=\"name\">LRATStep</span>.<span class=\"name\">add</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(id : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(lits proof : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LRATStep\">Mathlib.Tactic.Sat.LRATStep</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L379-L384","name":"Mathlib.Tactic.Sat.LRATStep","line":379,"kind":"inductive","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LRATStep","doc":"An LRAT step is either an addition or a deletion step. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LRATStep\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Sat</span>.<span class=\"name\">LRATStep</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L288-L377","name":"Mathlib.Tactic.Sat.buildProofStep","line":288,"kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildProofStep","doc":"Construct an individual proof step `⊢ ctx.proof c`.\n\n* `db`: the current global context\n* `ns`, `clause`: the new clause\n* `pf`: the LRAT proof trace\n* `ctx`: the main formula\n\nThe proof has three steps:\n\n1. Introduce local assumptions `have h1 : ctx.proof c1 := p1` for each clause `c1`\n   referenced in the proof. We actually do all the introductions at once,\n   as in `(fun h1 h2 h3 ↦ ...) p1 p2 p3`, because we want `p_i` to not be under any binders\n   to avoid the cost of `instantiate` during typechecking and get the benefits of dag-like\n   sharing in the `pi` (which are themselves previous proof steps which may be large terms).\n   The hypotheses are in `gctx`, keyed on the clause ID.\n\n2. Unfold `⊢ ctx.proof [a, b, c]` to\n   `∀ v, v.satisfies_fmla ctx → v.neg a → v.neg b → v.neg c → False` and `intro v hv ha hb hc`,\n   storing each `ha : v.neg a` in `lctx`, keyed on the literal `a`.\n\n3. For each LRAT step `hc : ctx.proof [x, y]`, `hc v hv : v.neg x → v.neg y → False`.\n   We look for a literal that is not falsified in the clause. Since it is a unit propagation\n   step, there can be at most one such literal.\n   * If `x` is the non-falsified clause, let `x'` denote the negated literal of `x`.\n     Then `x'.negate` reduces to `x`, so `hnx : v.neg x'.negate |- hc v hv hnx hy : False`,\n     so we construct the term\n       `by_cases (fun hnx : v.neg x'.negate ↦ hc v hv hnx hy) (fun hx : v.neg x ↦ ...)`\n     and `hx` is added to the local context.\n   * If all clauses are falsified, then we are done: `hc v hv hx hy : False`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildProofStep\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Sat</span>.<span class=\"name\">buildProofStep</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(db : <span class=\"fn\"><a href=\"./Std/Data/HashMap/Basic.html#Std.HashMap\">Std.HashMap</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Clause\">Mathlib.Tactic.Sat.Clause</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ns pf : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ctx clause : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Except\">Except</a> <a href=\"./Init/Prelude.html#String\">String</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L286-L286","name":"Mathlib.Tactic.Sat.LClause.depth","line":286,"kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LClause.depth","doc":"The bound variable index of the hypothesis asserting `⊢ ctx.proof c`,\n_counting from the outside and 1-based_. (We use this numbering because we will need to\nreference the variable from multiple binder depths.) "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LClause.depth\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Sat</span>.<span class=\"name\">LClause</span>.<span class=\"name\">depth</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LClause\">Mathlib.Tactic.Sat.LClause</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L282-L282","name":"Mathlib.Tactic.Sat.LClause.expr","line":282,"kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LClause.expr","doc":"The clause expression of type `Clause` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LClause.expr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Sat</span>.<span class=\"name\">LClause</span>.<span class=\"name\">expr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LClause\">Mathlib.Tactic.Sat.LClause</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L280-L280","name":"Mathlib.Tactic.Sat.LClause.lits","line":280,"kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LClause.lits","doc":"The list of literals as read from the input file "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LClause.lits\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Sat</span>.<span class=\"name\">LClause</span>.<span class=\"name\">lits</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LClause\">Mathlib.Tactic.Sat.LClause</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L278-L278","name":"Mathlib.Tactic.Sat.LClause.mk","line":278,"kind":"ctor","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LClause.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LClause.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Sat</span>.<span class=\"name\">LClause</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(lits : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(expr : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(depth : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LClause\">Mathlib.Tactic.Sat.LClause</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L276-L286","name":"Mathlib.Tactic.Sat.LClause","line":276,"kind":"structure","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LClause","doc":"A localized clause reference.\nIt is the same as `Clause` except that the proof is now a local variable. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LClause\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Sat</span>.<span class=\"name\">LClause</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L256-L274","name":"Mathlib.Tactic.Sat.buildClauses","line":256,"kind":"opaque","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildClauses","doc":"Constructs the proofs of `⊢ ctx.proof c` for each clause `c` in `ctx`.\nThe proofs are stashed in a `HashMap` keyed on the clause ID. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildClauses\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Sat</span>.<span class=\"name\">buildClauses</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(arr : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ctx : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(start stop : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f p : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(accum : <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Std/Data/HashMap/Basic.html#Std.HashMap\">Std.HashMap</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Clause\">Mathlib.Tactic.Sat.Clause</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Std/Data/HashMap/Basic.html#Std.HashMap\">Std.HashMap</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Clause\">Mathlib.Tactic.Sat.Clause</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L247-L254","name":"Mathlib.Tactic.Sat.buildConj","line":247,"kind":"opaque","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildConj","doc":"Constructs the formula expression from the input CNF, as a balanced tree of `Fmla.and` nodes. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildConj\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Sat</span>.<span class=\"name\">buildConj</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(arr : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(start stop : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L240-L245","name":"Mathlib.Tactic.Sat.buildClause","line":240,"kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildClause","doc":"Construct the clause expression from the input list. For example `[1, -2]` is translated to\n`Clause.cons (Literal.pos 1) (Clause.cons (Literal.neg 2) Clause.nil)`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildClause\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Sat</span>.<span class=\"name\">buildClause</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(arr : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L238-L238","name":"Mathlib.Tactic.Sat.Clause.proof","line":238,"kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Clause.proof","doc":"A proof of `⊢ ctx.proof c`.\nNote that we do not use `have` statements to cache these proofs:\nthis is literally the proof expression itself. As a result, the proof terms\nrely heavily on dag-like sharing of the expression, and printing these proof terms\ndirectly is likely to crash lean for larger examples. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Clause.proof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Sat</span>.<span class=\"name\">Clause</span>.<span class=\"name\">proof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Clause\">Mathlib.Tactic.Sat.Clause</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L232-L232","name":"Mathlib.Tactic.Sat.Clause.expr","line":232,"kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Clause.expr","doc":"The clause expression of type `Clause` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Clause.expr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Sat</span>.<span class=\"name\">Clause</span>.<span class=\"name\">expr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Clause\">Mathlib.Tactic.Sat.Clause</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L230-L230","name":"Mathlib.Tactic.Sat.Clause.lits","line":230,"kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Clause.lits","doc":"The list of literals as read from the input file "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Clause.lits\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Sat</span>.<span class=\"name\">Clause</span>.<span class=\"name\">lits</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Clause\">Mathlib.Tactic.Sat.Clause</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L228-L228","name":"Mathlib.Tactic.Sat.Clause.mk","line":228,"kind":"ctor","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Clause.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Clause.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Sat</span>.<span class=\"name\">Clause</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(lits : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(expr proof : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Clause\">Mathlib.Tactic.Sat.Clause</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L227-L238","name":"Mathlib.Tactic.Sat.Clause","line":227,"kind":"structure","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Clause","doc":"The representation of a global clause. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Clause\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Sat</span>.<span class=\"name\">Clause</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L220-L221","name":"Sat.Literal.reify_neg","line":220,"kind":"theorem","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.reify_neg","doc":"The reification of a negative literal `¬⟦¬a⟧_v ≡ a`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.reify_neg\"><span class=\"name\">Sat</span>.<span class=\"name\">Literal</span>.<span class=\"name\">reify_neg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{v : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation\">Sat.Valuation</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{a : <a href=\"./foundational_types.html\">Prop</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">v</span> <span class=\"fn\">n</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.reify\">Sat.Literal.reify</a> <span class=\"fn\">v</span> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.neg\">Sat.Literal.neg</a> <span class=\"fn\">n</span>)</span> <span class=\"fn\">a</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L217-L218","name":"Sat.Literal.reify_pos","line":217,"kind":"theorem","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.reify_pos","doc":"The reification of a positive literal `¬⟦a⟧_v ≡ ¬a`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.reify_pos\"><span class=\"name\">Sat</span>.<span class=\"name\">Literal</span>.<span class=\"name\">reify_pos</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{v : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation\">Sat.Valuation</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{a : <a href=\"./foundational_types.html\">Prop</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">v</span> <span class=\"fn\">n</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.reify\">Sat.Literal.reify</a> <span class=\"fn\">v</span> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.pos\">Sat.Literal.pos</a> <span class=\"fn\">n</span>)</span> <span class=\"fn\"><a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">a</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L212-L215","name":"Sat.Clause.reify_one","line":212,"kind":"theorem","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.reify_one","doc":"The reification of a singleton clause `¬⟦l⟧_v ≡ ¬⟦l⟧_v`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.reify_one\"><span class=\"name\">Sat</span>.<span class=\"name\">Clause</span>.<span class=\"name\">reify_one</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{v : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation\">Sat.Valuation</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{l : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal\">Sat.Literal</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{a : <a href=\"./foundational_types.html\">Prop</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h₁ : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.reify\">Sat.Literal.reify</a> <span class=\"fn\">v</span> <span class=\"fn\">l</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.reify\">Sat.Clause.reify</a> <span class=\"fn\">v</span> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.cons\">Sat.Clause.cons</a> <span class=\"fn\">l</span> <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.nil\">Sat.Clause.nil</a>)</span> <span class=\"fn\">a</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L209-L210","name":"Sat.Clause.reify_zero","line":209,"kind":"theorem","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.reify_zero","doc":"The reification of the empty clause is `True`: `¬⟦⊥⟧_v ≡ True`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.reify_zero\"><span class=\"name\">Sat</span>.<span class=\"name\">Clause</span>.<span class=\"name\">reify_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{v : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation\">Sat.Valuation</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.reify\">Sat.Clause.reify</a> <span class=\"fn\">v</span> <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.nil\">Sat.Clause.nil</a> <a href=\"./Init/Prelude.html#True\">True</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L203-L207","name":"Sat.Clause.reify_and","line":203,"kind":"theorem","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.reify_and","doc":"Negation turns OR into AND, so `¬⟦l ∨ c⟧_v ≡ ¬⟦l⟧_v ∧ ¬⟦c⟧_v`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.reify_and\"><span class=\"name\">Sat</span>.<span class=\"name\">Clause</span>.<span class=\"name\">reify_and</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{v : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation\">Sat.Valuation</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{l : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal\">Sat.Literal</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{a : <a href=\"./foundational_types.html\">Prop</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause\">Sat.Clause</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{b : <a href=\"./foundational_types.html\">Prop</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h₁ : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.reify\">Sat.Literal.reify</a> <span class=\"fn\">v</span> <span class=\"fn\">l</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h₂ : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.reify\">Sat.Clause.reify</a> <span class=\"fn\">v</span> <span class=\"fn\">c</span> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.reify\">Sat.Clause.reify</a> <span class=\"fn\">v</span> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.cons\">Sat.Clause.cons</a> <span class=\"fn\">l</span> <span class=\"fn\">c</span>)</span> <span class=\"fn\">(<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\">b</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L201-L201","name":"Sat.Literal.reify.prop","line":201,"kind":"theorem","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.reify.prop","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.reify.prop\"><span class=\"name\">Sat</span>.<span class=\"name\">Literal</span>.<span class=\"name\">reify</span>.<span class=\"name\">prop</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{v : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation\">Sat.Valuation</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{l : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal\">Sat.Literal</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{p : <a href=\"./foundational_types.html\">Prop</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(self : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.reify\">Sat.Literal.reify</a> <span class=\"fn\">v</span> <span class=\"fn\">l</span> <span class=\"fn\">p</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">v</span>.neg</span> <span class=\"fn\">l</span></span> → <span class=\"fn\">p</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L200-L200","name":"Sat.Literal.reify.mk","line":200,"kind":"ctor","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.reify.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.reify.mk\"><span class=\"name\">Sat</span>.<span class=\"name\">Literal</span>.<span class=\"name\">reify</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{v : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation\">Sat.Valuation</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{l : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal\">Sat.Literal</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{p : <a href=\"./foundational_types.html\">Prop</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(prop : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">v</span>.neg</span> <span class=\"fn\">l</span></span> → <span class=\"fn\">p</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.reify\">Sat.Literal.reify</a> <span class=\"fn\">v</span> <span class=\"fn\">l</span> <span class=\"fn\">p</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L199-L201","name":"Sat.Literal.reify","line":199,"kind":"structure","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.reify","doc":"Asserts that `¬⟦l⟧_v` implies `p`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.reify\"><span class=\"name\">Sat</span>.<span class=\"name\">Literal</span>.<span class=\"name\">reify</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(v : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation\">Sat.Valuation</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(l : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal\">Sat.Literal</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./foundational_types.html\">Prop</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L194-L197","name":"Sat.Fmla.reify_one","line":194,"kind":"theorem","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.reify_one","doc":"Reification of a single clause formula. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.reify_one\"><span class=\"name\">Sat</span>.<span class=\"name\">Fmla</span>.<span class=\"name\">reify_one</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{v : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation\">Sat.Valuation</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause\">Sat.Clause</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{a : <a href=\"./foundational_types.html\">Prop</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.reify\">Sat.Clause.reify</a> <span class=\"fn\">v</span> <span class=\"fn\">c</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.reify\">Sat.Fmla.reify</a> <span class=\"fn\">v</span> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.one\">Sat.Fmla.one</a> <span class=\"fn\">c</span>)</span> <span class=\"fn\">a</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L192-L192","name":"Sat.Clause.reify.prop","line":192,"kind":"theorem","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.reify.prop","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.reify.prop\"><span class=\"name\">Sat</span>.<span class=\"name\">Clause</span>.<span class=\"name\">reify</span>.<span class=\"name\">prop</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{v : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation\">Sat.Valuation</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause\">Sat.Clause</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{p : <a href=\"./foundational_types.html\">Prop</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(self : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.reify\">Sat.Clause.reify</a> <span class=\"fn\">v</span> <span class=\"fn\">c</span> <span class=\"fn\">p</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">v</span>.satisfies</span> <span class=\"fn\">c</span></span></span> → <span class=\"fn\">p</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L191-L191","name":"Sat.Clause.reify.mk","line":191,"kind":"ctor","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.reify.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.reify.mk\"><span class=\"name\">Sat</span>.<span class=\"name\">Clause</span>.<span class=\"name\">reify</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{v : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation\">Sat.Valuation</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause\">Sat.Clause</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{p : <a href=\"./foundational_types.html\">Prop</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(prop : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">v</span>.satisfies</span> <span class=\"fn\">c</span></span></span> → <span class=\"fn\">p</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.reify\">Sat.Clause.reify</a> <span class=\"fn\">v</span> <span class=\"fn\">c</span> <span class=\"fn\">p</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L190-L192","name":"Sat.Clause.reify","line":190,"kind":"structure","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.reify","doc":"Asserts that `¬⟦c⟧_v` implies `p`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.reify\"><span class=\"name\">Sat</span>.<span class=\"name\">Clause</span>.<span class=\"name\">reify</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(v : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation\">Sat.Valuation</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause\">Sat.Clause</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./foundational_types.html\">Prop</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L182-L188","name":"Sat.Fmla.reify_or","line":182,"kind":"theorem","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.reify_or","doc":"Negation turns AND into OR, so `¬⟦f₁ ∧ f₂⟧_v ≡ ¬⟦f₁⟧_v ∨ ¬⟦f₂⟧_v`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.reify_or\"><span class=\"name\">Sat</span>.<span class=\"name\">Fmla</span>.<span class=\"name\">reify_or</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{v : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation\">Sat.Valuation</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f₁ : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla\">Sat.Fmla</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{a : <a href=\"./foundational_types.html\">Prop</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f₂ : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla\">Sat.Fmla</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{b : <a href=\"./foundational_types.html\">Prop</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h₁ : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.reify\">Sat.Fmla.reify</a> <span class=\"fn\">v</span> <span class=\"fn\">f₁</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h₂ : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.reify\">Sat.Fmla.reify</a> <span class=\"fn\">v</span> <span class=\"fn\">f₂</span> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.reify\">Sat.Fmla.reify</a> <span class=\"fn\">v</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f₁</span>.and</span> <span class=\"fn\">f₂</span>)</span> <span class=\"fn\">(<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Or\">∨</a> <span class=\"fn\">b</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L175-L180","name":"Sat.Fmla.refute","line":175,"kind":"theorem","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.refute","doc":"If `f` is unsatisfiable, and every `v` which agrees with `ps` implies `¬⟦f⟧_v → p`, then `p`.\nEquivalently, there exists a valuation `v` which agrees with `ps`,\nand every such valuation yields `¬⟦f⟧_v` because `f` is unsatisfiable. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.refute\"><span class=\"name\">Sat</span>.<span class=\"name\">Fmla</span>.<span class=\"name\">refute</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{p : <a href=\"./foundational_types.html\">Prop</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{ps : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./foundational_types.html\">Prop</a></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla\">Sat.Fmla</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span>.proof</span> <span class=\"fn\">[]</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hv : <span class=\"fn\">∀ (<span class=\"fn\">v</span> : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation\">Sat.Valuation</a>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">v</span>.implies</span> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.reify\">Sat.Fmla.reify</a> <span class=\"fn\">v</span> <span class=\"fn\">f</span> <span class=\"fn\">p</span>)</span> <span class=\"fn\">ps</span> <span class=\"fn\">0</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">p</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L171-L171","name":"Sat.Fmla.reify.prop","line":171,"kind":"theorem","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.reify.prop","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.reify.prop\"><span class=\"name\">Sat</span>.<span class=\"name\">Fmla</span>.<span class=\"name\">reify</span>.<span class=\"name\">prop</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{v : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation\">Sat.Valuation</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla\">Sat.Fmla</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{p : <a href=\"./foundational_types.html\">Prop</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(self : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.reify\">Sat.Fmla.reify</a> <span class=\"fn\">v</span> <span class=\"fn\">f</span> <span class=\"fn\">p</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">v</span>.satisfies_fmla</span> <span class=\"fn\">f</span></span></span> → <span class=\"fn\">p</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L170-L170","name":"Sat.Fmla.reify.mk","line":170,"kind":"ctor","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.reify.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.reify.mk\"><span class=\"name\">Sat</span>.<span class=\"name\">Fmla</span>.<span class=\"name\">reify</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{v : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation\">Sat.Valuation</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla\">Sat.Fmla</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{p : <a href=\"./foundational_types.html\">Prop</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(prop : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">v</span>.satisfies_fmla</span> <span class=\"fn\">f</span></span></span> → <span class=\"fn\">p</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.reify\">Sat.Fmla.reify</a> <span class=\"fn\">v</span> <span class=\"fn\">f</span> <span class=\"fn\">p</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L169-L171","name":"Sat.Fmla.reify","line":169,"kind":"structure","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.reify","doc":"Asserts that `¬⟦f⟧_v` implies `p`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.reify\"><span class=\"name\">Sat</span>.<span class=\"name\">Fmla</span>.<span class=\"name\">reify</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(v : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation\">Sat.Valuation</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla\">Sat.Fmla</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./foundational_types.html\">Prop</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L154-L167","name":"Sat.Valuation.mk_implies","line":154,"kind":"theorem","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.mk_implies","doc":"The fundamental relationship between `mk` and `implies`:\n`(mk ps).implies p ps 0` is equivalent to `p`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.mk_implies\"><span class=\"name\">Sat</span>.<span class=\"name\">Valuation</span>.<span class=\"name\">mk_implies</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{p : <a href=\"./foundational_types.html\">Prop</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{as ps : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./foundational_types.html\">Prop</a></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(as₁ : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">as</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">as₁</span>.reverseAux</span> <span class=\"fn\">ps</span></span></span> → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.mk\">Sat.Valuation.mk</a> <span class=\"fn\">as</span>)</span>.implies</span> <span class=\"fn\">p</span> <span class=\"fn\">ps</span> <span class=\"fn\"><span class=\"fn\">as₁</span>.length</span></span> → <span class=\"fn\">p</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L147-L152","name":"Sat.Valuation.mk","line":147,"kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.mk","doc":"`Valuation.mk [a, b, c]` is a valuation which is `a` at 0, `b` at 1 and `c` at 2, and false\neverywhere else. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.mk\"><span class=\"name\">Sat</span>.<span class=\"name\">Valuation</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./foundational_types.html\">Prop</a></span> → <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation\">Sat.Valuation</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L141-L145","name":"Sat.Valuation.implies","line":141,"kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.implies","doc":"`v.implies p [a, b, c] 0` definitionally unfolds to `(v 0 ↔ a) → (v 1 ↔ b) → (v 2 ↔ c) → p`.\nThis is used to introduce assumptions about the first `n` values of `v` during reification. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.implies\"><span class=\"name\">Sat</span>.<span class=\"name\">Valuation</span>.<span class=\"name\">implies</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(v : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation\">Sat.Valuation</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./foundational_types.html\">Prop</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./foundational_types.html\">Prop</a></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <a href=\"./foundational_types.html\">Prop</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L126-L139","name":"Sat.Valuation.by_cases","line":126,"kind":"theorem","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.by_cases","doc":"The core unit-propagation step.\n\nWe have a local context of assumptions `¬l'` (sometimes called an assignment)\nand we wish to add `¬l` to the context, that is, we want to prove `l` is also falsified.\nThis is because there is a clause `a ∨ b ∨ ¬l` in the global context\nsuch that all literals in the clause are falsified except for `¬l`;\nso in the context `h₁` where we suppose that `¬l` is falsified,\nthe clause itself is falsified so we can prove `False`.\nWe continue the proof in `h₂`, with the assumption that `l` is falsified. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.by_cases\"><span class=\"name\">Sat</span>.<span class=\"name\">Valuation</span>.<span class=\"name\">by_cases</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{v : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation\">Sat.Valuation</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{l : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal\">Sat.Literal</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h₁ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">v</span>.neg</span> <span class=\"fn\"><span class=\"fn\">l</span>.negate</span></span> → <a href=\"./Init/Prelude.html#False\">False</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h₂ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">v</span>.neg</span> <span class=\"fn\">l</span></span> → <a href=\"./Init/Prelude.html#False\">False</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#False\">False</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L121-L124","name":"Sat.Fmla.proof_of_subsumes","line":121,"kind":"theorem","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.proof_of_subsumes","doc":"If `f` subsumes `c` (i.e. `c ∈ f`), then `f.proof c`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.proof_of_subsumes\"><span class=\"name\">Sat</span>.<span class=\"name\">Fmla</span>.<span class=\"name\">proof_of_subsumes</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla\">Sat.Fmla</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause\">Sat.Clause</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(H : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span>.subsumes</span> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.one\">Sat.Fmla.one</a> <span class=\"fn\">c</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span>.proof</span> <span class=\"fn\">c</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L117-L119","name":"Sat.Fmla.proof","line":117,"kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.proof","doc":"`f.proof c` asserts that `c` is derivable from `f`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.proof\"><span class=\"name\">Sat</span>.<span class=\"name\">Fmla</span>.<span class=\"name\">proof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(f : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla\">Sat.Fmla</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause\">Sat.Clause</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L115-L115","name":"Sat.Valuation.satisfies_fmla.prop","line":115,"kind":"theorem","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.satisfies_fmla.prop","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.satisfies_fmla.prop\"><span class=\"name\">Sat</span>.<span class=\"name\">Valuation</span>.<span class=\"name\">satisfies_fmla</span>.<span class=\"name\">prop</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{v : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation\">Sat.Valuation</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla\">Sat.Fmla</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(self : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">v</span>.satisfies_fmla</span> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause\">Sat.Clause</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">c</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">f</span></span> → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">v</span>.satisfies</span> <span class=\"fn\">c</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L114-L114","name":"Sat.Valuation.satisfies_fmla.mk","line":114,"kind":"ctor","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.satisfies_fmla.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.satisfies_fmla.mk\"><span class=\"name\">Sat</span>.<span class=\"name\">Valuation</span>.<span class=\"name\">satisfies_fmla</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{v : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation\">Sat.Valuation</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla\">Sat.Fmla</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(prop : <span class=\"fn\">∀ (<span class=\"fn\">c</span> : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause\">Sat.Clause</a>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">c</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">f</span></span> → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">v</span>.satisfies</span> <span class=\"fn\">c</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">v</span>.satisfies_fmla</span> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L112-L115","name":"Sat.Valuation.satisfies_fmla","line":112,"kind":"structure","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.satisfies_fmla","doc":"`v.satisfies_fmla f` asserts that formula `f` is satisfied by the valuation.\nA formula is satisfied if all clauses in it are satisfied. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.satisfies_fmla\"><span class=\"name\">Sat</span>.<span class=\"name\">Valuation</span>.<span class=\"name\">satisfies_fmla</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(v : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation\">Sat.Valuation</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla\">Sat.Fmla</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L104-L110","name":"Sat.Valuation.satisfies","line":104,"kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.satisfies","doc":"`v.satisfies c` asserts that clause `c` satisfied by the valuation.\nIt is written in a negative way: A clause like `a ∨ ¬b ∨ c` is rewritten as\n`¬a → b → ¬c → False`, so we are asserting that it is not the case that\nall literals in the clause are falsified. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.satisfies\"><span class=\"name\">Sat</span>.<span class=\"name\">Valuation</span>.<span class=\"name\">satisfies</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(v : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation\">Sat.Valuation</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause\">Sat.Clause</a> → <a href=\"./foundational_types.html\">Prop</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L99-L102","name":"Sat.Valuation.neg","line":99,"kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.neg","doc":"`v.neg lit` asserts that literal `lit` is falsified in the valuation. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.neg\"><span class=\"name\">Sat</span>.<span class=\"name\">Valuation</span>.<span class=\"name\">neg</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(v : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation\">Sat.Valuation</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal\">Sat.Literal</a> → <a href=\"./foundational_types.html\">Prop</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L96-L97","name":"Sat.Valuation","line":96,"kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation","doc":"A valuation is an assignment of values to all the propositional variables. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation\"><span class=\"name\">Sat</span>.<span class=\"name\">Valuation</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L93-L94","name":"Sat.Fmla.subsumes_right","line":93,"kind":"theorem","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.subsumes_right","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.subsumes_right\"><span class=\"name\">Sat</span>.<span class=\"name\">Fmla</span>.<span class=\"name\">subsumes_right</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(f f₁ f₂ : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla\">Sat.Fmla</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(H : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span>.subsumes</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f₁</span>.and</span> <span class=\"fn\">f₂</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span>.subsumes</span> <span class=\"fn\">f₂</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L91-L92","name":"Sat.Fmla.subsumes_left","line":91,"kind":"theorem","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.subsumes_left","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.subsumes_left\"><span class=\"name\">Sat</span>.<span class=\"name\">Fmla</span>.<span class=\"name\">subsumes_left</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(f f₁ f₂ : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla\">Sat.Fmla</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(H : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span>.subsumes</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f₁</span>.and</span> <span class=\"fn\">f₂</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span>.subsumes</span> <span class=\"fn\">f₁</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L90-L90","name":"Sat.Fmla.subsumes_self","line":90,"kind":"theorem","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.subsumes_self","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.subsumes_self\"><span class=\"name\">Sat</span>.<span class=\"name\">Fmla</span>.<span class=\"name\">subsumes_self</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(f : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla\">Sat.Fmla</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span>.subsumes</span> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L88-L88","name":"Sat.Fmla.subsumes.prop","line":88,"kind":"theorem","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.subsumes.prop","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.subsumes.prop\"><span class=\"name\">Sat</span>.<span class=\"name\">Fmla</span>.<span class=\"name\">subsumes</span>.<span class=\"name\">prop</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f f' : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla\">Sat.Fmla</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(self : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span>.subsumes</span> <span class=\"fn\">f'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause\">Sat.Clause</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">f'</span></span> → <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">f</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L87-L87","name":"Sat.Fmla.subsumes.mk","line":87,"kind":"ctor","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.subsumes.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.subsumes.mk\"><span class=\"name\">Sat</span>.<span class=\"name\">Fmla</span>.<span class=\"name\">subsumes</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f f' : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla\">Sat.Fmla</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(prop : <span class=\"fn\">∀ (<span class=\"fn\">x</span> : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause\">Sat.Clause</a>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">f'</span></span> → <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">f</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span>.subsumes</span> <span class=\"fn\">f'</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L85-L88","name":"Sat.Fmla.subsumes","line":85,"kind":"structure","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.subsumes","doc":"Formula `f` subsumes `f'` if all the clauses in `f'` are in `f`.\nWe use this to prove that all clauses in the formula are subsumed by it. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.subsumes\"><span class=\"name\">Sat</span>.<span class=\"name\">Fmla</span>.<span class=\"name\">subsumes</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(f f' : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla\">Sat.Fmla</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L82-L83","name":"Sat.Fmla.and","line":82,"kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.and","doc":"A conjunction of formulas. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.and\"><span class=\"name\">Sat</span>.<span class=\"name\">Fmla</span>.<span class=\"name\">and</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(a b : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla\">Sat.Fmla</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla\">Sat.Fmla</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L79-L80","name":"Sat.Fmla.one","line":79,"kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.one","doc":"A single clause as a formula. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.one\"><span class=\"name\">Sat</span>.<span class=\"name\">Fmla</span>.<span class=\"name\">one</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause\">Sat.Clause</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla\">Sat.Fmla</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L76-L77","name":"Sat.Fmla","line":76,"kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla","doc":"A formula is a list of clauses, thought of as a conjunction like `(a ∨ b) ∧ c ∧ (¬c ∨ ¬d)`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla\"><span class=\"name\">Sat</span>.<span class=\"name\">Fmla</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L74-L74","name":"Sat.Clause.cons","line":74,"kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.cons","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.cons\"><span class=\"name\">Sat</span>.<span class=\"name\">Clause</span>.<span class=\"name\">cons</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal\">Sat.Literal</a> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause\">Sat.Clause</a> → <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause\">Sat.Clause</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L73-L73","name":"Sat.Clause.nil","line":73,"kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.nil","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.nil\"><span class=\"name\">Sat</span>.<span class=\"name\">Clause</span>.<span class=\"name\">nil</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause\">Sat.Clause</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L70-L71","name":"Sat.Clause","line":70,"kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause","doc":"A clause is a list of literals, thought of as a disjunction like `a ∨ b ∨ ¬c`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause\"><span class=\"name\">Sat</span>.<span class=\"name\">Clause</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L64-L68","name":"Sat.instToExprLiteral","line":64,"kind":"instance","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.instToExprLiteral","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.instToExprLiteral\"><span class=\"name\">Sat</span>.<span class=\"name\">instToExprLiteral</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/ToExpr.html#Lean.ToExpr\">Lean.ToExpr</a> <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal\">Sat.Literal</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L59-L62","name":"Sat.Literal.negate","line":59,"kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.negate","doc":"Swap the polarity of a literal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.negate\"><span class=\"name\">Sat</span>.<span class=\"name\">Literal</span>.<span class=\"name\">negate</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal\">Sat.Literal</a> → <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal\">Sat.Literal</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L54-L57","name":"Sat.Literal.ofInt","line":54,"kind":"def","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.ofInt","doc":"Construct a literal. Positive numbers are translated to positive literals,\nand negative numbers become negative literals. The input is assumed to be nonzero. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.ofInt\"><span class=\"name\">Sat</span>.<span class=\"name\">Literal</span>.<span class=\"name\">ofInt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(i : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal\">Sat.Literal</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L52-L52","name":"Sat.Literal.neg","line":52,"kind":"ctor","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.neg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.neg\"><span class=\"name\">Sat</span>.<span class=\"name\">Literal</span>.<span class=\"name\">neg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal\">Sat.Literal</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L51-L51","name":"Sat.Literal.pos","line":51,"kind":"ctor","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.pos","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.pos\"><span class=\"name\">Sat</span>.<span class=\"name\">Literal</span>.<span class=\"name\">pos</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <a href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal\">Sat.Literal</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Sat/FromLRAT.lean#L48-L52","name":"Sat.Literal","line":48,"kind":"inductive","docLink":"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal","doc":"A literal is a positive or negative occurrence of an atomic propositional variable.\nNote that unlike DIMACS, 0 is a valid variable index. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal\"><span class=\"name\">Sat</span>.<span class=\"name\">Literal</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"}]}