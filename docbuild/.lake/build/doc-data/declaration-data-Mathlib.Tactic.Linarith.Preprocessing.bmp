{"name":"Mathlib.Tactic.Linarith.Preprocessing","instances":[],"imports":["Init","Mathlib.Tactic.Linarith.Datatypes","Mathlib.Tactic.Zify","Mathlib.Tactic.CancelDenoms.Core","Batteries.Data.RBMap.Basic","Mathlib.Control.Basic","Mathlib.Util.AtomM"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Linarith/Preprocessing.lean#L375-L384","name":"Linarith.preprocess","line":375,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.preprocess","doc":"`preprocess pps l` takes a list `l` of proofs of propositions.\nIt maps each preprocessor `pp ∈ pps` over this list.\nThe preprocessors are run sequentially: each receives the output of the previous one.\nNote that a preprocessor may produce multiple or no expressions from each input expression,\nso the size of the list may change.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.preprocess\"><span class=\"name\">Linarith</span>.<span class=\"name\">preprocess</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(pps : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalBranchingPreprocessor\">Linarith.GlobalBranchingPreprocessor</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(l : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Branch\">Linarith.Branch</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Linarith/Preprocessing.lean#L368-L373","name":"Linarith.defaultPreprocessors","line":368,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.defaultPreprocessors","doc":"The default list of preprocessors, in the order they should typically run.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.defaultPreprocessors\"><span class=\"name\">Linarith</span>.<span class=\"name\">defaultPreprocessors</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalBranchingPreprocessor\">Linarith.GlobalBranchingPreprocessor</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Linarith/Preprocessing.lean#L357-L364","name":"Linarith.removeNe","line":357,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.removeNe","doc":"`removeNe` case splits on any proof `h : a ≠ b` in the input, turning it into `a < b ∨ a > b`,\nby calling `linarith.removeNe_aux`.\nThis produces `2^n` branches when there are `n` such hypotheses in the input.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.removeNe\"><span class=\"name\">Linarith</span>.<span class=\"name\">removeNe</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalBranchingPreprocessor\">Linarith.GlobalBranchingPreprocessor</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Linarith/Preprocessing.lean#L339-L355","name":"Linarith.removeNe_aux","line":339,"kind":"opaque","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.removeNe_aux","doc":"`removeNe_aux` case splits on any proof `h : a ≠ b` in the input,\nturning it into `a < b ∨ a > b`.\nThis produces `2^n` branches when there are `n` such hypotheses in the input.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.removeNe_aux\"><span class=\"name\">Linarith</span>.<span class=\"name\">removeNe_aux</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Branch\">Linarith.Branch</a>)</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Linarith/Preprocessing.lean#L290-L334","name":"Linarith.nlinarithExtras","line":290,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.nlinarithExtras","doc":"`nlinarithExtras` is the preprocessor corresponding to the `nlinarith` tactic.\n\n* For every term `t` such that `t^2` or `t*t` appears in the input, adds a proof of `t^2 ≥ 0`\n  or `t*t ≥ 0`.\n* For every pair of comparisons `t1 R1 0` and `t2 R2 0`, adds a proof of `t1*t2 R 0`.\n\nThis preprocessor is typically run last, after all inputs have been canonized.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.nlinarithExtras\"><span class=\"name\">Linarith</span>.<span class=\"name\">nlinarithExtras</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalPreprocessor\">Linarith.GlobalPreprocessor</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Linarith/Preprocessing.lean#L260-L288","name":"Linarith.findSquares","line":260,"kind":"opaque","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.findSquares","doc":"`findSquares s e` collects all terms of the form `a ^ 2` and `a * a` that appear in `e`\nand adds them to the set `s`.\nA pair `(i, true)` is added to `s` when `atoms[i]^2` appears in `e`,\nand `(i, false)` is added to `s` when `atoms[i]*atoms[i]` appears in `e`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.findSquares\"><span class=\"name\">Linarith</span>.<span class=\"name\">findSquares</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Batteries/Data/RBMap/Basic.html#Batteries.RBSet\">Batteries.RBSet</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span> <span class=\"fn\">compare</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">Mathlib.Tactic.AtomM</a> <span class=\"fn\">(<a href=\"./Batteries/Data/RBMap/Basic.html#Batteries.RBSet\">Batteries.RBSet</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span> <span class=\"fn\">compare</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Linarith/Preprocessing.lean#L245-L256","name":"Linarith.cancelDenoms","line":245,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.cancelDenoms","doc":"`cancelDenoms pf` assumes `pf` is a proof of `t R 0`. If `t` contains the division symbol `/`,\nit tries to scale `t` to cancel out division by numerals.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.cancelDenoms\"><span class=\"name\">Linarith</span>.<span class=\"name\">cancelDenoms</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Preprocessor\">Linarith.Preprocessor</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Linarith/Preprocessing.lean#L227-L243","name":"Linarith.normalizeDenominatorsLHS","line":227,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.normalizeDenominatorsLHS","doc":"`normalizeDenominatorsLHS h lhs` assumes that `h` is a proof of `lhs R 0`.\nIt creates a proof of `lhs' R 0`, where all numeric division in `lhs` has been cancelled.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.normalizeDenominatorsLHS\"><span class=\"name\">Linarith</span>.<span class=\"name\">normalizeDenominatorsLHS</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(h lhs : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Linarith/Preprocessing.lean#L224-L225","name":"Linarith.without_one_mul","line":224,"kind":"theorem","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.without_one_mul","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.without_one_mul\"><span class=\"name\">Linarith</span>.<span class=\"name\">without_one_mul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{M : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#MulOneClass\">MulOneClass</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{a b : <span class=\"fn\">M</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">1</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Linarith/Preprocessing.lean#L212-L218","name":"Linarith.compWithZero","line":212,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.compWithZero","doc":"`compWithZero h` takes a proof `h` of an equality, inequality, or negation thereof,\nand turns it into a proof of a comparison `_ R 0`, where `R ∈ {=, ≤, <}`.\n "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.compWithZero\"><span class=\"name\">Linarith</span>.<span class=\"name\">compWithZero</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Preprocessor\">Linarith.Preprocessor</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Linarith/Preprocessing.lean#L202-L210","name":"Linarith.rearrangeComparison","line":202,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.rearrangeComparison","doc":"`rearrangeComparison e` takes a proof `e` of an equality, inequality, or negation thereof,\nand turns it into a proof of a comparison `_ R 0`, where `R ∈ {=, ≤, <}`.\n "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.rearrangeComparison\"><span class=\"name\">Linarith</span>.<span class=\"name\">rearrangeComparison</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Linarith/Preprocessing.lean#L192-L196","name":"Linarith.strengthenStrictInt","line":192,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.strengthenStrictInt","doc":"`strengthenStrictInt h` turns a proof `h` of a strict integer inequality `t1 < t2`\ninto a proof of `t1 ≤ t2 + 1`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.strengthenStrictInt\"><span class=\"name\">Linarith</span>.<span class=\"name\">strengthenStrictInt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Preprocessor\">Linarith.Preprocessor</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Linarith/Preprocessing.lean#L178-L190","name":"Linarith.mkNonstrictIntProof","line":178,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.mkNonstrictIntProof","doc":"If `pf` is a proof of a strict inequality `(a : ℤ) < b`,\n`mkNonstrictIntProof pf` returns a proof of `a + 1 ≤ b`,\nand similarly if `pf` proves a negated weak inequality.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.mkNonstrictIntProof\"><span class=\"name\">Linarith</span>.<span class=\"name\">mkNonstrictIntProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(pf : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Linarith/Preprocessing.lean#L143-L172","name":"Linarith.natToInt","line":143,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.natToInt","doc":"If `h` is an equality or inequality between natural numbers,\n`natToInt` lifts this inequality to the integers.\nIt also adds the facts that the integers involved are nonnegative.\nTo avoid adding the same nonnegativity facts many times, it is a global preprocessor.\n "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.natToInt\"><span class=\"name\">Linarith</span>.<span class=\"name\">natToInt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalBranchingPreprocessor\">Linarith.GlobalBranchingPreprocessor</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Linarith/Preprocessing.lean#L136-L138","name":"Linarith.Expr.Ord","line":136,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.Expr.Ord","doc":"Ordering on `Expr`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.Expr.Ord\"><span class=\"name\">Linarith</span>.<span class=\"name\">Expr</span>.<span class=\"name\">Ord</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Ord.html#Ord\">Ord</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Linarith/Preprocessing.lean#L127-L133","name":"Linarith.mk_natCast_nonneg_prf","line":127,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.mk_natCast_nonneg_prf","doc":"If `e : ℕ`, returns a proof of `0 ≤ (e : C)`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.mk_natCast_nonneg_prf\"><span class=\"name\">Linarith</span>.<span class=\"name\">mk_natCast_nonneg_prf</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Linarith/Preprocessing.lean#L114-L125","name":"Linarith.getNatComparisons","line":114,"kind":"opaque","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.getNatComparisons","doc":"`getNatComparisons e` returns a list of all subexpressions of `e` of the form `((t : ℕ) : C)`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.getNatComparisons\"><span class=\"name\">Linarith</span>.<span class=\"name\">getNatComparisons</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Linarith/Preprocessing.lean#L108-L112","name":"Linarith.isNatCoe","line":108,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.isNatCoe","doc":"If `e` is of the form `((n : ℕ) : C)`, `isNatCoe e` returns `⟨n, C⟩`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.isNatCoe\"><span class=\"name\">Linarith</span>.<span class=\"name\">isNatCoe</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Linarith/Preprocessing.lean#L101-L106","name":"Linarith.isNatProp","line":101,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.isNatProp","doc":"`isNatProp tp` is true iff `tp` is an inequality or equality between natural numbers\nor the negation thereof.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.isNatProp\"><span class=\"name\">Linarith</span>.<span class=\"name\">isNatProp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Linarith/Preprocessing.lean#L78-L93","name":"Linarith.removeNegations","line":78,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.removeNegations","doc":"Replaces proofs of negations of comparisons with proofs of the reversed comparisons.\nFor example, a proof of `¬ a < b` will become a proof of `a ≥ b`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.removeNegations\"><span class=\"name\">Linarith</span>.<span class=\"name\">removeNegations</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Preprocessor\">Linarith.Preprocessor</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Linarith/Preprocessing.lean#L67-L76","name":"Linarith.flipNegatedComparison","line":67,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.flipNegatedComparison","doc":"If `prf` is a proof of `¬ e`, where `e` is a comparison,\n`flipNegatedComparison prf e` flips the comparison in `e` and returns a proof.\nFor example, if `prf : ¬ a < b`, ``flipNegatedComparison prf q(a < b)`` returns a proof of `a ≥ b`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.flipNegatedComparison\"><span class=\"name\">Linarith</span>.<span class=\"name\">flipNegatedComparison</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(prf e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Linarith/Preprocessing.lean#L53-L63","name":"Linarith.filterComparisons","line":53,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.filterComparisons","doc":"Removes any expressions that are not proofs of inequalities, equalities, or negations thereof.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.filterComparisons\"><span class=\"name\">Linarith</span>.<span class=\"name\">filterComparisons</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Preprocessor\">Linarith.Preprocessor</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Linarith/Preprocessing.lean#L46-L51","name":"Linarith.splitConjunctions.aux","line":46,"kind":"opaque","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.splitConjunctions.aux","doc":"Implementation of the `splitConjunctions` preprocessor. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.splitConjunctions.aux\"><span class=\"name\">Linarith</span>.<span class=\"name\">splitConjunctions</span>.<span class=\"name\">aux</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(proof : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Tactic/Linarith/Preprocessing.lean#L40-L51","name":"Linarith.splitConjunctions","line":40,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.splitConjunctions","doc":"Processor that recursively replaces `P ∧ Q` hypotheses with the pair `P` and `Q`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.splitConjunctions\"><span class=\"name\">Linarith</span>.<span class=\"name\">splitConjunctions</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Preprocessor\">Linarith.Preprocessor</a></div></div>"}]}