<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Logic.Basic</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Logic.Basic";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Logic</span>.<span class="name">Basic</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Batteries/Logic.html">Batteries.Logic</a></li><li><a href="../.././Batteries/Tactic/Trans.html">Batteries.Tactic.Trans</a></li><li><a href="../.././Batteries/Util/LibraryNote.html">Batteries.Util.LibraryNote</a></li><li><a href="../.././Mathlib/Tactic/Basic.html">Mathlib.Tactic.Basic</a></li><li><a href="../.././Mathlib/Data/Int/Notation.html">Mathlib.Data.Int.Notation</a></li><li><a href="../.././Mathlib/Data/Nat/Notation.html">Mathlib.Data.Nat.Notation</a></li><li><a href="../.././Mathlib/Tactic/Attr/Register.html">Mathlib.Tactic.Attr.Register</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Logic.Basic" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#hidden"><span class="name">hidden</span></a></div><div class="nav_link"><a class="break_within" href="#decidableEq_of_subsingleton"><span class="name">decidableEq_of_subsingleton</span></a></div><div class="nav_link"><a class="break_within" href="#instSubsingletonSubtype_mathlib"><span class="name">instSubsingletonSubtype_mathlib</span></a></div><div class="nav_link"><a class="break_within" href="#congr_heq"><span class="name">congr_heq</span></a></div><div class="nav_link"><a class="break_within" href="#congr_arg_heq"><span class="name">congr_arg_heq</span></a></div><div class="nav_link"><a class="break_within" href="#eq_iff_eq_cancel_left"><span class="name">eq_iff_eq_cancel_left</span></a></div><div class="nav_link"><a class="break_within" href="#eq_iff_eq_cancel_right"><span class="name">eq_iff_eq_cancel_right</span></a></div><div class="nav_link"><a class="break_within" href="#ne_and_eq_iff_right"><span class="name">ne_and_eq_iff_right</span></a></div><div class="nav_link"><a class="break_within" href="#Fact"><span class="name">Fact</span></a></div><div class="nav_link"><a class="break_within" href="#Fact.elim"><span class="name">Fact</span>.<span class="name">elim</span></a></div><div class="nav_link"><a class="break_within" href="#fact_iff"><span class="name">fact_iff</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableFact"><span class="name">instDecidableFact</span></a></div><div class="nav_link"><a class="break_within" href="#Function.swap₂"><span class="name">Function</span>.<span class="name">swap₂</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.imp"><span class="name">Iff</span>.<span class="name">imp</span></a></div><div class="nav_link"><a class="break_within" href="#imp_iff_right_iff"><span class="name">imp_iff_right_iff</span></a></div><div class="nav_link"><a class="break_within" href="#and_or_imp"><span class="name">and_or_imp</span></a></div><div class="nav_link"><a class="break_within" href="#Function.mt"><span class="name">Function</span>.<span class="name">mt</span></a></div><div class="nav_link"><a class="break_within" href="#dec_em"><span class="name">dec_em</span></a></div><div class="nav_link"><a class="break_within" href="#dec_em'"><span class="name">dec_em'</span></a></div><div class="nav_link"><a class="break_within" href="#em"><span class="name">em</span></a></div><div class="nav_link"><a class="break_within" href="#em'"><span class="name">em'</span></a></div><div class="nav_link"><a class="break_within" href="#or_not"><span class="name">or_not</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.eq_or_ne"><span class="name">Decidable</span>.<span class="name">eq_or_ne</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.ne_or_eq"><span class="name">Decidable</span>.<span class="name">ne_or_eq</span></a></div><div class="nav_link"><a class="break_within" href="#eq_or_ne"><span class="name">eq_or_ne</span></a></div><div class="nav_link"><a class="break_within" href="#ne_or_eq"><span class="name">ne_or_eq</span></a></div><div class="nav_link"><a class="break_within" href="#by_contradiction"><span class="name">by_contradiction</span></a></div><div class="nav_link"><a class="break_within" href="#by_cases"><span class="name">by_cases</span></a></div><div class="nav_link"><a class="break_within" href="#by_contra"><span class="name">by_contra</span></a></div><div class="nav_link"><a class="break_within" href="#of_not_not"><span class="name">of_not_not</span></a></div><div class="nav_link"><a class="break_within" href="#not_ne_iff"><span class="name">not_ne_iff</span></a></div><div class="nav_link"><a class="break_within" href="#of_not_imp"><span class="name">of_not_imp</span></a></div><div class="nav_link"><a class="break_within" href="#Not.decidable_imp_symm"><span class="name">Not</span>.<span class="name">decidable_imp_symm</span></a></div><div class="nav_link"><a class="break_within" href="#Not.imp_symm"><span class="name">Not</span>.<span class="name">imp_symm</span></a></div><div class="nav_link"><a class="break_within" href="#not_imp_comm"><span class="name">not_imp_comm</span></a></div><div class="nav_link"><a class="break_within" href="#not_imp_self"><span class="name">not_imp_self</span></a></div><div class="nav_link"><a class="break_within" href="#Imp.swap"><span class="name">Imp</span>.<span class="name">swap</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.not"><span class="name">Iff</span>.<span class="name">not</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.not_left"><span class="name">Iff</span>.<span class="name">not_left</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.not_right"><span class="name">Iff</span>.<span class="name">not_right</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.ne"><span class="name">Iff</span>.<span class="name">ne</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.ne_left"><span class="name">Iff</span>.<span class="name">ne_left</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.ne_right"><span class="name">Iff</span>.<span class="name">ne_right</span></a></div><div class="nav_link"><a class="break_within" href="#Xor'"><span class="name">Xor'</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableXor'"><span class="name">instDecidableXor'</span></a></div><div class="nav_link"><a class="break_within" href="#xor_true"><span class="name">xor_true</span></a></div><div class="nav_link"><a class="break_within" href="#xor_false"><span class="name">xor_false</span></a></div><div class="nav_link"><a class="break_within" href="#xor_comm"><span class="name">xor_comm</span></a></div><div class="nav_link"><a class="break_within" href="#instCommutativeXor'"><span class="name">instCommutativeXor'</span></a></div><div class="nav_link"><a class="break_within" href="#xor_self"><span class="name">xor_self</span></a></div><div class="nav_link"><a class="break_within" href="#xor_not_left"><span class="name">xor_not_left</span></a></div><div class="nav_link"><a class="break_within" href="#xor_not_right"><span class="name">xor_not_right</span></a></div><div class="nav_link"><a class="break_within" href="#xor_not_not"><span class="name">xor_not_not</span></a></div><div class="nav_link"><a class="break_within" href="#Xor'.or"><span class="name">Xor'</span>.<span class="name">or</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.and"><span class="name">Iff</span>.<span class="name">and</span></a></div><div class="nav_link"><a class="break_within" href="#And.rotate"><span class="name">And</span>.<span class="name">rotate</span></a></div><div class="nav_link"><a class="break_within" href="#and_symm_right"><span class="name">and_symm_right</span></a></div><div class="nav_link"><a class="break_within" href="#and_symm_left"><span class="name">and_symm_left</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.or"><span class="name">Iff</span>.<span class="name">or</span></a></div><div class="nav_link"><a class="break_within" href="#Or.rotate"><span class="name">Or</span>.<span class="name">rotate</span></a></div><div class="nav_link"><a class="break_within" href="#Or.elim3"><span class="name">Or</span>.<span class="name">elim3</span></a></div><div class="nav_link"><a class="break_within" href="#Or.imp3"><span class="name">Or</span>.<span class="name">imp3</span></a></div><div class="nav_link"><a class="break_within" href="#not_or_of_imp"><span class="name">not_or_of_imp</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.or_not_of_imp"><span class="name">Decidable</span>.<span class="name">or_not_of_imp</span></a></div><div class="nav_link"><a class="break_within" href="#or_not_of_imp"><span class="name">or_not_of_imp</span></a></div><div class="nav_link"><a class="break_within" href="#imp_iff_not_or"><span class="name">imp_iff_not_or</span></a></div><div class="nav_link"><a class="break_within" href="#imp_iff_or_not"><span class="name">imp_iff_or_not</span></a></div><div class="nav_link"><a class="break_within" href="#not_imp_not"><span class="name">not_imp_not</span></a></div><div class="nav_link"><a class="break_within" href="#imp_and_neg_imp_iff"><span class="name">imp_and_neg_imp_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Function.mtr"><span class="name">Function</span>.<span class="name">mtr</span></a></div><div class="nav_link"><a class="break_within" href="#or_congr_left'"><span class="name">or_congr_left'</span></a></div><div class="nav_link"><a class="break_within" href="#or_congr_right'"><span class="name">or_congr_right'</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.iff"><span class="name">Iff</span>.<span class="name">iff</span></a></div><div class="nav_link"><a class="break_within" href="#iff_mpr_iff_true_intro"><span class="name">iff_mpr_iff_true_intro</span></a></div><div class="nav_link"><a class="break_within" href="#imp_or"><span class="name">imp_or</span></a></div><div class="nav_link"><a class="break_within" href="#imp_or'"><span class="name">imp_or'</span></a></div><div class="nav_link"><a class="break_within" href="#not_imp"><span class="name">not_imp</span></a></div><div class="nav_link"><a class="break_within" href="#peirce"><span class="name">peirce</span></a></div><div class="nav_link"><a class="break_within" href="#not_iff_not"><span class="name">not_iff_not</span></a></div><div class="nav_link"><a class="break_within" href="#not_iff_comm"><span class="name">not_iff_comm</span></a></div><div class="nav_link"><a class="break_within" href="#not_iff"><span class="name">not_iff</span></a></div><div class="nav_link"><a class="break_within" href="#iff_not_comm"><span class="name">iff_not_comm</span></a></div><div class="nav_link"><a class="break_within" href="#iff_iff_and_or_not_and_not"><span class="name">iff_iff_and_or_not_and_not</span></a></div><div class="nav_link"><a class="break_within" href="#iff_iff_not_or_and_or_not"><span class="name">iff_iff_not_or_and_or_not</span></a></div><div class="nav_link"><a class="break_within" href="#not_and_not_right"><span class="name">not_and_not_right</span></a></div><div class="nav_link"><a class="break_within" href="#not_and_or"><span class="name">not_and_or</span></a></div><div class="nav_link"><a class="break_within" href="#or_iff_not_and_not"><span class="name">or_iff_not_and_not</span></a></div><div class="nav_link"><a class="break_within" href="#and_iff_not_or_not"><span class="name">and_iff_not_or_not</span></a></div><div class="nav_link"><a class="break_within" href="#not_xor"><span class="name">not_xor</span></a></div><div class="nav_link"><a class="break_within" href="#xor_iff_not_iff"><span class="name">xor_iff_not_iff</span></a></div><div class="nav_link"><a class="break_within" href="#xor_iff_iff_not"><span class="name">xor_iff_iff_not</span></a></div><div class="nav_link"><a class="break_within" href="#xor_iff_not_iff'"><span class="name">xor_iff_not_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#Membership.mem.ne_of_not_mem"><span class="name">Membership</span>.<span class="name">mem</span>.<span class="name">ne_of_not_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Membership.mem.ne_of_not_mem'"><span class="name">Membership</span>.<span class="name">mem</span>.<span class="name">ne_of_not_mem'</span></a></div><div class="nav_link"><a class="break_within" href="#forall_cond_comm"><span class="name">forall_cond_comm</span></a></div><div class="nav_link"><a class="break_within" href="#forall_mem_comm"><span class="name">forall_mem_comm</span></a></div><div class="nav_link"><a class="break_within" href="#ball_cond_comm"><span class="name">ball_cond_comm</span></a></div><div class="nav_link"><a class="break_within" href="#ball_mem_comm"><span class="name">ball_mem_comm</span></a></div><div class="nav_link"><a class="break_within" href="#ne_of_eq_of_ne"><span class="name">ne_of_eq_of_ne</span></a></div><div class="nav_link"><a class="break_within" href="#ne_of_ne_of_eq"><span class="name">ne_of_ne_of_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Eq.trans_ne"><span class="name">Eq</span>.<span class="name">trans_ne</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.trans_eq"><span class="name">Ne</span>.<span class="name">trans_eq</span></a></div><div class="nav_link"><a class="break_within" href="#eq_equivalence"><span class="name">eq_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#congr_refl_left"><span class="name">congr_refl_left</span></a></div><div class="nav_link"><a class="break_within" href="#congr_refl_right"><span class="name">congr_refl_right</span></a></div><div class="nav_link"><a class="break_within" href="#congr_arg_refl"><span class="name">congr_arg_refl</span></a></div><div class="nav_link"><a class="break_within" href="#congr_fun_rfl"><span class="name">congr_fun_rfl</span></a></div><div class="nav_link"><a class="break_within" href="#congr_fun_congr_arg"><span class="name">congr_fun_congr_arg</span></a></div><div class="nav_link"><a class="break_within" href="#Eq.rec_eq_cast"><span class="name">Eq</span>.<span class="name">rec_eq_cast</span></a></div><div class="nav_link"><a class="break_within" href="#eqRec_heq'"><span class="name">eqRec_heq'</span></a></div><div class="nav_link"><a class="break_within" href="#rec_heq_of_heq"><span class="name">rec_heq_of_heq</span></a></div><div class="nav_link"><a class="break_within" href="#rec_heq_iff_heq"><span class="name">rec_heq_iff_heq</span></a></div><div class="nav_link"><a class="break_within" href="#heq_rec_iff_heq"><span class="name">heq_rec_iff_heq</span></a></div><div class="nav_link"><a class="break_within" href="#heq_of_eq_cast"><span class="name">heq_of_eq_cast</span></a></div><div class="nav_link"><a class="break_within" href="#eq_cast_iff_heq"><span class="name">eq_cast_iff_heq</span></a></div><div class="nav_link"><a class="break_within" href="#forall₂_imp"><span class="name">forall₂_imp</span></a></div><div class="nav_link"><a class="break_within" href="#forall₃_imp"><span class="name">forall₃_imp</span></a></div><div class="nav_link"><a class="break_within" href="#Exists₂.imp"><span class="name">Exists₂</span>.<span class="name">imp</span></a></div><div class="nav_link"><a class="break_within" href="#Exists₃.imp"><span class="name">Exists₃</span>.<span class="name">imp</span></a></div><div class="nav_link"><a class="break_within" href="#forall_swap"><span class="name">forall_swap</span></a></div><div class="nav_link"><a class="break_within" href="#forall₂_swap"><span class="name">forall₂_swap</span></a></div><div class="nav_link"><a class="break_within" href="#imp_forall_iff"><span class="name">imp_forall_iff</span></a></div><div class="nav_link"><a class="break_within" href="#imp_forall_iff_forall"><span class="name">imp_forall_iff_forall</span></a></div><div class="nav_link"><a class="break_within" href="#exists_swap"><span class="name">exists_swap</span></a></div><div class="nav_link"><a class="break_within" href="#exists_and_exists_comm"><span class="name">exists_and_exists_comm</span></a></div><div class="nav_link"><a class="break_within" href="#not_forall_not"><span class="name">not_forall_not</span></a></div><div class="nav_link"><a class="break_within" href="#forall_or_exists_not"><span class="name">forall_or_exists_not</span></a></div><div class="nav_link"><a class="break_within" href="#exists_or_forall_not"><span class="name">exists_or_forall_not</span></a></div><div class="nav_link"><a class="break_within" href="#forall_imp_iff_exists_imp"><span class="name">forall_imp_iff_exists_imp</span></a></div><div class="nav_link"><a class="break_within" href="#forall_true_iff"><span class="name">forall_true_iff</span></a></div><div class="nav_link"><a class="break_within" href="#forall_true_iff'"><span class="name">forall_true_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#forall₂_true_iff"><span class="name">forall₂_true_iff</span></a></div><div class="nav_link"><a class="break_within" href="#forall₃_true_iff"><span class="name">forall₃_true_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.and_forall_ne"><span class="name">Decidable</span>.<span class="name">and_forall_ne</span></a></div><div class="nav_link"><a class="break_within" href="#and_forall_ne"><span class="name">and_forall_ne</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.ne_or_ne"><span class="name">Ne</span>.<span class="name">ne_or_ne</span></a></div><div class="nav_link"><a class="break_within" href="#exists_apply_eq_apply'"><span class="name">exists_apply_eq_apply'</span></a></div><div class="nav_link"><a class="break_within" href="#exists_apply_eq_apply2"><span class="name">exists_apply_eq_apply2</span></a></div><div class="nav_link"><a class="break_within" href="#exists_apply_eq_apply2'"><span class="name">exists_apply_eq_apply2'</span></a></div><div class="nav_link"><a class="break_within" href="#exists_apply_eq_apply3"><span class="name">exists_apply_eq_apply3</span></a></div><div class="nav_link"><a class="break_within" href="#exists_apply_eq_apply3'"><span class="name">exists_apply_eq_apply3'</span></a></div><div class="nav_link"><a class="break_within" href="#exists_apply_eq"><span class="name">exists_apply_eq</span></a></div><div class="nav_link"><a class="break_within" href="#exists_exists_and_eq_and"><span class="name">exists_exists_and_eq_and</span></a></div><div class="nav_link"><a class="break_within" href="#exists_exists_eq_and"><span class="name">exists_exists_eq_and</span></a></div><div class="nav_link"><a class="break_within" href="#exists_exists_and_exists_and_eq_and"><span class="name">exists_exists_and_exists_and_eq_and</span></a></div><div class="nav_link"><a class="break_within" href="#exists_exists_exists_and_eq"><span class="name">exists_exists_exists_and_eq</span></a></div><div class="nav_link"><a class="break_within" href="#forall_apply_eq_imp_iff'"><span class="name">forall_apply_eq_imp_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#forall_eq_apply_imp_iff'"><span class="name">forall_eq_apply_imp_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#exists₂_comm"><span class="name">exists₂_comm</span></a></div><div class="nav_link"><a class="break_within" href="#And.exists"><span class="name">And</span>.<span class="name">exists</span></a></div><div class="nav_link"><a class="break_within" href="#forall_or_of_or_forall"><span class="name">forall_or_of_or_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.forall_or_left"><span class="name">Decidable</span>.<span class="name">forall_or_left</span></a></div><div class="nav_link"><a class="break_within" href="#forall_or_left"><span class="name">forall_or_left</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.forall_or_right"><span class="name">Decidable</span>.<span class="name">forall_or_right</span></a></div><div class="nav_link"><a class="break_within" href="#forall_or_right"><span class="name">forall_or_right</span></a></div><div class="nav_link"><a class="break_within" href="#Exists.fst"><span class="name">Exists</span>.<span class="name">fst</span></a></div><div class="nav_link"><a class="break_within" href="#Exists.snd"><span class="name">Exists</span>.<span class="name">snd</span></a></div><div class="nav_link"><a class="break_within" href="#Prop.exists_iff"><span class="name">Prop</span>.<span class="name">exists_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Prop.forall_iff"><span class="name">Prop</span>.<span class="name">forall_iff</span></a></div><div class="nav_link"><a class="break_within" href="#exists_iff_of_forall"><span class="name">exists_iff_of_forall</span></a></div><div class="nav_link"><a class="break_within" href="#exists_prop_of_false"><span class="name">exists_prop_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#forall_prop_congr"><span class="name">forall_prop_congr</span></a></div><div class="nav_link"><a class="break_within" href="#forall_prop_congr'"><span class="name">forall_prop_congr'</span></a></div><div class="nav_link"><a class="break_within" href="#imp_congr_eq"><span class="name">imp_congr_eq</span></a></div><div class="nav_link"><a class="break_within" href="#imp_congr_ctx_eq"><span class="name">imp_congr_ctx_eq</span></a></div><div class="nav_link"><a class="break_within" href="#eq_true_intro"><span class="name">eq_true_intro</span></a></div><div class="nav_link"><a class="break_within" href="#eq_false_intro"><span class="name">eq_false_intro</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.eq"><span class="name">Iff</span>.<span class="name">eq</span></a></div><div class="nav_link"><a class="break_within" href="#iff_eq_eq"><span class="name">iff_eq_eq</span></a></div><div class="nav_link"><a class="break_within" href="#forall_true_left"><span class="name">forall_true_left</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.dec"><span class="name">Classical</span>.<span class="name">dec</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.decPred"><span class="name">Classical</span>.<span class="name">decPred</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.decRel"><span class="name">Classical</span>.<span class="name">decRel</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.decEq"><span class="name">Classical</span>.<span class="name">decEq</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.existsCases"><span class="name">Classical</span>.<span class="name">existsCases</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.some_spec₂"><span class="name">Classical</span>.<span class="name">some_spec₂</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.subtype_of_exists"><span class="name">Classical</span>.<span class="name">subtype_of_exists</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.byContradiction'"><span class="name">Classical</span>.<span class="name">byContradiction'</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.choice_of_byContradiction'"><span class="name">Classical</span>.<span class="name">choice_of_byContradiction'</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.choose_eq"><span class="name">Classical</span>.<span class="name">choose_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.choose_eq'"><span class="name">Classical</span>.<span class="name">choose_eq'</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.axiom_of_choice"><span class="name">Classical</span>.<span class="name">axiom_of_choice</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.by_cases"><span class="name">Classical</span>.<span class="name">by_cases</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.by_contradiction"><span class="name">Classical</span>.<span class="name">by_contradiction</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.prop_complete"><span class="name">Classical</span>.<span class="name">prop_complete</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.cases_true_false"><span class="name">Classical</span>.<span class="name">cases_true_false</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.eq_false_or_eq_true"><span class="name">Classical</span>.<span class="name">eq_false_or_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.cases_on"><span class="name">Classical</span>.<span class="name">cases_on</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.cases"><span class="name">Classical</span>.<span class="name">cases</span></a></div><div class="nav_link"><a class="break_within" href="#Exists.classicalRecOn"><span class="name">Exists</span>.<span class="name">classicalRecOn</span></a></div><div class="nav_link"><a class="break_within" href="#bex_def"><span class="name">bex_def</span></a></div><div class="nav_link"><a class="break_within" href="#BEx.elim"><span class="name">BEx</span>.<span class="name">elim</span></a></div><div class="nav_link"><a class="break_within" href="#BEx.intro"><span class="name">BEx</span>.<span class="name">intro</span></a></div><div class="nav_link"><a class="break_within" href="#bex_eq_left"><span class="name">bex_eq_left</span></a></div><div class="nav_link"><a class="break_within" href="#ball_congr"><span class="name">ball_congr</span></a></div><div class="nav_link"><a class="break_within" href="#bex_congr"><span class="name">bex_congr</span></a></div><div class="nav_link"><a class="break_within" href="#BAll.imp_right"><span class="name">BAll</span>.<span class="name">imp_right</span></a></div><div class="nav_link"><a class="break_within" href="#BEx.imp_right"><span class="name">BEx</span>.<span class="name">imp_right</span></a></div><div class="nav_link"><a class="break_within" href="#BAll.imp_left"><span class="name">BAll</span>.<span class="name">imp_left</span></a></div><div class="nav_link"><a class="break_within" href="#BEx.imp_left"><span class="name">BEx</span>.<span class="name">imp_left</span></a></div><div class="nav_link"><a class="break_within" href="#ball_of_forall"><span class="name">ball_of_forall</span></a></div><div class="nav_link"><a class="break_within" href="#forall_of_ball"><span class="name">forall_of_ball</span></a></div><div class="nav_link"><a class="break_within" href="#exists_mem_of_exists"><span class="name">exists_mem_of_exists</span></a></div><div class="nav_link"><a class="break_within" href="#exists_of_exists_mem"><span class="name">exists_of_exists_mem</span></a></div><div class="nav_link"><a class="break_within" href="#bex_of_exists"><span class="name">bex_of_exists</span></a></div><div class="nav_link"><a class="break_within" href="#exists_of_bex"><span class="name">exists_of_bex</span></a></div><div class="nav_link"><a class="break_within" href="#bex_imp"><span class="name">bex_imp</span></a></div><div class="nav_link"><a class="break_within" href="#not_exists_mem"><span class="name">not_exists_mem</span></a></div><div class="nav_link"><a class="break_within" href="#not_forall₂_of_exists₂_not"><span class="name">not_forall₂_of_exists₂_not</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.not_forall₂"><span class="name">Decidable</span>.<span class="name">not_forall₂</span></a></div><div class="nav_link"><a class="break_within" href="#not_forall₂"><span class="name">not_forall₂</span></a></div><div class="nav_link"><a class="break_within" href="#forall₂_and"><span class="name">forall₂_and</span></a></div><div class="nav_link"><a class="break_within" href="#forall_and_left"><span class="name">forall_and_left</span></a></div><div class="nav_link"><a class="break_within" href="#forall_and_right"><span class="name">forall_and_right</span></a></div><div class="nav_link"><a class="break_within" href="#exists_mem_or"><span class="name">exists_mem_or</span></a></div><div class="nav_link"><a class="break_within" href="#forall₂_or_left"><span class="name">forall₂_or_left</span></a></div><div class="nav_link"><a class="break_within" href="#exists_mem_or_left"><span class="name">exists_mem_or_left</span></a></div><div class="nav_link"><a class="break_within" href="#dite_eq_iff"><span class="name">dite_eq_iff</span></a></div><div class="nav_link"><a class="break_within" href="#ite_eq_iff"><span class="name">ite_eq_iff</span></a></div><div class="nav_link"><a class="break_within" href="#eq_ite_iff"><span class="name">eq_ite_iff</span></a></div><div class="nav_link"><a class="break_within" href="#dite_eq_iff'"><span class="name">dite_eq_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#ite_eq_iff'"><span class="name">ite_eq_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#dite_ne_left_iff"><span class="name">dite_ne_left_iff</span></a></div><div class="nav_link"><a class="break_within" href="#dite_ne_right_iff"><span class="name">dite_ne_right_iff</span></a></div><div class="nav_link"><a class="break_within" href="#ite_ne_left_iff"><span class="name">ite_ne_left_iff</span></a></div><div class="nav_link"><a class="break_within" href="#ite_ne_right_iff"><span class="name">ite_ne_right_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.dite_eq_left_iff"><span class="name">Ne</span>.<span class="name">dite_eq_left_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.dite_eq_right_iff"><span class="name">Ne</span>.<span class="name">dite_eq_right_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.ite_eq_left_iff"><span class="name">Ne</span>.<span class="name">ite_eq_left_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.ite_eq_right_iff"><span class="name">Ne</span>.<span class="name">ite_eq_right_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.dite_ne_left_iff"><span class="name">Ne</span>.<span class="name">dite_ne_left_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.dite_ne_right_iff"><span class="name">Ne</span>.<span class="name">dite_ne_right_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.ite_ne_left_iff"><span class="name">Ne</span>.<span class="name">ite_ne_left_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.ite_ne_right_iff"><span class="name">Ne</span>.<span class="name">ite_ne_right_iff</span></a></div><div class="nav_link"><a class="break_within" href="#dite_eq_or_eq"><span class="name">dite_eq_or_eq</span></a></div><div class="nav_link"><a class="break_within" href="#ite_eq_or_eq"><span class="name">ite_eq_or_eq</span></a></div><div class="nav_link"><a class="break_within" href="#apply_dite₂"><span class="name">apply_dite₂</span></a></div><div class="nav_link"><a class="break_within" href="#apply_ite₂"><span class="name">apply_ite₂</span></a></div><div class="nav_link"><a class="break_within" href="#dite_apply"><span class="name">dite_apply</span></a></div><div class="nav_link"><a class="break_within" href="#ite_apply"><span class="name">ite_apply</span></a></div><div class="nav_link"><a class="break_within" href="#ite_and"><span class="name">ite_and</span></a></div><div class="nav_link"><a class="break_within" href="#ite_or"><span class="name">ite_or</span></a></div><div class="nav_link"><a class="break_within" href="#dite_dite_comm"><span class="name">dite_dite_comm</span></a></div><div class="nav_link"><a class="break_within" href="#ite_ite_comm"><span class="name">ite_ite_comm</span></a></div><div class="nav_link"><a class="break_within" href="#ite_prop_iff_or"><span class="name">ite_prop_iff_or</span></a></div><div class="nav_link"><a class="break_within" href="#dite_prop_iff_or"><span class="name">dite_prop_iff_or</span></a></div><div class="nav_link"><a class="break_within" href="#ite_prop_iff_and"><span class="name">ite_prop_iff_and</span></a></div><div class="nav_link"><a class="break_within" href="#dite_prop_iff_and"><span class="name">dite_prop_iff_and</span></a></div><div class="nav_link"><a class="break_within" href="#if_ctx_congr"><span class="name">if_ctx_congr</span></a></div><div class="nav_link"><a class="break_within" href="#if_congr"><span class="name">if_congr</span></a></div><div class="nav_link"><a class="break_within" href="#not_beq_of_ne"><span class="name">not_beq_of_ne</span></a></div><div class="nav_link"><a class="break_within" href="#beq_eq_decide"><span class="name">beq_eq_decide</span></a></div><div class="nav_link"><a class="break_within" href="#beq_eq_beq"><span class="name">beq_eq_beq</span></a></div><div class="nav_link"><a class="break_within" href="#beq_ext"><span class="name">beq_ext</span></a></div><div class="nav_link"><a class="break_within" href="#lawful_beq_subsingleton"><span class="name">lawful_beq_subsingleton</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Basic-logic-properties">Basic logic properties <a class="hover-link" href="#Basic-logic-properties">#</a></h1><p>This file is one of the earliest imports in mathlib.</p><h2 class="markdown-heading" id="Implementation-notes">Implementation notes <a class="hover-link" href="#Implementation-notes">#</a></h2><p>Theorems that require decidability hypotheses are in the namespace <code><a href="../.././Init/Prelude.html#Decidable">Decidable</a></code>.
Classical versions are in the namespace <code>Classical</code>.</p></div><div class="decl" id="hidden"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L43-L46">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#hidden"><span class="name">hidden</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>An identity function with its main argument implicit. This will be printed as <code><a href="../.././Mathlib/Logic/Basic.html#hidden">hidden</a></code> even
if it is applied to a large term, so it can be used for elision,
as done in the <code>elide</code> and <code>unelide</code> tactics.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">hidden</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></li></ul></details><details id="instances-for-list-hidden" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="decidableEq_of_subsingleton"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L50-L51">source</a></div><div class="attributes">@[instance 10]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#decidableEq_of_subsingleton"><span class="name">decidableEq_of_subsingleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#decidableEq_of_subsingleton">decidableEq_of_subsingleton</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span></span></li></ul></details></div></div><div class="decl" id="instSubsingletonSubtype_mathlib"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L53-L54">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#instSubsingletonSubtype_mathlib"><span class="name">instSubsingletonSubtype_mathlib</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">(<a href="../.././Init/Prelude.html#Subtype">Subtype</a> <span class="fn">p</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="congr_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L56-L58">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#congr_heq"><span class="name">congr_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">x</span> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span> <span class="fn">y</span></span></span></div></div></div></div><div class="decl" id="congr_arg_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L60-L62">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#congr_arg_heq"><span class="name">congr_arg_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a₁ a₂ : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a₁</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a₂</span></span> → <span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">(<span class="fn">f</span> <span class="fn">a₁</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a₂</span>)</span></span></span></div></div></div></div><div class="decl" id="eq_iff_eq_cancel_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L64-L65">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_iff_eq_cancel_left"><span class="name">eq_iff_eq_cancel_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ {<span class="fn">a</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></div></div></div></div><div class="decl" id="eq_iff_eq_cancel_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L67-L68">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_iff_eq_cancel_right"><span class="name">eq_iff_eq_cancel_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ {<span class="fn">c</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="ne_and_eq_iff_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L70-L71">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ne_and_eq_iff_right"><span class="name">ne_and_eq_iff_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">b</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></div></div></div></div><div class="decl" id="Fact"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L73-L93">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Fact"><span class="name">Fact</span></a></span><span class="decl_args">
<span class="fn">(p : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Prop</a></div></div><p>Wrapper for adding elementary propositions to the type class systems.
Warning: this can easily be abused. See the rest of this docstring for details.</p><p>Certain propositions should not be treated as a class globally,
but sometimes it is very convenient to be able to use the type class system
in specific circumstances.</p><p>For example, <code>ZMod p</code> is a field if and only if <code>p</code> is a prime number.
In order to be able to find this field instance automatically by type class search,
we have to turn <code>p.prime</code> into an instance implicit assumption.</p><p>On the other hand, making <code>Nat.prime</code> a class would require a major refactoring of the library,
and it is questionable whether making <code>Nat.prime</code> a class is desirable at all.
The compromise is to add the assumption <code>[Fact p.prime]</code> to <code>ZMod.field</code>.</p><p>In particular, this class is not intended for turning the type class system
into an automated theorem prover for first order logic.</p><ul class="structure_fields" id="Fact.mk"><li id="Fact.out" class="structure_field"><div class="structure_field_info">out : <span class="fn">p</span></div><div class="structure_field_doc"><p><code><a href="../.././Mathlib/Logic/Basic.html#Fact.out">Fact.out</a></code> contains the unwrapped witness for the fact represented by the instance of
<code><a href="../.././Mathlib/Logic/Basic.html#Fact">Fact</a> p</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Fact" class="instances-list"></ul></details></div></div><div class="decl" id="Fact.elim"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L101-L101">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Fact.elim"><span class="name">Fact</span>.<span class="name">elim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn">p</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span></div></div></div></div><div class="decl" id="fact_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L102-L102">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#fact_iff"><span class="name">fact_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn">p</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">p</span></span></div></div></div></div><div class="decl" id="instDecidableFact"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L104-L105">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#instDecidableFact"><span class="name">instDecidableFact</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<a href="../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn">p</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instDecidableFact</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/PropLemmas.html#decidable_of_iff">decidable_of_iff</a> <span class="fn">p</span> <span class="fn">⋯</span></span></span></li></ul></details></div></div><div class="decl" id="Function.swap₂"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L107-L110">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Function.swap₂"><span class="name">Function</span>.<span class="name">swap₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι₁ : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι₂ : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{κ₁ : <span class="fn"><span class="fn">ι₁</span> → <a href="../.././foundational_types.html">Sort</a> u_4</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{κ₂ : <span class="fn"><span class="fn">ι₂</span> → <a href="../.././foundational_types.html">Sort</a> u_5</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{φ : <span class="fn">(<span class="fn">i₁</span> : <span class="fn">ι₁</span>) → <span class="fn"><span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span> → <span class="fn">(<span class="fn">i₂</span> : <span class="fn">ι₂</span>) → <span class="fn"><span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span> → <a href="../.././foundational_types.html">Sort</a> u_6</span></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">i₁</span> : <span class="fn">ι₁</span>) → <span class="fn">(<span class="fn">j₁</span> : <span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span>) → <span class="fn">(<span class="fn">i₂</span> : <span class="fn">ι₂</span>) → <span class="fn">(<span class="fn">j₂</span> : <span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span>) → <span class="fn"><span class="fn">φ</span> <span class="fn">i₁</span> <span class="fn">j₁</span> <span class="fn">i₂</span> <span class="fn">j₂</span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i₂ : <span class="fn">ι₂</span>)</span></span>
<span class="decl_args">
<span class="fn">(j₂ : <span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i₁ : <span class="fn">ι₁</span>)</span></span>
<span class="decl_args">
<span class="fn">(j₁ : <span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">φ</span> <span class="fn">i₁</span> <span class="fn">j₁</span> <span class="fn">i₂</span> <span class="fn">j₂</span></span></div></div><p>Swaps two pairs of arguments to a function.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Function.swap₂">Function.swap₂</a> <span class="fn">f</span> <span class="fn">i₂</span> <span class="fn">j₂</span> <span class="fn">i₁</span> <span class="fn">j₁</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">i₁</span> <span class="fn">j₁</span> <span class="fn">i₂</span> <span class="fn">j₂</span></span></span></li></ul></details><details id="instances-for-list-Function.swap₂" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-propositional-connectives">Declarations about propositional connectives <a class="hover-link" href="#Declarations-about-propositional-connectives">#</a></h3></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-implies">Declarations about <code>implies</code> <a class="hover-link" href="#Declarations-about-implies">#</a></h3></div><div class="decl" id="Iff.imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L135-L135">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.imp"><span class="name">Iff</span>.<span class="name">imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b c d : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">d</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">c</span> → <span class="fn">d</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Core.html#imp_congr">imp_congr</a></code>.</p></div></div><div class="decl" id="imp_iff_right_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L138-L138">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_iff_right_iff"><span class="name">imp_iff_right_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="and_or_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L141-L141">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#and_or_imp"><span class="name">and_or_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">(<span class="fn">a</span> → <span class="fn">c</span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> → <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></span></span></span></div></div></div></div><div class="decl" id="Function.mt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L143-L144">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Function.mt"><span class="name">Function</span>.<span class="name">mt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> → <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span> → <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span></span></span></div></div><p>Provide modus tollens (<code><a href="../.././Init/Core.html#mt">mt</a></code>) as dot notation for implications.</p></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-not">Declarations about <code><a href="../.././Mathlib/Logic/Basic.html#Iff.not">not</a></code> <a class="hover-link" href="#Declarations-about-not">#</a></h3></div><div class="decl" id="dec_em"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L148-L148">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dec_em"><span class="name">dec_em</span></a></span><span class="decl_args">
<span class="fn">(p : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Core.html#Decidable.em">Decidable.em</a></code>.</p></div></div><div class="decl" id="dec_em'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L150-L150">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dec_em'"><span class="name">dec_em'</span></a></span><span class="decl_args">
<span class="fn">(p : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">p</span></span></div></div></div></div><div class="decl" id="em"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L152-L152">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#em"><span class="name">em</span></a></span><span class="decl_args">
<span class="fn">(p : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Classical.html#Classical.em">Classical.em</a></code>.</p><hr></hr><p><strong>Diaconescu's theorem</strong>: excluded middle from choice, Function extensionality and propositional extensionality.</p></div></div><div class="decl" id="em'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L154-L154">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#em'"><span class="name">em'</span></a></span><span class="decl_args">
<span class="fn">(p : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">p</span></span></div></div></div></div><div class="decl" id="or_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L156-L156">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#or_not"><span class="name">or_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span></span></div></div></div></div><div class="decl" id="Decidable.eq_or_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L158-L159">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Decidable.eq_or_ne"><span class="name">Decidable</span>.<span class="name">eq_or_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(x y : <span class="fn">α</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span></span></span></div></div></div></div><div class="decl" id="Decidable.ne_or_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L161-L162">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Decidable.ne_or_eq"><span class="name">Decidable</span>.<span class="name">ne_or_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(x y : <span class="fn">α</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span></div></div></div></div><div class="decl" id="eq_or_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L164-L164">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_or_ne"><span class="name">eq_or_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(x y : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span></span></span></div></div></div></div><div class="decl" id="ne_or_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L166-L166">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ne_or_eq"><span class="name">ne_or_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(x y : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span></div></div></div></div><div class="decl" id="by_contradiction"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L168-L168">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#by_contradiction"><span class="name">by_contradiction</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> → <a href="../.././Init/Prelude.html#False">False</a>)</span> → <span class="fn">p</span></span></div></div></div></div><div class="decl" id="by_cases"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L170-L171">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#by_cases"><span class="name">by_cases</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p q : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(hpq : <span class="fn"><span class="fn">p</span> → <span class="fn">q</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hnpq : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> → <span class="fn">q</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">q</span></div></div></div></div><div class="decl" id="by_contra"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L173-L173">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#by_contra"><span class="name">by_contra</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> → <a href="../.././Init/Prelude.html#False">False</a>)</span> → <span class="fn">p</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Logic/Basic.html#by_contradiction">by_contradiction</a></code>.</p></div></div><div class="decl" id="of_not_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L200-L200">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#of_not_not"><span class="name">of_not_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span></span> → <span class="fn">a</span></span></div></div></div></div><div class="decl" id="not_ne_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L202-L202">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_ne_iff"><span class="name">not_ne_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="of_not_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L204-L204">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#of_not_imp"><span class="name">of_not_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span></span> → <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Not.decidable_imp_symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L206-L206">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Not.decidable_imp_symm"><span class="name">Not</span>.<span class="name">decidable_imp_symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">a</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> → <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hb : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/PropLemmas.html#Decidable.not_imp_symm">Decidable.not_imp_symm</a></code>.</p></div></div><div class="decl" id="Not.imp_symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L208-L208">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Not.imp_symm"><span class="name">Not</span>.<span class="name">imp_symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> → <span class="fn">b</span>)</span> → <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span> → <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="not_imp_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L210-L210">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_imp_comm"><span class="name">not_imp_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> → <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span> → <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="not_imp_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L212-L212">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_imp_self"><span class="name">not_imp_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> → <span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Imp.swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L214-L215">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Imp.swap"><span class="name">Imp</span>.<span class="name">swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> → <span class="fn"><span class="fn">b</span> → <span class="fn">c</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">b</span> → <span class="fn"><span class="fn">a</span> → <span class="fn">c</span></span></span></span></div></div></div></div><div class="decl" id="Iff.not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L217-L217">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.not"><span class="name">Iff</span>.<span class="name">not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Core.html#not_congr">not_congr</a></code>.</p></div></div><div class="decl" id="Iff.not_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L219-L219">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.not_left"><span class="name">Iff</span>.<span class="name">not_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Iff.not_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L221-L221">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.not_right"><span class="name">Iff</span>.<span class="name">not_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Iff.ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L223-L224">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.ne"><span class="name">Iff</span>.<span class="name">ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c d : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">c</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span>)</span> → <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">c</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">d</span></span>)</span></span></div></div></div></div><div class="decl" id="Iff.ne_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L226-L227">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.ne_left"><span class="name">Iff</span>.<span class="name">ne_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c d : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">c</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">d</span></span>)</span> → <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">c</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span>)</span></span></div></div></div></div><div class="decl" id="Iff.ne_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L229-L230">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.ne_right"><span class="name">Iff</span>.<span class="name">ne_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c d : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">c</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span>)</span> → <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">c</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">d</span></span>)</span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-Xor">Declarations about <code><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a></code> <a class="hover-link" href="#Declarations-about-Xor">#</a></h3></div><div class="decl" id="Xor'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L234-L235">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Xor'"><span class="name">Xor'</span></a></span><span class="decl_args">
<span class="fn">(a b : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Prop</a></div></div><p><code><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> a b</code> is the exclusive-or of propositions.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span></span>)</span></span></li></ul></details><details id="instances-for-list-Xor'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instDecidableXor'"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L237-L237">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#instDecidableXor'"><span class="name">instDecidableXor'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">a</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">b</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">b</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instDecidableXor'</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#inferInstanceAs">inferInstanceAs</a> <span class="fn">(<a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span></span>)</span>)</span></span></span></li></ul></details></div></div><div class="decl" id="xor_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L239-L240">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_true"><span class="name">xor_true</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <a href="../.././Init/Prelude.html#True">True</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Not">Not</a></span></div></div></div></div><div class="decl" id="xor_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L242-L242">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_false"><span class="name">xor_false</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <a href="../.././Init/Prelude.html#False">False</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">id</span></span></div></div></div></div><div class="decl" id="xor_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L244-L244">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_comm"><span class="name">xor_comm</span></a></span><span class="decl_args">
<span class="fn">(a b : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">b</span> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="instCommutativeXor'"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L246-L246">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#instCommutativeXor'"><span class="name">instCommutativeXor'</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Std.Commutative">Std.Commutative</a> <a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#instCommutativeXor'">instCommutativeXor'</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="xor_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L248-L248">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_self"><span class="name">xor_self</span></a></span><span class="decl_args">
<span class="fn">(a : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#False">False</a></span></div></div></div></div><div class="decl" id="xor_not_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L250-L250">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_not_left"><span class="name">xor_not_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span>)</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span></span></div></div></div></div><div class="decl" id="xor_not_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L252-L252">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_not_right"><span class="name">xor_not_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span></span></div></div></div></div><div class="decl" id="xor_not_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L254-L254">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_not_not"><span class="name">xor_not_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span>)</span> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Xor'.or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L256-L256">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Xor'.or"><span class="name">Xor'</span>.<span class="name">or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-and">Declarations about <code><a href="../.././Mathlib/Logic/Basic.html#Iff.and">and</a></code> <a class="hover-link" href="#Declarations-about-and">#</a></h3></div><div class="decl" id="Iff.and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L260-L260">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.and"><span class="name">Iff</span>.<span class="name">and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a c b d : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">d</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">c</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">d</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/PropLemmas.html#and_congr">and_congr</a></code>.</p></div></div><div class="decl" id="And.rotate"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L261-L261">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#And.rotate"><span class="name">And</span>.<span class="name">rotate</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">c</span></span></span> → <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">c</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">a</span></span></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../.././Init/PropLemmas.html#and_rotate">and_rotate</a></code>.</p></div></div><div class="decl" id="and_symm_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L263-L263">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#and_symm_right"><span class="name">and_symm_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(a b : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></span></span></div></div></div></div><div class="decl" id="and_symm_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L264-L264">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#and_symm_left"><span class="name">and_symm_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(a b : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">p</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">p</span></span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-or">Declarations about <code><a href="../.././Mathlib/Logic/Basic.html#Xor'.or">or</a></code> <a class="hover-link" href="#Declarations-about-or">#</a></h3></div><div class="decl" id="Iff.or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L268-L268">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.or"><span class="name">Iff</span>.<span class="name">or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a c b d : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">d</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">c</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">d</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/PropLemmas.html#or_congr">or_congr</a></code>.</p></div></div><div class="decl" id="Or.rotate"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L269-L269">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Or.rotate"><span class="name">Or</span>.<span class="name">rotate</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></span></span> → <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">c</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">a</span></span></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../.././Init/PropLemmas.html#or_rotate">or_rotate</a></code>.</p></div></div><div class="decl" id="Or.elim3"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L271-L272">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Or.elim3"><span class="name">Or</span>.<span class="name">elim3</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b c d : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ha : <span class="fn"><span class="fn">a</span> → <span class="fn">d</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hb : <span class="fn"><span class="fn">b</span> → <span class="fn">d</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hc : <span class="fn"><span class="fn">c</span> → <span class="fn">d</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">d</span></div></div></div></div><div class="decl" id="Or.imp3"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L274-L276">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Or.imp3"><span class="name">Or</span>.<span class="name">imp3</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b d e c f : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(had : <span class="fn"><span class="fn">a</span> → <span class="fn">d</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hbe : <span class="fn"><span class="fn">b</span> → <span class="fn">e</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hcf : <span class="fn"><span class="fn">c</span> → <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></span></span> → <span class="fn"><span class="fn">d</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">e</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">f</span></span></span></span></div></div></div></div><div class="decl" id="not_or_of_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L280-L280">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_or_of_imp"><span class="name">not_or_of_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> → <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Decidable.or_not_of_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L283-L284">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Decidable.or_not_of_imp"><span class="name">Decidable</span>.<span class="name">or_not_of_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">a</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="or_not_of_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L286-L286">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#or_not_of_imp"><span class="name">or_not_of_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> → <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span></span></span></div></div></div></div><div class="decl" id="imp_iff_not_or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L288-L288">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_iff_not_or"><span class="name">imp_iff_not_or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="imp_iff_or_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L290-L290">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_iff_or_not"><span class="name">imp_iff_or_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">b</span> → <span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="not_imp_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L292-L292">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_imp_not"><span class="name">not_imp_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> → <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">b</span> → <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="imp_and_neg_imp_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L294-L294">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_and_neg_imp_iff"><span class="name">imp_and_neg_imp_iff</span></a></span><span class="decl_args">
<span class="fn">(p q : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn">p</span> → <span class="fn">q</span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> → <span class="fn">q</span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">q</span></span></div></div></div></div><div class="decl" id="Function.mtr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L296-L297">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Function.mtr"><span class="name">Function</span>.<span class="name">mtr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> → <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span>)</span> → <span class="fn"><span class="fn">b</span> → <span class="fn">a</span></span></span></div></div><p>Provide the reverse of modus tollens (<code><a href="../.././Init/Core.html#mt">mt</a></code>) as dot notation for implications.</p></div></div><div class="decl" id="or_congr_left'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L299-L300">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#or_congr_left'"><span class="name">or_congr_left'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c a b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">c</span></span> → <span class="fn">(<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></span></span></div></div></div></div><div class="decl" id="or_congr_right'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L302-L302">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#or_congr_right'"><span class="name">or_congr_right'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> → <span class="fn">(<span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">c</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-distributivity">Declarations about distributivity <a class="hover-link" href="#Declarations-about-distributivity">#</a></h3></div><div class="mod_doc"><p>Declarations about <code><a href="../.././Mathlib/Logic/Basic.html#Iff.iff">iff</a></code></p></div><div class="decl" id="Iff.iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L308-L308">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.iff"><span class="name">Iff</span>.<span class="name">iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p₁ p₂ q₁ q₂ : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">p₁</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">p₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">q₁</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">q₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">p₁</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">q₁</span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn">p₂</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">q₂</span>)</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/SimpLemmas.html#iff_congr">iff_congr</a></code>.</p></div></div><div class="decl" id="iff_mpr_iff_true_intro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L311-L311">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#iff_mpr_iff_true_intro"><span class="name">iff_mpr_iff_true_intro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">P</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="imp_or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L313-L313">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_or"><span class="name">imp_or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> → <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">(<span class="fn">a</span> → <span class="fn">c</span>)</span></span></span></div></div></div></div><div class="decl" id="imp_or'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L315-L315">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_or'"><span class="name">imp_or'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> → <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">(<span class="fn">a</span> → <span class="fn">c</span>)</span></span></span></div></div></div></div><div class="decl" id="not_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L317-L317">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_imp"><span class="name">not_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="peirce"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L319-L319">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#peirce"><span class="name">peirce</span></a></span><span class="decl_args">
<span class="fn">(a b : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> → <span class="fn">a</span>)</span> → <span class="fn">a</span></span></div></div></div></div><div class="decl" id="not_iff_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L321-L321">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_iff_not"><span class="name">not_iff_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span></span></div></div></div></div><div class="decl" id="not_iff_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L323-L323">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_iff_comm"><span class="name">not_iff_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span>)</span></span></div></div></div></div><div class="decl" id="not_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L325-L325">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_iff"><span class="name">not_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span></span></div></div></div></div><div class="decl" id="iff_not_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L327-L327">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#iff_not_comm"><span class="name">iff_not_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span>)</span></span></div></div></div></div><div class="decl" id="iff_iff_and_or_not_and_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L329-L330">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#iff_iff_and_or_not_and_not"><span class="name">iff_iff_and_or_not_and_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span></span></span></div></div></div></div><div class="decl" id="iff_iff_not_or_and_or_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L332-L333">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#iff_iff_not_or_and_or_not"><span class="name">iff_iff_not_or_and_or_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">(<span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span>)</span></span></span></div></div></div></div><div class="decl" id="not_and_not_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L335-L335">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_and_not_right"><span class="name">not_and_not_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="De-Morgan-s-laws">De Morgan's laws <a class="hover-link" href="#De-Morgan-s-laws">#</a></h3></div><div class="decl" id="not_and_or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L339-L341">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_and_or"><span class="name">not_and_or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span></span></div></div><p>One of <strong>de Morgan's laws</strong>: the negation of a conjunction is logically equivalent to the
disjunction of the negations.</p></div></div><div class="decl" id="or_iff_not_and_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L343-L343">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#or_iff_not_and_not"><span class="name">or_iff_not_and_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span>)</span></span></span></div></div></div></div><div class="decl" id="and_iff_not_or_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L345-L345">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#and_iff_not_or_not"><span class="name">and_iff_not_or_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span>)</span></span></span></div></div></div></div><div class="decl" id="not_xor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L347-L348">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_xor"><span class="name">not_xor</span></a></span><span class="decl_args">
<span class="fn">(P Q : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">P</span> <span class="fn">Q</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn">P</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">Q</span>)</span></span></div></div></div></div><div class="decl" id="xor_iff_not_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L350-L350">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_iff_not_iff"><span class="name">xor_iff_not_iff</span></a></span><span class="decl_args">
<span class="fn">(P Q : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">P</span> <span class="fn">Q</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn">P</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">Q</span>)</span></span></span></div></div></div></div><div class="decl" id="xor_iff_iff_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L352-L352">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_iff_iff_not"><span class="name">xor_iff_iff_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span>)</span></span></div></div></div></div><div class="decl" id="xor_iff_not_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L354-L354">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_iff_not_iff'"><span class="name">xor_iff_not_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-equality">Declarations about equality <a class="hover-link" href="#Declarations-about-equality">#</a></h3></div><div class="decl" id="Membership.mem.ne_of_not_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L360-L360">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Membership.mem.ne_of_not_mem"><span class="name">Membership</span>.<span class="name">mem</span>.<span class="name">ne_of_not_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span></span> → <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/PropLemmas.html#ne_of_mem_of_not_mem">ne_of_mem_of_not_mem</a></code>.</p></div></div><div class="decl" id="Membership.mem.ne_of_not_mem'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L361-L361">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Membership.mem.ne_of_not_mem'"><span class="name">Membership</span>.<span class="name">mem</span>.<span class="name">ne_of_not_mem'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s t : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span></span> → <span class="fn"><span class="fn">s</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">t</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/PropLemmas.html#ne_of_mem_of_not_mem'">ne_of_mem_of_not_mem'</a></code>.</p></div></div><div class="decl" id="forall_cond_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L366-L368">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_cond_comm"><span class="name">forall_cond_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">s</span> <span class="fn">a</span></span> → <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">s</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">s</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn"><span class="fn">s</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></span></span></div></div></div></div><div class="decl" id="forall_mem_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L370-L372">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_mem_comm"><span class="name">forall_mem_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span> → <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span> → <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></span></span></div></div></div></div><div class="decl" id="ball_cond_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L374-L374">source</a></div><div class="attributes">@[deprecated forall_cond_comm]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ball_cond_comm"><span class="name">ball_cond_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">s</span> <span class="fn">a</span></span> → <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">s</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">s</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn"><span class="fn">s</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Logic/Basic.html#forall_cond_comm">forall_cond_comm</a></code>.</p></div></div><div class="decl" id="ball_mem_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L375-L375">source</a></div><div class="attributes">@[deprecated forall_mem_comm]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ball_mem_comm"><span class="name">ball_mem_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span> → <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span> → <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Logic/Basic.html#forall_mem_comm">forall_mem_comm</a></code>.</p></div></div><div class="decl" id="ne_of_eq_of_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L377-L377">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ne_of_eq_of_ne"><span class="name">ne_of_eq_of_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">b</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="ne_of_ne_of_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L378-L378">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ne_of_ne_of_eq"><span class="name">ne_of_ne_of_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Eq.trans_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L380-L380">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Eq.trans_ne"><span class="name">Eq</span>.<span class="name">trans_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">b</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">c</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Logic/Basic.html#ne_of_eq_of_ne">ne_of_eq_of_ne</a></code>.</p></div></div><div class="decl" id="Ne.trans_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L381-L381">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.trans_eq"><span class="name">Ne</span>.<span class="name">trans_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">c</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Logic/Basic.html#ne_of_ne_of_eq">ne_of_ne_of_eq</a></code>.</p></div></div><div class="decl" id="eq_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L383-L384">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_equivalence"><span class="name">eq_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">Eq</span></span></div></div></div></div><div class="decl" id="congr_refl_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L390-L391">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#congr_refl_left"><span class="name">congr_refl_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="congr_refl_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L394-L395">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#congr_refl_right"><span class="name">congr_refl_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f g : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">f</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="congr_arg_refl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L398-L400">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#congr_arg_refl"><span class="name">congr_arg_refl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="congr_fun_rfl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L403-L404">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#congr_fun_rfl"><span class="name">congr_fun_rfl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="congr_fun_congr_arg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L407-L408">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#congr_fun_congr_arg"><span class="name">congr_fun_congr_arg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a a' : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Eq.rec_eq_cast"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L410-L411">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Eq.rec_eq_cast"><span class="name">Eq</span>.<span class="name">rec_eq_cast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x y : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(z : <span class="fn"><span class="fn">P</span> <span class="fn">x</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">h</span> ▸ <span class="fn">z</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">z</span></span></span></div></div></div></div><div class="decl" id="eqRec_heq'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L413-L416">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eqRec_heq'"><span class="name">eqRec_heq'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a' : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">a'</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Sort</a> u_2</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">motive</span> <span class="fn">a'</span> <span class="fn">⋯</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(t : <span class="fn"><span class="fn">a'</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">(<span class="fn">t</span> ▸ <span class="fn">p</span>)</span> <span class="fn">p</span></span></div></div></div></div><div class="decl" id="rec_heq_of_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L418-L419">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#rec_heq_of_heq"><span class="name">rec_heq_of_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn"><span class="fn">C</span> <span class="fn">a</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">x</span> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">(<span class="fn">e</span> ▸ <span class="fn">x</span>)</span> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="rec_heq_iff_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L421-L422">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#rec_heq_iff_heq"><span class="name">rec_heq_iff_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn"><span class="fn">C</span> <span class="fn">a</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">(<span class="fn">e</span> ▸ <span class="fn">x</span>)</span> <span class="fn">y</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">x</span> <span class="fn">y</span></span></span></div></div></div></div><div class="decl" id="heq_rec_iff_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L424-L425">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#heq_rec_iff_heq"><span class="name">heq_rec_iff_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn"><span class="fn">C</span> <span class="fn">a</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">x</span> <span class="fn">(<span class="fn">e</span> ▸ <span class="fn">y</span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">x</span> <span class="fn">y</span></span></span></div></div></div></div><div class="decl" id="heq_of_eq_cast"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L430-L430">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#heq_of_eq_cast"><span class="name">heq_of_eq_cast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α β : <a href="../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">β</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#cast">cast</a> <span class="fn">e</span> <span class="fn">b</span></span></span> → <span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="eq_cast_iff_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L432-L432">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_cast_iff_heq"><span class="name">eq_cast_iff_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α β : <a href="../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <span class="fn"><span class="fn">β</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#cast">cast</a> <span class="fn">e</span> <span class="fn">b</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-quantifiers">Declarations about quantifiers <a class="hover-link" href="#Declarations-about-quantifiers">#</a></h3></div><div class="decl" id="forall₂_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L445-L447">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall₂_imp"><span class="name">forall₂_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p q : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span> → <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="forall₃_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L449-L451">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall₃_imp"><span class="name">forall₃_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Sort</a> u_3</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p q : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn">(<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) → <span class="fn"><span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) (<span class="fn">c</span> : <span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) (<span class="fn">c</span> : <span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span> → <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) (<span class="fn">c</span> : <span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span></div></div></div></div><div class="decl" id="Exists₂.imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L453-L455">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Exists₂.imp"><span class="name">Exists₂</span>.<span class="name">imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p q : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span>)</span> → <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></span></div></div></div></div><div class="decl" id="Exists₃.imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L457-L459">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Exists₃.imp"><span class="name">Exists₃</span>.<span class="name">imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Sort</a> u_3</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p q : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn">(<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) → <span class="fn"><span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) (<span class="fn">c</span> : <span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn">∃ (<span class="fn">c</span> : <span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span>)</span> → <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn">∃ (<span class="fn">c</span> : <span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span></span></span></div></div></div></div><div class="decl" id="forall_swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L465-L466">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_swap"><span class="name">forall_swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">y</span> : <span class="fn">β</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span> <span class="fn">y</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">y</span> : <span class="fn">β</span>) (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span> <span class="fn">y</span></span></span></span></div></div></div></div><div class="decl" id="forall₂_swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L468-L470">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall₂_swap"><span class="name">forall₂_swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι₁ : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι₂ : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{κ₁ : <span class="fn"><span class="fn">ι₁</span> → <a href="../.././foundational_types.html">Sort</a> u_5</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{κ₂ : <span class="fn"><span class="fn">ι₂</span> → <a href="../.././foundational_types.html">Sort</a> u_6</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn">(<span class="fn">i₁</span> : <span class="fn">ι₁</span>) → <span class="fn"><span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span> → <span class="fn">(<span class="fn">i₂</span> : <span class="fn">ι₂</span>) → <span class="fn"><span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">i₁</span> : <span class="fn">ι₁</span>) (<span class="fn">j₁</span> : <span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span>) (<span class="fn">i₂</span> : <span class="fn">ι₂</span>) (<span class="fn">j₂</span> : <span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">i₁</span> <span class="fn">j₁</span> <span class="fn">i₂</span> <span class="fn">j₂</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">i₂</span> : <span class="fn">ι₂</span>) (<span class="fn">j₂</span> : <span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span>) (<span class="fn">i₁</span> : <span class="fn">ι₁</span>) (<span class="fn">j₁</span> : <span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">i₁</span> <span class="fn">j₁</span> <span class="fn">i₂</span> <span class="fn">j₂</span></span></span></span></div></div></div></div><div class="decl" id="imp_forall_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L472-L475">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_forall_iff"><span class="name">imp_forall_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">p</span> → <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> → <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></span></span></div></div><p>We intentionally restrict the type of <code>α</code> in this lemma so that this is a safer to use in simp
than <code><a href="../.././Mathlib/Logic/Basic.html#forall_swap">forall_swap</a></code>.</p></div></div><div class="decl" id="imp_forall_iff_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L477-L478">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_forall_iff_forall"><span class="name">imp_forall_iff_forall</span></a></span><span class="decl_args">
<span class="fn">(A : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args">
<span class="fn">(B : <span class="fn"><span class="fn">A</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">A</span> → <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">A</span>), <span class="fn"><span class="fn">B</span> <span class="fn">h</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">A</span>), <span class="fn"><span class="fn">B</span> <span class="fn">h</span></span></span></span></div></div></div></div><div class="decl" id="exists_swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L480-L481">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_swap"><span class="name">exists_swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">y</span> : <span class="fn">β</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span> <span class="fn">y</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">y</span> : <span class="fn">β</span>), <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span> <span class="fn">y</span></span></span></span></span></div></div></div></div><div class="decl" id="exists_and_exists_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L483-L485">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_and_exists_comm"><span class="name">exists_and_exists_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Q : <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">(∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">P</span> <span class="fn">a</span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∃ (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn">Q</span> <span class="fn">b</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">Q</span> <span class="fn">b</span></span></span></span></span></span></div></div></div></div><div class="decl" id="not_forall_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L489-L489">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_forall_not"><span class="name">not_forall_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></span></div></div></div></div><div class="decl" id="forall_or_exists_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L493-L494">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_or_exists_not"><span class="name">forall_or_exists_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(P : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">P</span> <span class="fn">a</span></span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">P</span> <span class="fn">a</span></span></span></span></span></div></div></div></div><div class="decl" id="exists_or_forall_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L496-L497">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_or_forall_not"><span class="name">exists_or_forall_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(P : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">P</span> <span class="fn">a</span></span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">P</span> <span class="fn">a</span></span></span></span></span></div></div></div></div><div class="decl" id="forall_imp_iff_exists_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L499-L503">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_imp_iff_exists_imp"><span class="name">forall_imp_iff_exists_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[ha : <span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span> → <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="forall_true_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L505-L506">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_true_iff"><span class="name">forall_true_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">α</span> → <a href="../.././Init/Prelude.html#True">True</a></span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#True">True</a></span></div></div></div></div><div class="decl" id="forall_true_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L510-L511">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_true_iff'"><span class="name">forall_true_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#True">True</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#True">True</a></span></div></div></div></div><div class="decl" id="forall₂_true_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L514-L514">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall₂_true_iff"><span class="name">forall₂_true_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_3</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././Init/Prelude.html#True">True</a></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#True">True</a></span></div></div></div></div><div class="decl" id="forall₃_true_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L517-L518">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall₃_true_iff"><span class="name">forall₃_true_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_3</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Sort</a> u_4</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span> → <a href="../.././Init/Prelude.html#True">True</a></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#True">True</a></span></div></div></div></div><div class="decl" id="Decidable.and_forall_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L520-L522">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Decidable.and_forall_ne"><span class="name">Decidable</span>.<span class="name">and_forall_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="and_forall_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L524-L525">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#and_forall_ne"><span class="name">and_forall_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="Ne.ne_or_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L527-L528">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.ne_or_ne"><span class="name">Ne</span>.<span class="name">ne_or_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x y : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(z : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">z</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">y</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">z</span></span></span></div></div></div></div><div class="decl" id="exists_apply_eq_apply'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L530-L531">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_apply_eq_apply'"><span class="name">exists_apply_eq_apply'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a' : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a'</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span></span></span></div></div></div></div><div class="decl" id="exists_apply_eq_apply2"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L533-L535">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_apply_eq_apply2"><span class="name">exists_apply_eq_apply2</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">y</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span> <span class="fn">y</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></span></div></div></div></div><div class="decl" id="exists_apply_eq_apply2'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L537-L539">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_apply_eq_apply2'"><span class="name">exists_apply_eq_apply2'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">y</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">x</span> <span class="fn">y</span></span></span></span></span></div></div></div></div><div class="decl" id="exists_apply_eq_apply3"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L541-L544">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_apply_eq_apply3"><span class="name">exists_apply_eq_apply3</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{δ : <a href="../.././foundational_types.html">Sort</a> u_6}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">γ</span> → <span class="fn">δ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">γ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">y</span> : <span class="fn">β</span>), <span class="fn">∃ (<span class="fn">z</span> : <span class="fn">γ</span>), <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span> <span class="fn">y</span> <span class="fn">z</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span></span></span></div></div></div></div><div class="decl" id="exists_apply_eq_apply3'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L546-L549">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_apply_eq_apply3'"><span class="name">exists_apply_eq_apply3'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{δ : <a href="../.././foundational_types.html">Sort</a> u_6}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">γ</span> → <span class="fn">δ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">γ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">y</span> : <span class="fn">β</span>), <span class="fn">∃ (<span class="fn">z</span> : <span class="fn">γ</span>), <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">x</span> <span class="fn">y</span> <span class="fn">z</span></span></span></span></span></span></div></div></div></div><div class="decl" id="exists_apply_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L552-L552">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_apply_eq"><span class="name">exists_apply_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>), <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="exists_exists_and_eq_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L554-L556">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_exists_and_eq_and"><span class="name">exists_exists_and_eq_and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn">(∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">q</span> <span class="fn">b</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">q</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span></span></span></span></div></div></div></div><div class="decl" id="exists_exists_eq_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L558-L560">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_exists_eq_and"><span class="name">exists_exists_eq_and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn">(∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span></span></span></div></div></div></div><div class="decl" id="exists_exists_and_exists_and_eq_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L562-L566">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_exists_and_exists_and_eq_and"><span class="name">exists_exists_and_exists_and_eq_and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Type</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">γ</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">c</span> : <span class="fn">γ</span>), <span class="fn"><span class="fn">(∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∃ (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">r</span> <span class="fn">c</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∃ (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">r</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span>)</span></span></span></span></span></span></span></div></div></div></div><div class="decl" id="exists_exists_exists_and_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L568-L572">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_exists_exists_and_eq"><span class="name">exists_exists_exists_and_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Type</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">γ</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">c</span> : <span class="fn">γ</span>), <span class="fn"><span class="fn">(∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">p</span> <span class="fn">c</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span>)</span></span></span></span></span></div></div></div></div><div class="decl" id="forall_apply_eq_imp_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L574-L575">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_apply_eq_imp_iff'"><span class="name">forall_apply_eq_imp_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span></span></span></div></div></div></div><div class="decl" id="forall_eq_apply_imp_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L577-L578">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_eq_apply_imp_iff'"><span class="name">forall_eq_apply_imp_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span></span></span></div></div></div></div><div class="decl" id="exists₂_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L580-L583">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists₂_comm"><span class="name">exists₂_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι₁ : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι₂ : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{κ₁ : <span class="fn"><span class="fn">ι₁</span> → <a href="../.././foundational_types.html">Sort</a> u_5</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{κ₂ : <span class="fn"><span class="fn">ι₂</span> → <a href="../.././foundational_types.html">Sort</a> u_6</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn">(<span class="fn">i₁</span> : <span class="fn">ι₁</span>) → <span class="fn"><span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span> → <span class="fn">(<span class="fn">i₂</span> : <span class="fn">ι₂</span>) → <span class="fn"><span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">i₁</span> : <span class="fn">ι₁</span>), <span class="fn">∃ (<span class="fn">j₁</span> : <span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span>), <span class="fn">∃ (<span class="fn">i₂</span> : <span class="fn">ι₂</span>), <span class="fn">∃ (<span class="fn">j₂</span> : <span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">i₁</span> <span class="fn">j₁</span> <span class="fn">i₂</span> <span class="fn">j₂</span></span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a>   <span class="fn">∃ (<span class="fn">i₂</span> : <span class="fn">ι₂</span>), <span class="fn">∃ (<span class="fn">j₂</span> : <span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span>), <span class="fn">∃ (<span class="fn">i₁</span> : <span class="fn">ι₁</span>), <span class="fn">∃ (<span class="fn">j₁</span> : <span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">i₁</span> <span class="fn">j₁</span> <span class="fn">i₂</span> <span class="fn">j₂</span></span></span></span></span></span></span></div></div></div></div><div class="decl" id="And.exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L585-L586">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#And.exists"><span class="name">And</span>.<span class="name">exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p q : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">q</span></span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">q</span></span>), <span class="fn"><span class="fn">f</span> <span class="fn">h</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">hp</span> : <span class="fn">p</span>), <span class="fn">∃ (<span class="fn">hq</span> : <span class="fn">q</span>), <span class="fn"><span class="fn">f</span> <span class="fn">⋯</span></span></span></span></span></div></div></div></div><div class="decl" id="forall_or_of_or_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L588-L590">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_or_of_or_forall"><span class="name">forall_or_of_or_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></div></div></div></div><div class="decl" id="Decidable.forall_or_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L593-L596">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Decidable.forall_or_left"><span class="name">Decidable</span>.<span class="name">forall_or_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">q</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">q</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">q</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></span></span></div></div></div></div><div class="decl" id="forall_or_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L598-L599">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_or_left"><span class="name">forall_or_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">q</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">q</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></span></span></div></div></div></div><div class="decl" id="Decidable.forall_or_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L602-L603">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Decidable.forall_or_right"><span class="name">Decidable</span>.<span class="name">forall_or_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">q</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">q</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">q</span></span></span></div></div></div></div><div class="decl" id="forall_or_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L605-L606">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_or_right"><span class="name">forall_or_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">q</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">q</span></span></span></div></div></div></div><div class="decl" id="Exists.fst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L608-L609">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Exists.fst"><span class="name">Exists</span>.<span class="name">fst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">b</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Core.html#Exists">Exists</a> <span class="fn">p</span></span> → <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Exists.snd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L611-L612">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Exists.snd"><span class="name">Exists</span>.<span class="name">snd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">b</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Init/Core.html#Exists">Exists</a> <span class="fn">p</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Prop.exists_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L614-L616">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Prop.exists_iff"><span class="name">Prop</span>.<span class="name">exists_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><a href="../.././foundational_types.html">Prop</a> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">h</span> : <a href="../.././foundational_types.html">Prop</a>), <span class="fn"><span class="fn">p</span> <span class="fn">h</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#False">False</a></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#True">True</a></span></span></span></div></div></div></div><div class="decl" id="Prop.forall_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L618-L619">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Prop.forall_iff"><span class="name">Prop</span>.<span class="name">forall_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><a href="../.././foundational_types.html">Prop</a> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">h</span> : <a href="../.././foundational_types.html">Prop</a>), <span class="fn"><span class="fn">p</span> <span class="fn">h</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#False">False</a></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#True">True</a></span></span></span></div></div></div></div><div class="decl" id="exists_iff_of_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L621-L622">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_iff_of_forall"><span class="name">exists_iff_of_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">p</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn"><span class="fn">q</span> <span class="fn">h</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn"><span class="fn">q</span> <span class="fn">h</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">p</span></span></div></div></div></div><div class="decl" id="exists_prop_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L624-L625">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_prop_of_false"><span class="name">exists_prop_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">p</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> → <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">∃ (<span class="fn">h'</span> : <span class="fn">p</span>), <span class="fn"><span class="fn">q</span> <span class="fn">h'</span></span></span></span></span></div></div></div></div><div class="decl" id="forall_prop_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L631-L633">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_prop_congr"><span class="name">forall_prop_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p p' : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q q' : <span class="fn"><span class="fn">p</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hq : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">h</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">q'</span> <span class="fn">h</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hp : <span class="fn"><span class="fn">p</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">p'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn"><span class="fn">q</span> <span class="fn">h</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">p'</span>), <span class="fn"><span class="fn">q'</span> <span class="fn">⋯</span></span></span></span></div></div></div></div><div class="decl" id="forall_prop_congr'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L637-L639">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_prop_congr'"><span class="name">forall_prop_congr'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p p' : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q q' : <span class="fn"><span class="fn">p</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hq : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">h</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">q'</span> <span class="fn">h</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hp : <span class="fn"><span class="fn">p</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">p'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn"><span class="fn">q</span> <span class="fn">h</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">p'</span>), <span class="fn"><span class="fn">q'</span> <span class="fn">⋯</span></span></span></span></div></div></div></div><div class="decl" id="imp_congr_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L641-L642">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_congr_eq"><span class="name">imp_congr_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b c d : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">c</span> → <span class="fn">d</span>)</span></span></div></div></div></div><div class="decl" id="imp_congr_ctx_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L644-L645">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_congr_ctx_eq"><span class="name">imp_congr_ctx_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b c d : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">c</span> → <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">c</span> → <span class="fn">d</span>)</span></span></div></div></div></div><div class="decl" id="eq_true_intro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L647-L647">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_true_intro"><span class="name">eq_true_intro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#True">True</a></span></div></div></div></div><div class="decl" id="eq_false_intro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L649-L649">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_false_intro"><span class="name">eq_false_intro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#False">False</a></span></div></div></div></div><div class="decl" id="Iff.eq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L652-L652">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.eq"><span class="name">Iff</span>.<span class="name">eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span> → <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Core.html#propext">propext</a></code>.</p><hr></hr><p>The axiom of <strong>propositional extensionality</strong>. It asserts that if propositions
<code>a</code> and <code>b</code> are logically equivalent (i.e. we can prove <code>a</code> from <code>b</code> and vice versa),
then <code>a</code> and <code>b</code> are <em>equal</em>, meaning that we can replace <code>a</code> with <code>b</code> in all
contexts.</p><p>For simple expressions like <code>a ∧ c ∨ d → e</code> we can prove that because all the logical
connectives respect logical equivalence, we can replace <code>a</code> with <code>b</code> in this expression
without using <code><a href="../.././Init/Core.html#propext">propext</a></code>. However, for higher order expressions like <code>P a</code> where
<code>P : Prop → Prop</code> is unknown, or indeed for <code>a = b</code> itself, we cannot replace <code>a</code> with <code>b</code>
without an axiom which says exactly this.</p><p>This is a relatively uncontroversial axiom, which is intuitionistically valid.
It does however block computation when using <code>#reduce</code> to reduce proofs directly
(which is not recommended), meaning that canonicity,
the property that all closed terms of type <code><a href="../.././Init/Prelude.html#Nat">Nat</a></code> normalize to numerals,
fails to hold when this (or any) axiom is used:</p><pre><code>set_option pp.proofs true

def foo : <a href="../.././Init/Prelude.html#Nat">Nat</a> := by
  have : (True → True) ↔ <a href="../.././Init/Prelude.html#True">True</a> := ⟨λ _ =&gt; trivial, λ _ _ =&gt; trivial⟩
  have := <a href="../.././Init/Core.html#propext">propext</a> this ▸ (2 : Nat)
  exact this

#reduce foo
-- <a href="../.././Init/Core.html#propext">propext</a> { mp := fun x x =&gt; True.intro, mpr := fun x =&gt; <a href="../.././Init/Prelude.html#True.intro">True.intro</a> } ▸ 2

#eval foo -- 2
</code></pre><p><code>#eval</code> can evaluate it to a numeral because the compiler erases casts and
does not evaluate proofs, so <code><a href="../.././Init/Core.html#propext">propext</a></code>, whose return type is a proposition,
can never block it.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Iff.eq">@<a href="../.././Mathlib/Logic/Basic.html#Iff.eq">Iff.eq</a></a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Core.html#propext">@<a href="../.././Init/Core.html#propext">propext</a></a></span></li></ul></details><details id="instances-for-list-Iff.eq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="iff_eq_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L654-L654">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#iff_eq_eq"><span class="name">iff_eq_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</span></span></div></div></div></div><div class="decl" id="forall_true_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L658-L660">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_true_left"><span class="name">forall_true_left</span></a></span><span class="decl_args">
<span class="fn">(p : <span class="fn"><a href="../.././Init/Prelude.html#True">True</a> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#True">True</a>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#True.intro">True.intro</a></span></span></div></div><p>See <code>IsEmpty.<a href="../.././Mathlib/Logic/Basic.html#Prop.forall_iff">forall_iff</a></code> for the <code><a href="../.././Init/Prelude.html#False">False</a></code> version.</p></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Classical-lemmas">Classical lemmas <a class="hover-link" href="#Classical-lemmas">#</a></h3></div><div class="decl" id="Classical.dec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L669-L670">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.dec"><span class="name">Classical</span>.<span class="name">dec</span></a></span><span class="decl_args">
<span class="fn">(p : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span></div></div><p>Any prop <code>p</code> is decidable classically. A shorthand for <code><a href="../.././Init/Classical.html#Classical.propDecidable">Classical.propDecidable</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.dec">Classical.dec</a> <span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">inferInstance</span></span></li></ul></details><details id="instances-for-list-Classical.dec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.decPred"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L674-L675">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.decPred"><span class="name">Classical</span>.<span class="name">decPred</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#DecidablePred">DecidablePred</a> <span class="fn">p</span></span></div></div><p>Any predicate <code>p</code> is decidable classically.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.decPred">Classical.decPred</a> <span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">inferInstance</span></span></li></ul></details><details id="instances-for-list-Classical.decPred" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.decRel"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L677-L678">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.decRel"><span class="name">Classical</span>.<span class="name">decRel</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">p</span></span></div></div><p>Any relation <code>p</code> is decidable classically.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.decRel">Classical.decRel</a> <span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">inferInstance</span></span></li></ul></details><details id="instances-for-list-Classical.decRel" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.decEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L680-L681">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.decEq"><span class="name">Classical</span>.<span class="name">decEq</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../.././foundational_types.html">Sort</a> u_2)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span></div></div><p>Any type <code>α</code> has decidable equality classically.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.decEq">Classical.decEq</a> <span class="fn">α</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">inferInstance</span></span></li></ul></details><details id="instances-for-list-Classical.decEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.existsCases"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L683-L686">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.existsCases"><span class="name">Classical</span>.<span class="name">existsCases</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(H0 : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(H : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> → <span class="fn">C</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p>Construct a function from a default value <code>H0</code>, and a function to use if there exists a value
satisfying the predicate.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.existsCases">Classical.existsCases</a> <span class="fn">H0</span> <span class="fn">H</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span></span> then <span class="fn"><span class="fn">H</span> <span class="fn">(<a href="../.././Init/Classical.html#Classical.choose">Classical.choose</a> <span class="fn">h</span>)</span> <span class="fn">⋯</span></span> else <span class="fn">H0</span></span></span></li></ul></details><details id="instances-for-list-Classical.existsCases" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.some_spec₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L688-L689">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.some_spec₂"><span class="name">Classical</span>.<span class="name">some_spec₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{h : <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(q : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(hpq : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">a</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">q</span> <span class="fn">(<a href="../.././Init/Classical.html#Classical.choose">Classical.choose</a> <span class="fn">h</span>)</span></span></div></div></div></div><div class="decl" id="Classical.subtype_of_exists"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L691-L697">source</a></div><div class="attributes">@[deprecated Classical.indefiniteDescription]</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.subtype_of_exists"><span class="name">Classical</span>.<span class="name">subtype_of_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">{ <span class="fn">x</span> : <span class="fn">α</span> // <span class="fn"><span class="fn">P</span> <span class="fn">x</span></span> }</span></div></div><p>A version of <code><a href="../.././Init/Classical.html#Classical.indefiniteDescription">Classical.indefiniteDescription</a></code> which is definitionally equal to a pair.</p><p>In Lean 4, this definition is defeq to <code><a href="../.././Init/Classical.html#Classical.indefiniteDescription">Classical.indefiniteDescription</a></code>,
so it is deprecated.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.subtype_of_exists">Classical.subtype_of_exists</a> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⟨<span class="fn"><a href="../.././Init/Classical.html#Classical.choose">Classical.choose</a> <span class="fn">h</span></span>, <span class="fn">⋯</span>⟩</span></span></li></ul></details><details id="instances-for-list-Classical.subtype_of_exists" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.byContradiction'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L699-L701">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.byContradiction'"><span class="name">Classical</span>.<span class="name">byContradiction'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn">α</span> → <a href="../.././Init/Prelude.html#False">False</a>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>A version of <code>byContradiction</code> that uses types instead of propositions.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.byContradiction'">Classical.byContradiction'</a> <span class="fn">H</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Classical.choice">Classical.choice</a> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-Classical.byContradiction'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.choice_of_byContradiction'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L703-L705">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.choice_of_byContradiction'"><span class="name">Classical</span>.<span class="name">choice_of_byContradiction'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(contra : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn">α</span> → <a href="../.././Init/Prelude.html#False">False</a>)</span></span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span> → <span class="fn">α</span></span></div></div><p><code><a href="../.././Mathlib/Logic/Basic.html#Classical.byContradiction'">Classical.byContradiction'</a></code> is equivalent to lean's axiom <code><a href="../.././Init/Prelude.html#Classical.choice">Classical.choice</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.choice_of_byContradiction'">Classical.choice_of_byContradiction'</a> <span class="fn">contra</span> <span class="fn">H</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">contra</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-Classical.choice_of_byContradiction'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.choose_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L707-L707">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.choose_eq"><span class="name">Classical</span>.<span class="name">choose_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">⋯</span>.choose</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Classical.choose_eq'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L709-L711">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.choose_eq'"><span class="name">Classical</span>.<span class="name">choose_eq'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">⋯</span>.choose</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Classical.axiom_of_choice"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L713-L713">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.axiom_of_choice"><span class="name">Classical</span>.<span class="name">axiom_of_choice</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">y</span> : <span class="fn"><span class="fn">β</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">f</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">β</span> <span class="fn">x</span></span></span>), <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x</span>)</span></span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Classical.html#Classical.axiomOfChoice">Classical.axiomOfChoice</a></code>.</p><hr></hr><p>the axiom of choice</p></div></div><div class="decl" id="Classical.by_cases"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L714-L714">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.by_cases"><span class="name">Classical</span>.<span class="name">by_cases</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p q : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(hpq : <span class="fn"><span class="fn">p</span> → <span class="fn">q</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hnpq : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> → <span class="fn">q</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">q</span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Classical.html#Classical.byCases">Classical.byCases</a></code>.</p></div></div><div class="decl" id="Classical.by_contradiction"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L715-L715">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.by_contradiction"><span class="name">Classical</span>.<span class="name">by_contradiction</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> → <a href="../.././Init/Prelude.html#False">False</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Classical.html#Classical.byContradiction">Classical.byContradiction</a></code>.</p></div></div><div class="decl" id="Classical.prop_complete"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L721-L721">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.prop_complete"><span class="name">Classical</span>.<span class="name">prop_complete</span></a></span><span class="decl_args">
<span class="fn">(a : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#True">True</a></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#False">False</a></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Classical.html#Classical.propComplete">Classical.propComplete</a></code>.</p></div></div><div class="decl" id="Classical.cases_true_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L723-L726">source</a></div><div class="attributes">@[deprecated]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.cases_true_false"><span class="name">Classical</span>.<span class="name">cases_true_false</span></a></span><span class="decl_args">
<span class="fn">(p : <span class="fn"><a href="../.././foundational_types.html">Prop</a> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(h1 : <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#True">True</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(h2 : <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#False">False</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Classical.eq_false_or_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L728-L729">source</a></div><div class="attributes">@[deprecated]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.eq_false_or_eq_true"><span class="name">Classical</span>.<span class="name">eq_false_or_eq_true</span></a></span><span class="decl_args">
<span class="fn">(a : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#False">False</a></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#True">True</a></span></span></div></div></div></div><div class="decl" id="Classical.cases_on"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L732-L734">source</a></div><div class="attributes">@[deprecated]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.cases_on"><span class="name">Classical</span>.<span class="name">cases_on</span></a></span><span class="decl_args">
<span class="fn">(a : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><a href="../.././foundational_types.html">Prop</a> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h1 : <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#True">True</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(h2 : <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#False">False</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Classical.cases"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L737-L738">source</a></div><div class="attributes">@[deprecated]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.cases"><span class="name">Classical</span>.<span class="name">cases</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><a href="../.././foundational_types.html">Prop</a> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h1 : <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#True">True</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(h2 : <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#False">False</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Exists.classicalRecOn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L742-L747">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Exists.classicalRecOn"><span class="name">Exists</span>.<span class="name">classicalRecOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> → <span class="fn">C</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p>This function has the same type as <code><a href="../.././Init/Core.html#Exists.recOn">Exists.recOn</a></code>, and can be used to case on an equality,
but <code><a href="../.././Init/Core.html#Exists.recOn">Exists.recOn</a></code> can only eliminate into Prop, while this version eliminates into any universe
using the axiom of choice.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">h</span>.classicalRecOn</span> <span class="fn">H</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">H</span> <span class="fn">(<a href="../.././Init/Classical.html#Classical.choose">Classical.choose</a> <span class="fn">h</span>)</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-Exists.classicalRecOn" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-bounded-quantifiers">Declarations about bounded quantifiers <a class="hover-link" href="#Declarations-about-bounded-quantifiers">#</a></h3></div><div class="decl" id="bex_def"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L754-L755">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#bex_def"><span class="name">bex_def</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p q : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">x_1</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></span></span></div></div></div></div><div class="decl" id="BEx.elim"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L757-L758">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#BEx.elim"><span class="name">BEx</span>.<span class="name">elim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span>)</span> → <span class="fn"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">a</span> <span class="fn">h</span></span> → <span class="fn">b</span></span>)</span> → <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="BEx.intro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L760-L761">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#BEx.intro"><span class="name">BEx</span>.<span class="name">intro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">P</span> <span class="fn">a</span> <span class="fn">h₁</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span></div></div></div></div><div class="decl" id="bex_eq_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L763-L765">source</a></div><div class="attributes">@[deprecated exists_eq_left]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#bex_eq_left"><span class="name">bex_eq_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">x_1</span> : <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="ball_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L767-L767">source</a></div><div class="attributes">@[deprecated forall₂_congr]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ball_congr"><span class="name">ball_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p q : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/PropLemmas.html#forall₂_congr">forall₂_congr</a></code>.</p></div></div><div class="decl" id="bex_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L768-L768">source</a></div><div class="attributes">@[deprecated exists₂_congr]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#bex_congr"><span class="name">bex_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p q : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/PropLemmas.html#exists₂_congr">exists₂_congr</a></code>.</p></div></div><div class="decl" id="BAll.imp_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L770-L771">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#BAll.imp_right"><span class="name">BAll</span>.<span class="name">imp_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P Q : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span> → <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₁ : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="BEx.imp_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L773-L774">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#BEx.imp_right"><span class="name">BEx</span>.<span class="name">imp_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P Q : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span> → <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span>)</span> → <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span></span></div></div></div></div><div class="decl" id="BAll.imp_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L776-L777">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#BAll.imp_left"><span class="name">BAll</span>.<span class="name">imp_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r p q : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₁ : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">x</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="BEx.imp_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L779-L780">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#BEx.imp_left"><span class="name">BEx</span>.<span class="name">imp_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r p q : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">x_1</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span>)</span> → <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">x_1</span> : <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span></span></span></div></div></div></div><div class="decl" id="ball_of_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L782-L783">source</a></div><div class="attributes">@[deprecated id]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ball_of_forall"><span class="name">ball_of_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="forall_of_ball"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L785-L786">source</a></div><div class="attributes">@[deprecated forall_imp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_of_ball"><span class="name">forall_of_ball</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p q : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="exists_mem_of_exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L788-L789">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_mem_of_exists"><span class="name">exists_mem_of_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p q : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span>)</span> → <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">x_1</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></span></span></div></div></div></div><div class="decl" id="exists_of_exists_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L791-L792">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_of_exists_mem"><span class="name">exists_of_exists_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p q : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">x_1</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span>)</span> → <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></span></div></div></div></div><div class="decl" id="bex_of_exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L794-L794">source</a></div><div class="attributes">@[deprecated exists_mem_of_exists]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#bex_of_exists"><span class="name">bex_of_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p q : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span>)</span> → <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">x_1</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Logic/Basic.html#exists_mem_of_exists">exists_mem_of_exists</a></code>.</p></div></div><div class="decl" id="exists_of_bex"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L795-L795">source</a></div><div class="attributes">@[deprecated exists_of_exists_mem]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_of_bex"><span class="name">exists_of_bex</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p q : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">x_1</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span>)</span> → <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Logic/Basic.html#exists_of_exists_mem">exists_of_exists_mem</a></code>.</p></div></div><div class="decl" id="bex_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L796-L796">source</a></div><div class="attributes">@[deprecated exists₂_imp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#bex_imp"><span class="name">bex_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span>)</span> → <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span> → <span class="fn">b</span></span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/PropLemmas.html#exists₂_imp">exists₂_imp</a></code>.</p></div></div><div class="decl" id="not_exists_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L798-L798">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_exists_mem"><span class="name">not_exists_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span></span></div></div></div></div><div class="decl" id="not_forall₂_of_exists₂_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L800-L801">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_forall₂_of_exists₂_not"><span class="name">not_forall₂_of_exists₂_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span>)</span> → <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span></span></div></div></div></div><div class="decl" id="Decidable.not_forall₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L804-L807">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Decidable.not_forall₂"><span class="name">Decidable</span>.<span class="name">not_forall₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>) → <span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span>)</span></span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span></span></span></div></div></div></div><div class="decl" id="not_forall₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L809-L809">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_forall₂"><span class="name">not_forall₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span></span></span></div></div></div></div><div class="decl" id="forall₂_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L811-L812">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall₂_and"><span class="name">forall₂_and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P Q : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span></span></div></div></div></div><div class="decl" id="forall_and_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L814-L815">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_and_left"><span class="name">forall_and_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(q : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">q</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">q</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></span></span></div></div></div></div><div class="decl" id="forall_and_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L817-L818">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_and_right"><span class="name">forall_and_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(q : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">q</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">q</span></span></span></div></div></div></div><div class="decl" id="exists_mem_or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L820-L821">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_mem_or"><span class="name">exists_mem_or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P Q : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span></span></span></div></div></div></div><div class="decl" id="forall₂_or_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L823-L824">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall₂_or_left"><span class="name">forall₂_or_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r p q : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">x</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span></span></span></span></div></div></div></div><div class="decl" id="exists_mem_or_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L826-L829">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_mem_or_left"><span class="name">exists_mem_or_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r p q : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">x_1</span> : <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span>), <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">x_1</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">x_1</span> : <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span></span></span></span></div></div></div></div><div class="decl" id="dite_eq_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L838-L839">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_eq_iff"><span class="name">dite_eq_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">A</span> <span class="fn">B</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(∃ (<span class="fn">h</span> : <span class="fn">P</span>), <span class="fn"><span class="fn"><span class="fn">A</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span>), <span class="fn"><span class="fn"><span class="fn">B</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></span></span></div></div></div></div><div class="decl" id="ite_eq_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L841-L842">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_eq_iff"><span class="name">ite_eq_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">P</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></span></span></div></div></div></div><div class="decl" id="eq_ite_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L844-L845">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_ite_iff"><span class="name">eq_ite_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if <span class="fn">P</span> then <span class="fn">b</span> else <span class="fn">c</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">P</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></span></span></div></div></div></div><div class="decl" id="dite_eq_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L847-L849">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_eq_iff'"><span class="name">dite_eq_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">A</span> <span class="fn">B</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(∀ (<span class="fn">h</span> : <span class="fn">P</span>), <span class="fn"><span class="fn"><span class="fn">A</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span>), <span class="fn"><span class="fn"><span class="fn">B</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></span></span></div></div></div></div><div class="decl" id="ite_eq_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L851-L851">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_eq_iff'"><span class="name">ite_eq_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(<span class="fn">P</span> → <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span>)</span></span></span></div></div></div></div><div class="decl" id="dite_ne_left_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L853-L855">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_ne_left_iff"><span class="name">dite_ne_left_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">P</span>) =&gt; <span class="fn">a</span>)</span> <span class="fn">B</span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span>), <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn"><span class="fn">B</span> <span class="fn">h</span></span></span></span></span></div></div></div></div><div class="decl" id="dite_ne_right_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L857-L858">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_ne_right_iff"><span class="name">dite_ne_right_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">A</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span>) =&gt; <span class="fn">b</span></span>)</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">h</span> : <span class="fn">P</span>), <span class="fn"><span class="fn"><span class="fn">A</span> <span class="fn">h</span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="ite_ne_left_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L860-L861">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_ne_left_iff"><span class="name">ite_ne_left_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">b</span>)</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="ite_ne_right_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L863-L864">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_ne_right_iff"><span class="name">ite_ne_right_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">b</span>)</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">P</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="Ne.dite_eq_left_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L866-L867">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.dite_eq_left_iff"><span class="name">Ne</span>.<span class="name">dite_eq_left_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span>), <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn"><span class="fn">B</span> <span class="fn">h</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">P</span>) =&gt; <span class="fn">a</span>)</span> <span class="fn">B</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">P</span></span></div></div></div></div><div class="decl" id="Ne.dite_eq_right_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L869-L870">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.dite_eq_right_iff"><span class="name">Ne</span>.<span class="name">dite_eq_right_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">P</span>), <span class="fn"><span class="fn"><span class="fn">A</span> <span class="fn">h</span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">A</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span>) =&gt; <span class="fn">b</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span></span></div></div></div></div><div class="decl" id="Ne.ite_eq_left_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L872-L873">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.ite_eq_left_iff"><span class="name">Ne</span>.<span class="name">ite_eq_left_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">P</span></span></div></div></div></div><div class="decl" id="Ne.ite_eq_right_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L875-L876">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.ite_eq_right_iff"><span class="name">Ne</span>.<span class="name">ite_eq_right_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span></span></div></div></div></div><div class="decl" id="Ne.dite_ne_left_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L878-L879">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.dite_ne_left_iff"><span class="name">Ne</span>.<span class="name">dite_ne_left_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span>), <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn"><span class="fn">B</span> <span class="fn">h</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">P</span>) =&gt; <span class="fn">a</span>)</span> <span class="fn">B</span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span></span></div></div></div></div><div class="decl" id="Ne.dite_ne_right_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L881-L882">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.dite_ne_right_iff"><span class="name">Ne</span>.<span class="name">dite_ne_right_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">P</span>), <span class="fn"><span class="fn"><span class="fn">A</span> <span class="fn">h</span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">A</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span>) =&gt; <span class="fn">b</span></span>)</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">P</span></span></div></div></div></div><div class="decl" id="Ne.ite_ne_left_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L884-L885">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.ite_ne_left_iff"><span class="name">Ne</span>.<span class="name">ite_ne_left_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">b</span>)</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span></span></div></div></div></div><div class="decl" id="Ne.ite_ne_right_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L887-L888">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.ite_ne_right_iff"><span class="name">Ne</span>.<span class="name">ite_ne_right_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">b</span>)</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">P</span></span></div></div></div></div><div class="decl" id="dite_eq_or_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L892-L893">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_eq_or_eq"><span class="name">dite_eq_or_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(P : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">h</span> : <span class="fn">P</span>), <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">A</span> <span class="fn">B</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">A</span> <span class="fn">h</span></span></span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span>), <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">A</span> <span class="fn">B</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">B</span> <span class="fn">h</span></span></span></span></span></div></div></div></div><div class="decl" id="ite_eq_or_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L895-L896">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_eq_or_eq"><span class="name">ite_eq_or_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(P : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a b : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">(if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="apply_dite₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L898-L903">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#apply_dite₂"><span class="name">apply_dite₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(P : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn"><span class="fn">P</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(d : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">a</span> <span class="fn">b</span>)</span> <span class="fn">(<a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">c</span> <span class="fn">d</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">P</span> then <span class="fn"><span class="fn">f</span> <span class="fn">(<span class="fn">a</span> <span class="fn">h</span>)</span> <span class="fn">(<span class="fn">c</span> <span class="fn">h</span>)</span></span> else <span class="fn"><span class="fn">f</span> <span class="fn">(<span class="fn">b</span> <span class="fn">h</span>)</span> <span class="fn">(<span class="fn">d</span> <span class="fn">h</span>)</span></span></span></span></div></div><p>A two-argument function applied to two <code><a href="../.././Init/Prelude.html#dite">dite</a></code>s is a <code><a href="../.././Init/Prelude.html#dite">dite</a></code> of that two-argument function
applied to each of the branches.</p></div></div><div class="decl" id="apply_ite₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L905-L909">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#apply_ite₂"><span class="name">apply_ite₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(P : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a b : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(c d : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">(if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">b</span>)</span> <span class="fn">(if <span class="fn">P</span> then <span class="fn">c</span> else <span class="fn">d</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if <span class="fn">P</span> then <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">c</span></span> else <span class="fn"><span class="fn">f</span> <span class="fn">b</span> <span class="fn">d</span></span></span></span></div></div><p>A two-argument function applied to two <code><a href="../.././Init/Prelude.html#ite">ite</a></code>s is a <code><a href="../.././Init/Prelude.html#ite">ite</a></code> of that two-argument function
applied to each of the branches.</p></div></div><div class="decl" id="dite_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L911-L914">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_apply"><span class="name">dite_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{σ : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(P : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">P</span> → <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">σ</span> <span class="fn">a</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">σ</span> <span class="fn">a</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">P</span> then <span class="fn"><span class="fn">f</span> <span class="fn">h</span> <span class="fn">a</span></span> else <span class="fn"><span class="fn">g</span> <span class="fn">h</span> <span class="fn">a</span></span></span></span></div></div><p>A 'dite' producing a <code>Pi</code> type <code>Π a, σ a</code>, applied to a value <code>a : α</code> is a <code><a href="../.././Init/Prelude.html#dite">dite</a></code> that applies
either branch to <code>a</code>.</p></div></div><div class="decl" id="ite_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L916-L919">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_apply"><span class="name">ite_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{σ : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(P : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f g : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">σ</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(if <span class="fn">P</span> then <span class="fn">f</span> else <span class="fn">g</span>)</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if <span class="fn">P</span> then <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> else <span class="fn"><span class="fn">g</span> <span class="fn">a</span></span></span></span></div></div><p>A 'ite' producing a <code>Pi</code> type <code>Π a, σ a</code>, applied to a value <code>a : α</code> is a <code><a href="../.././Init/Prelude.html#ite">ite</a></code> that applies
either branch to <code>a</code>.</p></div></div><div class="decl" id="ite_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L924-L925">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_and"><span class="name">ite_and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(P Q : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a b : <span class="fn">α</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">Q</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(if <span class="fn"><span class="fn">P</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">Q</span></span> then <span class="fn">a</span> else <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if <span class="fn">P</span> then <span class="fn">if <span class="fn">Q</span> then <span class="fn">a</span> else <span class="fn">b</span></span> else <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="ite_or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L927-L928">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_or"><span class="name">ite_or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(P Q : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a b : <span class="fn">α</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">Q</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(if <span class="fn"><span class="fn">P</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">Q</span></span> then <span class="fn">a</span> else <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">if <span class="fn">Q</span> then <span class="fn">a</span> else <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="dite_dite_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L930-L935">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_dite_comm"><span class="name">dite_dite_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(P Q : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">Q</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn"><span class="fn">Q</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">Q</span></span> → <span class="fn">α</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">P</span> → <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">Q</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(if p : <span class="fn">P</span> then <span class="fn"><span class="fn">A</span> <span class="fn">p</span></span> else <span class="fn">if q : <span class="fn">Q</span> then <span class="fn"><span class="fn">B</span> <span class="fn">q</span></span> else <span class="fn"><span class="fn">C</span> <span class="fn">p</span> <span class="fn">q</span></span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if q : <span class="fn">Q</span> then <span class="fn"><span class="fn">B</span> <span class="fn">q</span></span> else <span class="fn">if p : <span class="fn">P</span> then <span class="fn"><span class="fn">A</span> <span class="fn">p</span></span> else <span class="fn"><span class="fn">C</span> <span class="fn">p</span> <span class="fn">q</span></span></span></span></span></div></div></div></div><div class="decl" id="ite_ite_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L937-L940">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_ite_comm"><span class="name">ite_ite_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(P Q : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a b : <span class="fn">α</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">Q</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">P</span> → <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">Q</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">if <span class="fn">Q</span> then <span class="fn">b</span> else <span class="fn">c</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if <span class="fn">Q</span> then <span class="fn">b</span> else <span class="fn">if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">c</span></span></span></span></div></div></div></div><div class="decl" id="ite_prop_iff_or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L946-L947">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_prop_iff_or"><span class="name">ite_prop_iff_or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P Q R : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(if <span class="fn">P</span> then <span class="fn">Q</span> else <span class="fn">R</span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">P</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">Q</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">R</span></span></span></span></div></div></div></div><div class="decl" id="dite_prop_iff_or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L949-L951">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_prop_iff_or"><span class="name">dite_prop_iff_or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Q : <span class="fn"><span class="fn">P</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">Q</span> <span class="fn">R</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(∃ (<span class="fn">p</span> : <span class="fn">P</span>), <span class="fn"><span class="fn">Q</span> <span class="fn">p</span></span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∃ (<span class="fn">p</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span>), <span class="fn"><span class="fn">R</span> <span class="fn">p</span></span></span></span></span></div></div></div></div><div class="decl" id="ite_prop_iff_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L954-L955">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_prop_iff_and"><span class="name">ite_prop_iff_and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P Q R : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(if <span class="fn">P</span> then <span class="fn">Q</span> else <span class="fn">R</span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(<span class="fn">P</span> → <span class="fn">Q</span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <span class="fn">R</span>)</span></span></span></div></div></div></div><div class="decl" id="dite_prop_iff_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L957-L959">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_prop_iff_and"><span class="name">dite_prop_iff_and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Q : <span class="fn"><span class="fn">P</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">Q</span> <span class="fn">R</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(∀ (<span class="fn">h</span> : <span class="fn">P</span>), <span class="fn"><span class="fn">Q</span> <span class="fn">h</span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span>), <span class="fn"><span class="fn">R</span> <span class="fn">h</span></span></span></span></span></div></div></div></div><div class="decl" id="if_ctx_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L965-L970">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#if_ctx_congr"><span class="name">if_ctx_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P Q : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">Q</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x y u v : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h_c : <span class="fn"><span class="fn">P</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">Q</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h_t : <span class="fn"><span class="fn">Q</span> → <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">u</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h_e : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">Q</span></span> → <span class="fn"><span class="fn">y</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(if <span class="fn">P</span> then <span class="fn">x</span> else <span class="fn">y</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if <span class="fn">Q</span> then <span class="fn">u</span> else <span class="fn">v</span></span></span></div></div></div></div><div class="decl" id="if_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L972-L973">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#if_congr"><span class="name">if_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P Q : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">Q</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x y u v : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h_c : <span class="fn"><span class="fn">P</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">Q</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h_t : <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">u</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h_e : <span class="fn"><span class="fn">y</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(if <span class="fn">P</span> then <span class="fn">x</span> else <span class="fn">y</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if <span class="fn">Q</span> then <span class="fn">u</span> else <span class="fn">v</span></span></span></div></div></div></div><div class="decl" id="not_beq_of_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L979-L980">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_beq_of_ne"><span class="name">not_beq_of_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(ne : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">(<span class="fn">a</span> <a href="../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="beq_eq_decide"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L982-L984">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#beq_eq_decide"><span class="name">beq_eq_decide</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href="../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Decidable.decide">decide</a> <span class="fn">(<span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</span></span></span></div></div></div></div><div class="decl" id="beq_eq_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L986-L987">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#beq_eq_beq"><span class="name">beq_eq_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₁ a₂ : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b₁ b₂ : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn">a₁</span> <a href="../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a₂</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">b₁</span> <a href="../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b₂</span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn"><span class="fn">a₁</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a₂</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">b₁</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₂</span></span>)</span></span></div></div></div></div><div class="decl" id="beq_ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L989-L989">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#beq_ext"><span class="name">beq_ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(inst1 inst2 : <span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">(<span class="fn">x</span> <a href="../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">y</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">x</span> <a href="../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">y</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">inst1</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">inst2</span></span></div></div></div></div><div class="decl" id="lawful_beq_subsingleton"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Basic.lean#L999-L1004">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#lawful_beq_subsingleton"><span class="name">lawful_beq_subsingleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(inst1 inst2 : <span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">inst1</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">inst2</span></span></div></div></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>