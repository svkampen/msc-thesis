<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Logic.Relation</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Logic.Relation";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Logic</span>.<span class="name">Relation</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/Logic/Relator.html">Mathlib.Logic.Relator</a></li><li><a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html">Mathlib.Tactic.MkIffOfInductiveProp</a></li><li><a href="../.././Mathlib/Tactic/SimpRw.html">Mathlib.Tactic.SimpRw</a></li><li><a href="../.././Mathlib/Tactic/Use.html">Mathlib.Tactic.Use</a></li><li><a href="../.././Mathlib/Logic/Function/Basic.html">Mathlib.Logic.Function.Basic</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Logic.Relation" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#IsRefl.reflexive"><span class="name">IsRefl</span>.<span class="name">reflexive</span></a></div><div class="nav_link"><a class="break_within" href="#Reflexive.rel_of_ne_imp"><span class="name">Reflexive</span>.<span class="name">rel_of_ne_imp</span></a></div><div class="nav_link"><a class="break_within" href="#Reflexive.ne_imp_iff"><span class="name">Reflexive</span>.<span class="name">ne_imp_iff</span></a></div><div class="nav_link"><a class="break_within" href="#reflexive_ne_imp_iff"><span class="name">reflexive_ne_imp_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Symmetric.iff"><span class="name">Symmetric</span>.<span class="name">iff</span></a></div><div class="nav_link"><a class="break_within" href="#Symmetric.flip_eq"><span class="name">Symmetric</span>.<span class="name">flip_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Symmetric.swap_eq"><span class="name">Symmetric</span>.<span class="name">swap_eq</span></a></div><div class="nav_link"><a class="break_within" href="#flip_eq_iff"><span class="name">flip_eq_iff</span></a></div><div class="nav_link"><a class="break_within" href="#swap_eq_iff"><span class="name">swap_eq_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Reflexive.comap"><span class="name">Reflexive</span>.<span class="name">comap</span></a></div><div class="nav_link"><a class="break_within" href="#Symmetric.comap"><span class="name">Symmetric</span>.<span class="name">comap</span></a></div><div class="nav_link"><a class="break_within" href="#Transitive.comap"><span class="name">Transitive</span>.<span class="name">comap</span></a></div><div class="nav_link"><a class="break_within" href="#Equivalence.comap"><span class="name">Equivalence</span>.<span class="name">comap</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.Comp"><span class="name">Relation</span>.<span class="name">Comp</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.comp_eq"><span class="name">Relation</span>.<span class="name">comp_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.eq_comp"><span class="name">Relation</span>.<span class="name">eq_comp</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.iff_comp"><span class="name">Relation</span>.<span class="name">iff_comp</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.comp_iff"><span class="name">Relation</span>.<span class="name">comp_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.comp_assoc"><span class="name">Relation</span>.<span class="name">comp_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.flip_comp"><span class="name">Relation</span>.<span class="name">flip_comp</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.Fibration"><span class="name">Relation</span>.<span class="name">Fibration</span></a></div><div class="nav_link"><a class="break_within" href="#Acc.of_fibration"><span class="name">Acc</span>.<span class="name">of_fibration</span></a></div><div class="nav_link"><a class="break_within" href="#Acc.of_downward_closed"><span class="name">Acc</span>.<span class="name">of_downward_closed</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.Map"><span class="name">Relation</span>.<span class="name">Map</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.map_apply"><span class="name">Relation</span>.<span class="name">map_apply</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.map_map"><span class="name">Relation</span>.<span class="name">map_map</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.map_apply_apply"><span class="name">Relation</span>.<span class="name">map_apply_apply</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.map_id_id"><span class="name">Relation</span>.<span class="name">map_id_id</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.instDecidableMapOfExistsAndEq"><span class="name">Relation</span>.<span class="name">instDecidableMapOfExistsAndEq</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen"><span class="name">Relation</span>.<span class="name">ReflTransGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.cases_tail_iff"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">cases_tail_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflGen"><span class="name">Relation</span>.<span class="name">ReflGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflGen_iff"><span class="name">Relation</span>.<span class="name">reflGen_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.EqvGen"><span class="name">Relation</span>.<span class="name">EqvGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.eqvGen_iff"><span class="name">Relation</span>.<span class="name">eqvGen_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.transGen_iff"><span class="name">Relation</span>.<span class="name">transGen_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflGen.to_reflTransGen"><span class="name">Relation</span>.<span class="name">ReflGen</span>.<span class="name">to_reflTransGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflGen.mono"><span class="name">Relation</span>.<span class="name">ReflGen</span>.<span class="name">mono</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflGen.instIsRefl"><span class="name">Relation</span>.<span class="name">ReflGen</span>.<span class="name">instIsRefl</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.trans"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">trans</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.single"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">single</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.head"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">head</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.symmetric"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">symmetric</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.cases_tail"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">cases_tail</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.head_induction_on"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">head_induction_on</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.trans_induction_on"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">trans_induction_on</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.cases_head"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">cases_head</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.cases_head_iff"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">cases_head_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.total_of_right_unique"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">total_of_right_unique</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.to_reflTransGen"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">to_reflTransGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.trans_left"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">trans_left</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.instTransReflTransGen"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">instTransReflTransGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.instTrans_mathlib"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">instTrans_mathlib</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.head'"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">head'</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.tail'"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">tail'</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.head"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">head</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.head_induction_on"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">head_induction_on</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.trans_induction_on"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">trans_induction_on</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.trans_right"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">trans_right</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.instTransReflTransGen_1"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">instTransReflTransGen_1</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.tail'_iff"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">tail'_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.head'_iff"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">head'_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflGen_eq_self"><span class="name">Relation</span>.<span class="name">reflGen_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflexive_reflGen"><span class="name">Relation</span>.<span class="name">reflexive_reflGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflGen_minimal"><span class="name">Relation</span>.<span class="name">reflGen_minimal</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.transGen_eq_self"><span class="name">Relation</span>.<span class="name">transGen_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.transitive_transGen"><span class="name">Relation</span>.<span class="name">transitive_transGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.instIsTransTransGen"><span class="name">Relation</span>.<span class="name">instIsTransTransGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.transGen_idem"><span class="name">Relation</span>.<span class="name">transGen_idem</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.lift"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">lift</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.lift'"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">lift'</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.closed"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">closed</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.closed'"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">closed'</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.mono"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">mono</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.transGen_minimal"><span class="name">Relation</span>.<span class="name">transGen_minimal</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.swap"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">swap</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.transGen_swap"><span class="name">Relation</span>.<span class="name">transGen_swap</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_iff_eq"><span class="name">Relation</span>.<span class="name">reflTransGen_iff_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_iff_eq_or_transGen"><span class="name">Relation</span>.<span class="name">reflTransGen_iff_eq_or_transGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.lift"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">lift</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.mono"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">mono</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_eq_self"><span class="name">Relation</span>.<span class="name">reflTransGen_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_minimal"><span class="name">Relation</span>.<span class="name">reflTransGen_minimal</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflexive_reflTransGen"><span class="name">Relation</span>.<span class="name">reflexive_reflTransGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.transitive_reflTransGen"><span class="name">Relation</span>.<span class="name">transitive_reflTransGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.instIsReflReflTransGen"><span class="name">Relation</span>.<span class="name">instIsReflReflTransGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.instIsTransReflTransGen"><span class="name">Relation</span>.<span class="name">instIsTransReflTransGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_idem"><span class="name">Relation</span>.<span class="name">reflTransGen_idem</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.lift'"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">lift'</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_closed"><span class="name">Relation</span>.<span class="name">reflTransGen_closed</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.swap"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">swap</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_swap"><span class="name">Relation</span>.<span class="name">reflTransGen_swap</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflGen_transGen"><span class="name">Relation</span>.<span class="name">reflGen_transGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.transGen_reflGen"><span class="name">Relation</span>.<span class="name">transGen_reflGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_reflGen"><span class="name">Relation</span>.<span class="name">reflTransGen_reflGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_transGen"><span class="name">Relation</span>.<span class="name">reflTransGen_transGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_eq_transGen"><span class="name">Relation</span>.<span class="name">reflTransGen_eq_transGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_eq_reflGen"><span class="name">Relation</span>.<span class="name">reflTransGen_eq_reflGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.EqvGen.is_equivalence"><span class="name">Relation</span>.<span class="name">EqvGen</span>.<span class="name">is_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.EqvGen.setoid"><span class="name">Relation</span>.<span class="name">EqvGen</span>.<span class="name">setoid</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.EqvGen.mono"><span class="name">Relation</span>.<span class="name">EqvGen</span>.<span class="name">mono</span></a></div><div class="nav_link"><a class="break_within" href="#EqvGen.is_equivalence"><span class="name">EqvGen</span>.<span class="name">is_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#EqvGen.Setoid"><span class="name">EqvGen</span>.<span class="name">Setoid</span></a></div><div class="nav_link"><a class="break_within" href="#EqvGen.mono"><span class="name">EqvGen</span>.<span class="name">mono</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.Join"><span class="name">Relation</span>.<span class="name">Join</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.church_rosser"><span class="name">Relation</span>.<span class="name">church_rosser</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.join_of_single"><span class="name">Relation</span>.<span class="name">join_of_single</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.symmetric_join"><span class="name">Relation</span>.<span class="name">symmetric_join</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflexive_join"><span class="name">Relation</span>.<span class="name">reflexive_join</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.transitive_join"><span class="name">Relation</span>.<span class="name">transitive_join</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.equivalence_join"><span class="name">Relation</span>.<span class="name">equivalence_join</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.equivalence_join_reflTransGen"><span class="name">Relation</span>.<span class="name">equivalence_join_reflTransGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.join_of_equivalence"><span class="name">Relation</span>.<span class="name">join_of_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_of_transitive_reflexive"><span class="name">Relation</span>.<span class="name">reflTransGen_of_transitive_reflexive</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_of_equivalence"><span class="name">Relation</span>.<span class="name">reflTransGen_of_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.eqvGen_exact"><span class="name">Quot</span>.<span class="name">eqvGen_exact</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.eqvGen_sound"><span class="name">Quot</span>.<span class="name">eqvGen_sound</span></a></div><div class="nav_link"><a class="break_within" href="#Equivalence.eqvGen_iff"><span class="name">Equivalence</span>.<span class="name">eqvGen_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Equivalence.eqvGen_eq"><span class="name">Equivalence</span>.<span class="name">eqvGen_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.exact"><span class="name">Quot</span>.<span class="name">exact</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.EqvGen_sound"><span class="name">Quot</span>.<span class="name">EqvGen_sound</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Relation-closures">Relation closures <a class="hover-link" href="#Relation-closures">#</a></h1><p>This file defines the reflexive, transitive, reflexive transitive and equivalence closures
of relations and proves some basic results on them.</p><p>Note that this is about unbundled relations, that is terms of types of the form <code>α → β → Prop</code>. For
the bundled version, see <code>Rel</code>.</p><h2 class="markdown-heading" id="Definitions">Definitions <a class="hover-link" href="#Definitions">#</a></h2><ul>
<li><code><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">Relation.ReflGen</a></code>: Reflexive closure. <code><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">ReflGen</a> r</code> relates everything <code>r</code> related, plus for all
<code>a</code> it relates <code>a</code> with itself. So <code><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">ReflGen</a> r a b ↔ r a b ∨ a = b</code>.</li>
<li><code><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a></code>: Transitive closure. <code>TransGen r</code> relates everything <code>r</code> related
transitively. So <code>TransGen r a b ↔ ∃ x₀ ... xₙ, r a x₀ ∧ r x₀ x₁ ∧ ... ∧ r xₙ b</code>.</li>
<li><code><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a></code>: Reflexive transitive closure. <code><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> r</code> relates everything
<code>r</code> related transitively, plus for all <code>a</code> it relates <code>a</code> with itself. So
<code><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> r a b ↔ (∃ x₀ ... xₙ, r a x₀ ∧ r x₀ x₁ ∧ ... ∧ r xₙ b) ∨ a = b</code>. It is the same as
the reflexive closure of the transitive closure, or the transitive closure of the reflexive
closure. In terms of rewriting systems, this means that <code>a</code> can be rewritten to <code>b</code> in a number of
rewrites.</li>
<li><code><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">Relation.EqvGen</a></code>: Equivalence closure. <code><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">EqvGen</a> r</code> relates everything <code><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> r</code> relates,
plus for all related pairs it relates them in the opposite order.</li>
<li><code><a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Relation.Comp</a></code>:  Relation composition. We provide notation <code>∘r</code>. For <code>r : α → β → Prop</code> and
<code>s : β → γ → Prop</code>, <code>r ∘r s</code>relates <code>a : α</code> and <code>c : γ</code> iff there exists <code>b : β</code> that's related to
both.</li>
<li><code><a href="../.././Mathlib/Logic/Relation.html#Relation.Map">Relation.Map</a></code>: Image of a relation under a pair of maps. For <code>r : α → β → Prop</code>, <code>f : α → γ</code>,
<code>g : β → δ</code>, <code><a href="../.././Mathlib/Logic/Relation.html#Relation.Map">Map</a> r f g</code> is the relation <code>γ → δ → Prop</code> relating <code>f a</code> and <code>g b</code> for all <code>a</code>, <code>b</code>
related by <code>r</code>.</li>
<li><code><a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Relation.Join</a></code>: Join of a relation. For <code>r : α → α → Prop</code>, <code><a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Join</a> r a b ↔ ∃ c, r a c ∧ r b c</code>. In
terms of rewriting systems, this means that <code>a</code> and <code>b</code> can be rewritten to the same term.</li>
</ul></div><div class="decl" id="IsRefl.reflexive"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L54-L54">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#IsRefl.reflexive"><span class="name">IsRefl</span>.<span class="name">reflexive</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#IsRefl">IsRefl</a> <span class="fn">α</span> <span class="fn">r</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Reflexive">Reflexive</a> <span class="fn">r</span></span></div></div></div></div><div class="decl" id="Reflexive.rel_of_ne_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L56-L61">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Reflexive.rel_of_ne_imp"><span class="name">Reflexive</span>.<span class="name">rel_of_ne_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Reflexive">Reflexive</a> <span class="fn">r</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{x y : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hr : <span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span></div></div><p>To show a reflexive relation <code>r : α → α → Prop</code> holds over <code>x y : α</code>,
it suffices to show it holds when <code>x ≠ y</code>.</p></div></div><div class="decl" id="Reflexive.ne_imp_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L64-L67">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Reflexive.ne_imp_iff"><span class="name">Reflexive</span>.<span class="name">ne_imp_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Reflexive">Reflexive</a> <span class="fn">r</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{x y : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span></span></div></div><p>If a reflexive relation <code>r : α → α → Prop</code> holds over <code>x y : α</code>,
then it holds whether or not <code>x ≠ y</code>.</p></div></div><div class="decl" id="reflexive_ne_imp_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L69-L72">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#reflexive_ne_imp_iff"><span class="name">reflexive_ne_imp_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#IsRefl">IsRefl</a> <span class="fn">α</span> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x y : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span></span></div></div><p>If a reflexive relation <code>r : α → α → Prop</code> holds over <code>x y : α</code>,
then it holds whether or not <code>x ≠ y</code>. Unlike <code><a href="../.././Mathlib/Logic/Relation.html#Reflexive.ne_imp_iff">Reflexive.ne_imp_iff</a></code>, this uses <code>[IsRefl α r]</code>.</p></div></div><div class="decl" id="Symmetric.iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L74-L75">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Symmetric.iff"><span class="name">Symmetric</span>.<span class="name">iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Symmetric">Symmetric</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x y : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">r</span> <span class="fn">y</span> <span class="fn">x</span></span></span></div></div></div></div><div class="decl" id="Symmetric.flip_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L77-L78">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Symmetric.flip_eq"><span class="name">Symmetric</span>.<span class="name">flip_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Symmetric">Symmetric</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Core.html#flip">flip</a> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></span></div></div></div></div><div class="decl" id="Symmetric.swap_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L80-L81">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Symmetric.swap_eq"><span class="name">Symmetric</span>.<span class="name">swap_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Symmetric">Symmetric</a> <span class="fn">r</span></span> → <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Function/Defs.html#Function.swap">Function.swap</a> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></span></span></div></div></div></div><div class="decl" id="flip_eq_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L83-L84">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#flip_eq_iff"><span class="name">flip_eq_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Init/Core.html#flip">flip</a> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Symmetric">Symmetric</a> <span class="fn">r</span></span></span></div></div></div></div><div class="decl" id="swap_eq_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L86-L87">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#swap_eq_iff"><span class="name">swap_eq_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Function/Defs.html#Function.swap">Function.swap</a> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Symmetric">Symmetric</a> <span class="fn">r</span></span></span></div></div></div></div><div class="decl" id="Reflexive.comap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L95-L95">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Reflexive.comap"><span class="name">Reflexive</span>.<span class="name">comap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Reflexive">Reflexive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Reflexive">Reflexive</a> <span class="fn">(<span class="fn">r</span> <a href="../.././Mathlib/Logic/Function/Defs.html#Function.onFun">on</a> <span class="fn">f</span>)</span></span></div></div></div></div><div class="decl" id="Symmetric.comap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L97-L97">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Symmetric.comap"><span class="name">Symmetric</span>.<span class="name">comap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Symmetric">Symmetric</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Symmetric">Symmetric</a> <span class="fn">(<span class="fn">r</span> <a href="../.././Mathlib/Logic/Function/Defs.html#Function.onFun">on</a> <span class="fn">f</span>)</span></span></div></div></div></div><div class="decl" id="Transitive.comap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L99-L100">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Transitive.comap"><span class="name">Transitive</span>.<span class="name">comap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Transitive">Transitive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Transitive">Transitive</a> <span class="fn">(<span class="fn">r</span> <a href="../.././Mathlib/Logic/Function/Defs.html#Function.onFun">on</a> <span class="fn">f</span>)</span></span></div></div></div></div><div class="decl" id="Equivalence.comap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L102-L103">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Equivalence.comap"><span class="name">Equivalence</span>.<span class="name">comap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">(<span class="fn">r</span> <a href="../.././Mathlib/Logic/Function/Defs.html#Function.onFun">on</a> <span class="fn">f</span>)</span></span></div></div></div></div><div class="decl" id="Relation.Comp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L113-L118">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.Comp"><span class="name">Relation</span>.<span class="name">Comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">γ</span> → <a href="../.././foundational_types.html">Prop</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn">γ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Prop</a></div></div><p>The composition of two relations, yielding a new relation.  The result
relates a term of <code>α</code> and a term of <code>γ</code> if there is an intermediate
term of <code>β</code> related to both.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Relation.Comp</a> <span class="fn">r</span> <span class="fn">p</span> <span class="fn">a</span> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">∃ (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">p</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span></span></li></ul></details><details id="instances-for-list-Relation.Comp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Relation.comp_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L123-L125">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.comp_eq"><span class="name">Relation</span>.<span class="name">comp_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Relation.Comp</a> <span class="fn">r</span> <span class="fn">fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">x1</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x2</span></span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></span></div></div></div></div><div class="decl" id="Relation.eq_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L127-L129">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.eq_comp"><span class="name">Relation</span>.<span class="name">eq_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Relation.Comp</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x1</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x2</span></span>)</span> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></span></div></div></div></div><div class="decl" id="Relation.iff_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L131-L133">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.iff_comp"><span class="name">Relation</span>.<span class="name">iff_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><a href="../.././foundational_types.html">Prop</a> → <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Relation.Comp</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <a href="../.././foundational_types.html">Prop</a>) =&gt; <span class="fn"><span class="fn">x1</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">x2</span></span>)</span> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></span></div></div></div></div><div class="decl" id="Relation.comp_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L135-L137">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.comp_iff"><span class="name">Relation</span>.<span class="name">comp_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn"><a href="../.././foundational_types.html">Prop</a> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Relation.Comp</a> <span class="fn">r</span> <span class="fn">fun (<span class="fn">x1</span> <span class="fn">x2</span> : <a href="../.././foundational_types.html">Prop</a>) =&gt; <span class="fn"><span class="fn">x1</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">x2</span></span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></span></div></div></div></div><div class="decl" id="Relation.comp_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L139-L144">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.comp_assoc"><span class="name">Relation</span>.<span class="name">comp_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{δ : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">γ</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">γ</span> → <span class="fn"><span class="fn">δ</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Relation.Comp</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Relation.Comp</a> <span class="fn">r</span> <span class="fn">p</span>)</span> <span class="fn">q</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Relation.Comp</a> <span class="fn">r</span> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Relation.Comp</a> <span class="fn">p</span> <span class="fn">q</span>)</span></span></span></div></div></div></div><div class="decl" id="Relation.flip_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L146-L151">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.flip_comp"><span class="name">Relation</span>.<span class="name">flip_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">γ</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Core.html#flip">flip</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Relation.Comp</a> <span class="fn">r</span> <span class="fn">p</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Relation.Comp</a> <span class="fn">(<a href="../.././Init/Core.html#flip">flip</a> <span class="fn">p</span>)</span> <span class="fn">(<a href="../.././Init/Core.html#flip">flip</a> <span class="fn">r</span>)</span></span></span></div></div></div></div><div class="decl" id="Relation.Fibration"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L159-L163">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.Fibration"><span class="name">Relation</span>.<span class="name">Fibration</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(rα : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(rβ : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Prop</a></div></div><p>A function <code>f : α → β</code> is a fibration between the relation <code>rα</code> and <code>rβ</code> if for all
<code>a : α</code> and <code>b : β</code>, whenever <code>b : β</code> and <code>f a</code> are related by <code>rβ</code>, <code>b</code> is the image
of some <code>a' : α</code> under <code>f</code>, and <code>a'</code> and <code>a</code> are related by <code>rα</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Fibration">Relation.Fibration</a> <span class="fn">rα</span> <span class="fn">rβ</span> <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">∀ ⦃<span class="fn">a</span> : <span class="fn">α</span>⦄ ⦃<span class="fn">b</span> : <span class="fn">β</span>⦄, <span class="fn"><span class="fn"><span class="fn">rβ</span> <span class="fn">b</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span> → <span class="fn">∃ (<span class="fn">a'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">rα</span> <span class="fn">a'</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a'</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></span></span></span></span></li></ul></details><details id="instances-for-list-Relation.Fibration" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Acc.of_fibration"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L167-L173">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Acc.of_fibration"><span class="name">Acc</span>.<span class="name">of_fibration</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{rα : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{rβ : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(fib : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Fibration">Relation.Fibration</a> <span class="fn">rα</span> <span class="fn">rβ</span> <span class="fn">f</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(ha : <span class="fn"><a href="../.././Init/WF.html#Acc">Acc</a> <span class="fn">rα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/WF.html#Acc">Acc</a> <span class="fn">rβ</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span></div></div><p>If <code>f : α → β</code> is a fibration between relations <code>rα</code> and <code>rβ</code>, and <code>a : α</code> is
accessible under <code>rα</code>, then <code>f a</code> is accessible under <code>rβ</code>.</p></div></div><div class="decl" id="Acc.of_downward_closed"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L175-L180">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Acc.of_downward_closed"><span class="name">Acc</span>.<span class="name">of_downward_closed</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{rβ : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(dc : <span class="fn">∀ {<span class="fn">a</span> : <span class="fn">α</span>} {<span class="fn">b</span> : <span class="fn">β</span>}, <span class="fn"><span class="fn"><span class="fn">rβ</span> <span class="fn">b</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span> → <span class="fn">∃ (<span class="fn">c</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(ha : <span class="fn"><a href="../.././Init/WF.html#Acc">Acc</a> <span class="fn">(<a href="../.././Init/Core.html#InvImage">InvImage</a> <span class="fn">rβ</span> <span class="fn">f</span>)</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/WF.html#Acc">Acc</a> <span class="fn">rβ</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span></div></div></div></div><div class="decl" id="Relation.Map"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L187-L193">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.Map"><span class="name">Relation</span>.<span class="name">Map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{δ : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">β</span> → <span class="fn">δ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">γ</span> → <span class="fn"><span class="fn">δ</span> → <a href="../.././foundational_types.html">Prop</a></span></span></div></div><p>The map of a relation <code>r</code> through a pair of functions pushes the
relation to the codomains of the functions.  The resulting relation is
defined by having pairs of terms related if they have preimages
related by <code>r</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Map">Relation.Map</a> <span class="fn">r</span> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">c</span> <span class="fn">d</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn">g</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span></span></span></span></span></span></li></ul></details><details id="instances-for-list-Relation.Map" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Relation.map_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L195-L195">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.map_apply"><span class="name">Relation</span>.<span class="name">map_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{δ : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">β</span> → <span class="fn">δ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">γ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Map">Relation.Map</a> <span class="fn">r</span> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">c</span> <span class="fn">d</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn">g</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span></span></span></span></span></span></div></div></div></div><div class="decl" id="Relation.map_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L197-L203">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.map_map"><span class="name">Relation</span>.<span class="name">map_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{δ : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ε : <a href="../.././foundational_types.html">Type</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ζ : <a href="../.././foundational_types.html">Type</a> u_6}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f₁ : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g₁ : <span class="fn"><span class="fn">β</span> → <span class="fn">δ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f₂ : <span class="fn"><span class="fn">γ</span> → <span class="fn">ε</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g₂ : <span class="fn"><span class="fn">δ</span> → <span class="fn">ζ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Map">Relation.Map</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Map">Relation.Map</a> <span class="fn">r</span> <span class="fn">f₁</span> <span class="fn">g₁</span>)</span> <span class="fn">f₂</span> <span class="fn">g₂</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Map">Relation.Map</a> <span class="fn">r</span> <span class="fn">(<span class="fn">f₂</span> <a href="../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">f₁</span>)</span> <span class="fn">(<span class="fn">g₂</span> <a href="../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">g₁</span>)</span></span></span></div></div></div></div><div class="decl" id="Relation.map_apply_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L205-L207">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.map_apply_apply"><span class="name">Relation</span>.<span class="name">map_apply_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{δ : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">β</span> → <span class="fn">δ</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../.././Mathlib/Logic/Function/Defs.html#Function.Injective">Function.Injective</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hg : <span class="fn"><a href="../.././Mathlib/Logic/Function/Defs.html#Function.Injective">Function.Injective</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Map">Relation.Map</a> <span class="fn">r</span> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">(<span class="fn">g</span> <span class="fn">b</span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Relation.map_id_id"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L209-L209">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.map_id_id"><span class="name">Relation</span>.<span class="name">map_id_id</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Map">Relation.Map</a> <span class="fn">r</span> <span class="fn">id</span> <span class="fn">id</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></span></div></div></div></div><div class="decl" id="Relation.instDecidableMapOfExistsAndEq"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L211-L212">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.instDecidableMapOfExistsAndEq"><span class="name">Relation</span>.<span class="name">instDecidableMapOfExistsAndEq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{δ : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">β</span> → <span class="fn">δ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">γ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <span class="fn">δ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn">g</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span></span></span></span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Map">Relation.Map</a> <span class="fn">r</span> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">c</span> <span class="fn">d</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Relation.instDecidableMapOfExistsAndEq</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">inst</span></span></li></ul></details></div></div><div class="decl" id="Relation.ReflTransGen"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L218-L222">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen"><span class="name">Relation</span>.<span class="name">ReflTransGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span></div></div><p><code><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> r</code>: reflexive transitive closure of <code>r</code></p><ul class="constructors"><li class="constructor" id="Relation.ReflTransGen.refl">refl: <span class="fn">∀ {<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1} {<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>} {<span class="fn">a</span> : <span class="fn">α</span>}, <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">a</span></span></span></li><li class="constructor" id="Relation.ReflTransGen.tail">tail: <span class="fn">∀ {<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1} {<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>} {<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span></span></span></span></li></ul><details id="instances-for-list-Relation.ReflTransGen" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Relation.ReflTransGen.cases_tail_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L219-L219">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.cases_tail_iff"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">cases_tail_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(a a✝ : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">a✝</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">a✝</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∃ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">r</span> <span class="fn">b</span> <span class="fn">a✝</span></span></span></span></span></span></div></div></div></div><div class="decl" id="Relation.ReflGen"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L226-L230">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen"><span class="name">Relation</span>.<span class="name">ReflGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span></div></div><p><code><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">ReflGen</a> r</code>: reflexive closure of <code>r</code></p><ul class="constructors"><li class="constructor" id="Relation.ReflGen.refl">refl: <span class="fn">∀ {<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1} {<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>} {<span class="fn">a</span> : <span class="fn">α</span>}, <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">Relation.ReflGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">a</span></span></span></li><li class="constructor" id="Relation.ReflGen.single">single: <span class="fn">∀ {<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1} {<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>} {<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">Relation.ReflGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></li></ul><details id="instances-for-list-Relation.ReflGen" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Relation.reflGen_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L227-L227">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflGen_iff"><span class="name">Relation</span>.<span class="name">reflGen_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(a a✝ : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">Relation.ReflGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">a✝</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">a✝</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">a✝</span></span></span></span></div></div></div></div><div class="decl" id="Relation.EqvGen"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L233-L239">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen"><span class="name">Relation</span>.<span class="name">EqvGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span></div></div><p><code><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">EqvGen</a> r</code>: equivalence closure of <code>r</code>.</p><ul class="constructors"><li class="constructor" id="Relation.EqvGen.rel">rel: <span class="fn">∀ {<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1} {<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>} (<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">Relation.EqvGen</a> <span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span></span></span></li><li class="constructor" id="Relation.EqvGen.refl">refl: <span class="fn">∀ {<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1} {<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>} (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">Relation.EqvGen</a> <span class="fn">r</span> <span class="fn">x</span> <span class="fn">x</span></span></span></li><li class="constructor" id="Relation.EqvGen.symm">symm: <span class="fn">∀ {<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1} {<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>} (<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">Relation.EqvGen</a> <span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">Relation.EqvGen</a> <span class="fn">r</span> <span class="fn">y</span> <span class="fn">x</span></span></span></span></li><li class="constructor" id="Relation.EqvGen.trans">trans: <span class="fn">∀ {<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1} {<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>} (<span class="fn">x </span><span class="fn">y </span><span class="fn">z</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">Relation.EqvGen</a> <span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">Relation.EqvGen</a> <span class="fn">r</span> <span class="fn">y</span> <span class="fn">z</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">Relation.EqvGen</a> <span class="fn">r</span> <span class="fn">x</span> <span class="fn">z</span></span></span></span></span></li></ul><details id="instances-for-list-Relation.EqvGen" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Relation.eqvGen_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L234-L234">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.eqvGen_iff"><span class="name">Relation</span>.<span class="name">eqvGen_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(a✝ a✝¹ : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">Relation.EqvGen</a> <span class="fn">r</span> <span class="fn">a✝</span> <span class="fn">a✝¹</span></span> <a href="../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a✝</span> <span class="fn">a✝¹</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn"><span class="fn">a✝¹</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a✝</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">Relation.EqvGen</a> <span class="fn">r</span> <span class="fn">a✝¹</span> <span class="fn">a✝</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∃ (<span class="fn">y</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">Relation.EqvGen</a> <span class="fn">r</span> <span class="fn">a✝</span> <span class="fn">y</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">Relation.EqvGen</a> <span class="fn">r</span> <span class="fn">y</span> <span class="fn">a✝¹</span></span></span></span></span></span></span></span></div></div></div></div><div class="decl" id="Relation.transGen_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L241-L241">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.transGen_iff"><span class="name">Relation</span>.<span class="name">transGen_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(a✝ a✝¹ : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a✝</span> <span class="fn">a✝¹</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a✝</span> <span class="fn">a✝¹</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∃ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a✝</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">r</span> <span class="fn">b</span> <span class="fn">a✝¹</span></span></span></span></span></span></div></div></div></div><div class="decl" id="Relation.ReflGen.to_reflTransGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L246-L248">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen.to_reflTransGen"><span class="name">Relation</span>.<span class="name">ReflGen</span>.<span class="name">to_reflTransGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">Relation.ReflGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Relation.ReflGen.mono"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L250-L252">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen.mono"><span class="name">Relation</span>.<span class="name">ReflGen</span>.<span class="name">mono</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r p : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hp : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">Relation.ReflGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">Relation.ReflGen</a> <span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Relation.ReflGen.instIsRefl"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L254-L255">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen.instIsRefl"><span class="name">Relation</span>.<span class="name">ReflGen</span>.<span class="name">instIsRefl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#IsRefl">IsRefl</a> <span class="fn">α</span> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">Relation.ReflGen</a> <span class="fn">r</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="Relation.ReflTransGen.trans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L261-L265">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.trans"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hab : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hbc : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.single"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L267-L268">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.single"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">single</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hab : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.head"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L270-L273">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.head"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">head</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hab : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hbc : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.symmetric"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L275-L279">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.symmetric"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">symmetric</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Symmetric">Symmetric</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Symmetric">Symmetric</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span>)</span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.cases_tail"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L281-L282">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.cases_tail"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">cases_tail</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∃ (<span class="fn">c</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">r</span> <span class="fn">c</span> <span class="fn">b</span></span></span></span></span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.head_induction_on"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L284-L293">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.head_induction_on"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">head_induction_on</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(refl : <span class="fn"><span class="fn">P</span> <span class="fn">b</span> <span class="fn">⋯</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(head : <span class="fn">∀ {<span class="fn">a </span><span class="fn">c</span> : <span class="fn">α</span>} (<span class="fn">h'</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span>) (<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">c</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">c</span> <span class="fn">h</span></span> → <span class="fn"><span class="fn">P</span> <span class="fn">a</span> <span class="fn">⋯</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">P</span> <span class="fn">a</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.trans_induction_on"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L295-L302">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.trans_induction_on"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">trans_induction_on</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>} → <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ih₁ : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">P</span> <span class="fn">⋯</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ih₂ : <span class="fn">∀ {<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>} (<span class="fn">h</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">⋯</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ih₃ : <span class="fn">∀ {<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>} (<span class="fn">h₁</span> : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>) (<span class="fn">h₂</span> : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">h₁</span></span> → <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">h₂</span></span> → <span class="fn"><span class="fn">P</span> <span class="fn">⋯</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">P</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.cases_head"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L304-L309">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.cases_head"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">cases_head</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∃ (<span class="fn">c</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">c</span> <span class="fn">b</span></span></span></span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.cases_head_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L311-L315">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.cases_head_iff"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">cases_head_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∃ (<span class="fn">c</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">c</span> <span class="fn">b</span></span></span></span></span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.total_of_right_unique"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L317-L327">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.total_of_right_unique"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">total_of_right_unique</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(U : <span class="fn"><a href="../.././Mathlib/Logic/Relator.html#Relator.RightUnique">Relator.RightUnique</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ab : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ac : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">c</span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Relation.TransGen.to_reflTransGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L333-L336">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.to_reflTransGen"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">to_reflTransGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.trans_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L338-L341">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.trans_left"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">trans_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hab : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hbc : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.instTransReflTransGen"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L343-L344">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.instTransReflTransGen"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">instTransReflTransGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Trans">Trans</a> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span>)</span> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span>)</span> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Relation.TransGen.instTransReflTransGen</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">trans</span> := <span class="fn">⋯</span> }</span></span></li></ul></details></div></div><div class="decl" id="Relation.TransGen.instTrans_mathlib"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L348-L349">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.instTrans_mathlib"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">instTrans_mathlib</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Trans">Trans</a> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span>)</span> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span>)</span> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Relation.TransGen.instTrans_mathlib</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">trans</span> := <span class="fn">⋯</span> }</span></span></li></ul></details></div></div><div class="decl" id="Relation.TransGen.head'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L351-L352">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.head'"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">head'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hab : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hbc : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.tail'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L354-L357">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.tail'"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">tail'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hab : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hbc : <span class="fn"><span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.head"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L359-L360">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.head"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">head</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hab : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hbc : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.head_induction_on"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L362-L371">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.head_induction_on"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">head_induction_on</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(base : <span class="fn">∀ {<span class="fn">a</span> : <span class="fn">α</span>} (<span class="fn">h</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">a</span> <span class="fn">⋯</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ih : <span class="fn">∀ {<span class="fn">a </span><span class="fn">c</span> : <span class="fn">α</span>} (<span class="fn">h'</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span>) (<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">c</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">c</span> <span class="fn">h</span></span> → <span class="fn"><span class="fn">P</span> <span class="fn">a</span> <span class="fn">⋯</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">P</span> <span class="fn">a</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.trans_induction_on"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L373-L380">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.trans_induction_on"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">trans_induction_on</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>} → <span class="fn"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(base : <span class="fn">∀ {<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>} (<span class="fn">h</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">⋯</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ih : <span class="fn">∀ {<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>} (<span class="fn">h₁</span> : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>) (<span class="fn">h₂</span> : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">h₁</span></span> → <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">h₂</span></span> → <span class="fn"><span class="fn">P</span> <span class="fn">⋯</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">P</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.trans_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L382-L385">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.trans_right"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">trans_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hab : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hbc : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.instTransReflTransGen_1"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L387-L388">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.instTransReflTransGen_1"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">instTransReflTransGen_1</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Trans">Trans</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span>)</span> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span>)</span> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Relation.TransGen.instTransReflTransGen_1</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">trans</span> := <span class="fn">⋯</span> }</span></span></li></ul></details></div></div><div class="decl" id="Relation.TransGen.tail'_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L390-L394">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.tail'_iff"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">tail'_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span></span></div></div></div></div><div class="decl" id="Relation.TransGen.head'_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L396-L402">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.head'_iff"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">head'_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span></span></div></div></div></div><div class="decl" id="Relation.reflGen_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L409-L411">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflGen_eq_self"><span class="name">Relation</span>.<span class="name">reflGen_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hr : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Reflexive">Reflexive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">Relation.ReflGen</a> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></span></div></div></div></div><div class="decl" id="Relation.reflexive_reflGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L413-L413">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflexive_reflGen"><span class="name">Relation</span>.<span class="name">reflexive_reflGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Reflexive">Reflexive</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">Relation.ReflGen</a> <span class="fn">r</span>)</span></span></div></div></div></div><div class="decl" id="Relation.reflGen_minimal"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L415-L417">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflGen_minimal"><span class="name">Relation</span>.<span class="name">reflGen_minimal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r r' : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hr' : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Reflexive">Reflexive</a> <span class="fn">r'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><span class="fn">r'</span> <span class="fn">x</span> <span class="fn">y</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{x y : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hxy : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">Relation.ReflGen</a> <span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">r'</span> <span class="fn">x</span> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="Relation.transGen_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L423-L428">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.transGen_eq_self"><span class="name">Relation</span>.<span class="name">transGen_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(trans : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Transitive">Transitive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></span></div></div></div></div><div class="decl" id="Relation.transitive_transGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L430-L430">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.transitive_transGen"><span class="name">Relation</span>.<span class="name">transitive_transGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Transitive">Transitive</a> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span>)</span></span></div></div></div></div><div class="decl" id="Relation.instIsTransTransGen"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L432-L433">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.instIsTransTransGen"><span class="name">Relation</span>.<span class="name">instIsTransTransGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#IsTrans">IsTrans</a> <span class="fn">α</span> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="Relation.transGen_idem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L435-L436">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.transGen_idem"><span class="name">Relation</span>.<span class="name">transGen_idem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span></span></span></div></div></div></div><div class="decl" id="Relation.TransGen.lift"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L438-L442">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.lift"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">lift</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">b</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hab : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">b</span>)</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.lift'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L444-L447">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.lift'"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">lift'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">b</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hab : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">b</span>)</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.closed"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L449-L451">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.closed"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">closed</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span>)</span> → <span class="fn"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="Relation.TransGen.closed'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L453-L455">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.closed'"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">closed'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(dc : <span class="fn">∀ {<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">P</span> <span class="fn">a</span></span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">P</span> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="Relation.TransGen.mono"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L457-L459">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.mono"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">mono</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span>)</span> → <span class="fn"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="Relation.transGen_minimal"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L461-L463">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.transGen_minimal"><span class="name">Relation</span>.<span class="name">transGen_minimal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r r' : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hr' : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Transitive">Transitive</a> <span class="fn">r'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><span class="fn">r'</span> <span class="fn">x</span> <span class="fn">y</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{x y : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hxy : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">r'</span> <span class="fn">x</span> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L465-L468">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.swap"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">(<a href="../.././Mathlib/Logic/Function/Defs.html#Function.swap">Function.swap</a> <span class="fn">r</span>)</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Relation.transGen_swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L470-L471">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.transGen_swap"><span class="name">Relation</span>.<span class="name">transGen_swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">(<a href="../.././Mathlib/Logic/Function/Defs.html#Function.swap">Function.swap</a> <span class="fn">r</span>)</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="Relation.reflTransGen_iff_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L479-L480">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_iff_eq"><span class="name">Relation</span>.<span class="name">reflTransGen_iff_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="Relation.reflTransGen_iff_eq_or_transGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L482-L489">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_iff_eq_or_transGen"><span class="name">Relation</span>.<span class="name">reflTransGen_iff_eq_or_transGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.lift"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L491-L493">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.lift"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">lift</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">b</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hab : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">b</span>)</span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.mono"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L495-L497">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.mono"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">mono</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span>)</span> → <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="Relation.reflTransGen_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L499-L504">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_eq_self"><span class="name">Relation</span>.<span class="name">reflTransGen_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(refl : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Reflexive">Reflexive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(trans : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Transitive">Transitive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></span></div></div></div></div><div class="decl" id="Relation.reflTransGen_minimal"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L506-L508">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_minimal"><span class="name">Relation</span>.<span class="name">reflTransGen_minimal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r r' : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hr₁ : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Reflexive">Reflexive</a> <span class="fn">r'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hr₂ : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Transitive">Transitive</a> <span class="fn">r'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><span class="fn">r'</span> <span class="fn">x</span> <span class="fn">y</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{x y : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hxy : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">r'</span> <span class="fn">x</span> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="Relation.reflexive_reflTransGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L510-L510">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflexive_reflTransGen"><span class="name">Relation</span>.<span class="name">reflexive_reflTransGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Reflexive">Reflexive</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span>)</span></span></div></div></div></div><div class="decl" id="Relation.transitive_reflTransGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L512-L512">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.transitive_reflTransGen"><span class="name">Relation</span>.<span class="name">transitive_reflTransGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Transitive">Transitive</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span>)</span></span></div></div></div></div><div class="decl" id="Relation.instIsReflReflTransGen"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L514-L515">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.instIsReflReflTransGen"><span class="name">Relation</span>.<span class="name">instIsReflReflTransGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#IsRefl">IsRefl</a> <span class="fn">α</span> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="Relation.instIsTransReflTransGen"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L517-L518">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.instIsTransReflTransGen"><span class="name">Relation</span>.<span class="name">instIsTransReflTransGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#IsTrans">IsTrans</a> <span class="fn">α</span> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="Relation.reflTransGen_idem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L520-L521">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_idem"><span class="name">Relation</span>.<span class="name">reflTransGen_idem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span></span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.lift'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L523-L526">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.lift'"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">lift'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">b</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hab : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">b</span>)</span></span></div></div></div></div><div class="decl" id="Relation.reflTransGen_closed"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L528-L530">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_closed"><span class="name">Relation</span>.<span class="name">reflTransGen_closed</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span>)</span> → <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L532-L535">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.swap"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">(<a href="../.././Mathlib/Logic/Function/Defs.html#Function.swap">Function.swap</a> <span class="fn">r</span>)</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Relation.reflTransGen_swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L537-L538">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_swap"><span class="name">Relation</span>.<span class="name">reflTransGen_swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">(<a href="../.././Mathlib/Logic/Function/Defs.html#Function.swap">Function.swap</a> <span class="fn">r</span>)</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="Relation.reflGen_transGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L540-L542">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflGen_transGen"><span class="name">Relation</span>.<span class="name">reflGen_transGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">Relation.ReflGen</a> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span></span></span></div></div></div></div><div class="decl" id="Relation.transGen_reflGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L544-L551">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.transGen_reflGen"><span class="name">Relation</span>.<span class="name">transGen_reflGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">Relation.ReflGen</a> <span class="fn">r</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span></span></span></div></div></div></div><div class="decl" id="Relation.reflTransGen_reflGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L553-L554">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_reflGen"><span class="name">Relation</span>.<span class="name">reflTransGen_reflGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">Relation.ReflGen</a> <span class="fn">r</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span></span></span></div></div></div></div><div class="decl" id="Relation.reflTransGen_transGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L556-L557">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_transGen"><span class="name">Relation</span>.<span class="name">reflTransGen_transGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span></span></span></div></div></div></div><div class="decl" id="Relation.reflTransGen_eq_transGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L559-L561">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_eq_transGen"><span class="name">Relation</span>.<span class="name">reflTransGen_eq_transGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hr : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Reflexive">Reflexive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span></span></span></div></div></div></div><div class="decl" id="Relation.reflTransGen_eq_reflGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L563-L565">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_eq_reflGen"><span class="name">Relation</span>.<span class="name">reflTransGen_eq_reflGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hr : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Transitive">Transitive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">Relation.ReflGen</a> <span class="fn">r</span></span></span></div></div></div></div><div class="decl" id="Relation.EqvGen.is_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L573-L574">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen.is_equivalence"><span class="name">Relation</span>.<span class="name">EqvGen</span>.<span class="name">is_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">Relation.EqvGen</a> <span class="fn">r</span>)</span></span></div></div></div></div><div class="decl" id="Relation.EqvGen.setoid"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L576-L581">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen.setoid"><span class="name">Relation</span>.<span class="name">EqvGen</span>.<span class="name">setoid</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span></div></div><p><code><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen.setoid">EqvGen.setoid</a> r</code> is the setoid generated by a relation <code>r</code>.</p><p>The motivation for this definition is that <code><a href="../.././Init/Prelude.html#Quot">Quot</a> r</code> behaves like <code><a href="../.././Init/Core.html#Quotient">Quotient</a> (EqvGen.<a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen.setoid">setoid</a> r)</code>,
see for example <code><a href="../.././Mathlib/Logic/Relation.html#Quot.eqvGen_exact">Quot.eqvGen_exact</a></code> and <code><a href="../.././Mathlib/Logic/Relation.html#Quot.eqvGen_sound">Quot.eqvGen_sound</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen.setoid">Relation.EqvGen.setoid</a> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">r</span> := <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">Relation.EqvGen</a> <span class="fn">r</span></span>, <span class="fn">iseqv</span> := <span class="fn">⋯</span> }</span></span></li></ul></details><details id="instances-for-list-Relation.EqvGen.setoid" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Relation.EqvGen.mono"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L583-L589">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen.mono"><span class="name">Relation</span>.<span class="name">EqvGen</span>.<span class="name">mono</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r p : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hrp : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">Relation.EqvGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">Relation.EqvGen</a> <span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="EqvGen.is_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L591-L591">source</a></div><div class="attributes">@[deprecated Relation.EqvGen.is_equivalence]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#EqvGen.is_equivalence"><span class="name">EqvGen</span>.<span class="name">is_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">Relation.EqvGen</a> <span class="fn">r</span>)</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen.is_equivalence">Relation.EqvGen.is_equivalence</a></code>.</p></div></div><div class="decl" id="EqvGen.Setoid"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L592-L592">source</a></div><div class="attributes">@[deprecated Relation.EqvGen.setoid]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#EqvGen.Setoid"><span class="name">EqvGen</span>.<span class="name">Setoid</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen.setoid">Relation.EqvGen.setoid</a></code>.</p><hr></hr><p><code><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen.setoid">EqvGen.setoid</a> r</code> is the setoid generated by a relation <code>r</code>.</p><p>The motivation for this definition is that <code><a href="../.././Init/Prelude.html#Quot">Quot</a> r</code> behaves like <code><a href="../.././Init/Core.html#Quotient">Quotient</a> (EqvGen.<a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen.setoid">setoid</a> r)</code>,
see for example <code><a href="../.././Mathlib/Logic/Relation.html#Quot.eqvGen_exact">Quot.eqvGen_exact</a></code> and <code><a href="../.././Mathlib/Logic/Relation.html#Quot.eqvGen_sound">Quot.eqvGen_sound</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#EqvGen.Setoid">@<a href="../.././Mathlib/Logic/Relation.html#EqvGen.Setoid">EqvGen.Setoid</a></a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen.setoid">@<a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen.setoid">Relation.EqvGen.setoid</a></a></span></li></ul></details><details id="instances-for-list-EqvGen.Setoid" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="EqvGen.mono"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L593-L593">source</a></div><div class="attributes">@[deprecated Relation.EqvGen.mono]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#EqvGen.mono"><span class="name">EqvGen</span>.<span class="name">mono</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r p : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hrp : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">Relation.EqvGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">Relation.EqvGen</a> <span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen.mono">Relation.EqvGen.mono</a></code>.</p></div></div><div class="decl" id="Relation.Join"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L597-L604">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.Join"><span class="name">Relation</span>.<span class="name">Join</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span></div></div><p>The join of a relation on a single type is a new relation for which
pairs of terms are related if there is a third term they are both
related to.  For example, if <code>r</code> is a relation representing rewrites
in a term rewriting system, then <em>confluence</em> is the property that if
<code>a</code> rewrites to both <code>b</code> and <code>c</code>, then <code>join r</code> relates <code>b</code> and <code>c</code>
(see <code><a href="../.././Mathlib/Logic/Relation.html#Relation.church_rosser">Relation.church_rosser</a></code>).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Relation.Join</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">∃ (<span class="fn">c</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span></span></li></ul></details><details id="instances-for-list-Relation.Join" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Relation.church_rosser"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L610-L631">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.church_rosser"><span class="name">Relation</span>.<span class="name">church_rosser</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span> → <span class="fn">∃ (<span class="fn">d</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">Relation.ReflGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">d</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">c</span> <span class="fn">d</span></span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hab : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hac : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Relation.Join</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span>)</span> <span class="fn">b</span> <span class="fn">c</span></span></div></div><p>A sufficient condition for the Church-Rosser property.</p></div></div><div class="decl" id="Relation.join_of_single"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L634-L635">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.join_of_single"><span class="name">Relation</span>.<span class="name">join_of_single</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Reflexive">Reflexive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hab : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Relation.Join</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Relation.symmetric_join"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L637-L637">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.symmetric_join"><span class="name">Relation</span>.<span class="name">symmetric_join</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Symmetric">Symmetric</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Relation.Join</a> <span class="fn">r</span>)</span></span></div></div></div></div><div class="decl" id="Relation.reflexive_join"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L639-L639">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflexive_join"><span class="name">Relation</span>.<span class="name">reflexive_join</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Reflexive">Reflexive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Reflexive">Reflexive</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Relation.Join</a> <span class="fn">r</span>)</span></span></div></div></div></div><div class="decl" id="Relation.transitive_join"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L641-L645">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.transitive_join"><span class="name">Relation</span>.<span class="name">transitive_join</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(ht : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Transitive">Transitive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Relation.Join</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Transitive">Transitive</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Relation.Join</a> <span class="fn">r</span>)</span></span></div></div></div></div><div class="decl" id="Relation.equivalence_join"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L647-L649">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.equivalence_join"><span class="name">Relation</span>.<span class="name">equivalence_join</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hr : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Reflexive">Reflexive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ht : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Transitive">Transitive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Relation.Join</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Relation.Join</a> <span class="fn">r</span>)</span></span></div></div></div></div><div class="decl" id="Relation.equivalence_join_reflTransGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L651-L654">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.equivalence_join_reflTransGen"><span class="name">Relation</span>.<span class="name">equivalence_join_reflTransGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span> → <span class="fn">∃ (<span class="fn">d</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">Relation.ReflGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">d</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">c</span> <span class="fn">d</span></span></span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Relation.Join</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span>)</span>)</span></span></div></div></div></div><div class="decl" id="Relation.join_of_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L656-L658">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.join_of_equivalence"><span class="name">Relation</span>.<span class="name">join_of_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r' : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hr : <span class="fn"><a href="../.././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r'</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Relation.Join</a> <span class="fn">r'</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Relation.reflTransGen_of_transitive_reflexive"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L660-L664">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_of_transitive_reflexive"><span class="name">Relation</span>.<span class="name">reflTransGen_of_transitive_reflexive</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r' : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hr : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Reflexive">Reflexive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ht : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Transitive">Transitive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r'</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h' : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r'</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Relation.reflTransGen_of_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L666-L668">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_of_equivalence"><span class="name">Relation</span>.<span class="name">reflTransGen_of_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r' : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hr : <span class="fn"><a href="../.././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r'</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span>)</span> → <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r'</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="Quot.eqvGen_exact"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L680-L682">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Quot.eqvGen_exact"><span class="name">Quot</span>.<span class="name">eqvGen_exact</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">b</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">Relation.EqvGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Quot.eqvGen_sound"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L684-L690">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Quot.eqvGen_sound"><span class="name">Quot</span>.<span class="name">eqvGen_sound</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">Relation.EqvGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Equivalence.eqvGen_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L692-L701">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Equivalence.eqvGen_iff"><span class="name">Equivalence</span>.<span class="name">eqvGen_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">Relation.EqvGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Equivalence.eqvGen_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L703-L704">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Equivalence.eqvGen_eq"><span class="name">Equivalence</span>.<span class="name">eqvGen_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">Relation.EqvGen</a> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></span></div></div></div></div><div class="decl" id="Quot.exact"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L706-L706">source</a></div><div class="attributes">@[deprecated Quot.eqvGen_exact]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Quot.exact"><span class="name">Quot</span>.<span class="name">exact</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">b</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">Relation.EqvGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Logic/Relation.html#Quot.eqvGen_exact">Quot.eqvGen_exact</a></code>.</p></div></div><div class="decl" id="Quot.EqvGen_sound"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84/Mathlib/Logic/Relation.lean#L707-L707">source</a></div><div class="attributes">@[deprecated Quot.eqvGen_sound]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Quot.EqvGen_sound"><span class="name">Quot</span>.<span class="name">EqvGen_sound</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">Relation.EqvGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">b</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Logic/Relation.html#Quot.eqvGen_sound">Quot.eqvGen_sound</a></code>.</p></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>